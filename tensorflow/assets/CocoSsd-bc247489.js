import{a as we,dR as zd,dS as Ud,dT as Pa,a5 as Gd,dU as Hd,dV as Xd,dW as Zn,dX as Qt,dZ as Eo,l as le,dI as _a,w as qd,c_ as jd,f as H,X as fs,d_ as J,K as Re,d$ as ts,e0 as on,e1 as st,e2 as Kd,bV as Le,de as Yd,c7 as Qd,d4 as Zd,e3 as Jd,e4 as ms,e5 as ns,c$ as Fo,e6 as ye,b9 as Do,bo as Oo,bv as Ao,bx as Po,bz as _o,bB as Mo,bC as Lo,bH as Vo,bI as Bo,bL as Wo,di as zo,bX as Uo,dm as Go,bN as ep,e7 as ia,b_ as Ho,ct as tp,c4 as np,bt as Oe,d7 as ot,e8 as rt,bu as Wt,dl as pt,e9 as Fn,ea as sp,eb as ap,ec as op,ed as rp,aJ as ip,r as cp,ar as lp,ee as up,cb as Xo,dy as qo,b4 as dp,dz as pp,ef as hp,eg as fp,eh as mp,ei as gp,ej as xp,ek as Cp,el as $p,em as bp,en as Ip,eo as vp,ep as yp,eq as wp,er as Ma,es as Sp,et as kp,eu as Rp,dA as jo,ck as Ko,ev as Np,dD as Yo,ew as $n,n as ke,ex as Tp,da as Qo,df as Ep,dp as Fp,ds as Zo,dr as Jo,dt as Dp,ey as Op,b3 as Ap,cy as Pp,aR as er,aS as tr,A as _p,aT as Mp,ez as zt,aU as Lp,aV as Vp,aW as Bp,aX as nr,aY as sr,aZ as ar,a_ as or,a$ as rr,b0 as Wp,Q as ca,c3 as Dn,b as la,b1 as zp,eA as gs,d1 as Up,d2 as Gp,b7 as Hp,b6 as Xp,eB as ir,eC as cr,eD as lr,eE as qp,eF as jp,b8 as Kp,B as Yp,ba as ur,d5 as Qp,bD as Zp,b2 as Jp,eG as eh,eH as _s,bc as th,eI as ua,V as rn,cu as nh,bd as sh,be as ah,eJ as da,d6 as oh,bf as rh,bg as dr,bh as pr,cz as ih,bi as ch,bW as lh,dd as hr,bj as uh,bk as dh,bl as ph,bm as hh,cw as fh,cx as mh,D as gh,bn as xh,eK as pa,d9 as La,an as Yt,eL as fr,d8 as Va,dE as Ch,e as $h,eM as bh,eN as Ih,eO as vh,eP as yh,eQ as wh,db as Sh,bq as mr,eR as kh,eS as Rh,eT as Nh,eU as Th,eV as Eh,eW as Fh,bw as Dh,dq as gr,eX as xr,eY as Oh,eZ as Ah,e_ as Ph,e$ as _h,f0 as Mh,f1 as Lh,ch as Vh,f2 as Bh,f3 as Wh,cA as zh,dc as Cr,cv as Uh,Z as Gh,J as Hh,f4 as Xh,bA as qh,f5 as jh,ci as Kh,bE as $r,bF as br,bG as Ir,L as Yh,bM as vr,bP as yr,bQ as wr,bR as Sr,bK as Qh,dh as Zh,br as Jh,bS as ef,bT as tf,dj as nf,dk as sf,M as af,bU as of,bs as rf,bY as cf,bZ as kr,cg as lf,h as uf,c5 as df,cC as pf,cD as hf,cG as ff,cH as mf,cE as gf,cF as xf,b$ as Cf,dF as $f,c0 as bf,cm as If,x as vf,c1 as yf,dn as Rr,R as wf,j as Sf,c6 as kf,c8 as Nr,cI as Rf,du as Nf,cJ as Tf,dv as Ef,c9 as Ff,cB as Df,f6 as Of,ca as Tr,H as Af,f7 as Er,S as Pf,bp as _f,cc as Fr,dw as Mf,dx as Lf,cd as Dr,ce as Or,cf as Ar,bO as Pr,c2 as Vf,cL as Bf,cM as Wf,cN as zf,cO as Uf,I as Gf,cj as Hf,f8 as Xf,dB as qf,dC as _r,cn as jf,f9 as Kf,fa as Yf,cP as Qf,cQ as Zf,cR as Jf,co as Mr,b5 as Lr,by as em,cp as tm,cK as nm,fb as ha,cq as sm,cs as am,cr as om,fc as rm,fr as Vr,aN as im}from"./index-c5cb974d.js";import{bK as Br,bL as Ba,g as ae,bM as qs,c as Jn,bN as Wr,bO as zr,bP as Ue,bQ as Wa,bR as Ne,bS as qt,bT as ss,bU as In,bV as Ur,d as Me,bW as Gr,bJ as dt,a as xe,bX as Qe,h as re,m as ne,bG as It,n as Ze,bY as Lt,bZ as Hr,p as Mt,b_ as js,b$ as Xr,c0 as qr,c1 as jr,c2 as Kr,c3 as Yr,c4 as Qr,c5 as Zr,A as Jr,c6 as ei,c7 as ti,y as ni,z as si,F as ai,K as oi,L as ri,c8 as ii,c9 as ci,ca as li,cb as ui,cc as di,cd as pi,M as hi,ce as fi,cf as mi,cg as gi,P as xi,U as Ci,ch as $i,ci as bi,cj as cm,V as Ii,W as vi,X as yi,ck as wi,cl as Si,Y as ki,Z as Ri,cm as Ni,a1 as Ti,cn as Ei,co as Fi,cp as Di,a2 as Oi,a3 as Ai,a4 as Pi,a5 as _i,a7 as Mi,bw as Li,cq as Vi,a8 as Bi,a9 as Wi,cr as zi,cs as Ui,ct as Gi,cu as Hi,cv as lm,cw as um,cx as dm,cy as Xi,aa as qi,cz as ji,cA as pm,ab as Ki,cB as Yi,ac as Qi,ad as Zi,cC as Ji,cD as ec,ae as tc,af as nc,ag as sc,ah as ac,cE as oc,ai as rc,aj as ic,ak as cc,al as lc,am as uc,an as dc,ao as pc,cF as hc,I as fc,cG as mc,cH as gc,cI as xc,cJ as Cc,bv as $c,cK as bc,cL as Ic,ap as vc,aq as yc,ar as wc,cM as Sc,as as kc,cN as Rc,cO as hm,at as Nc,au as Tc,av as Ec,aw as fm,cP as mm,ax as Fc,az as Dc,cQ as Oc,cR as Ac,cS as Pc,cT as _c,ay as Mc,aA as Lc,aB as Vc,aC as Bc,aD as Wc,cU as zc,cV as Uc,aE as Gc,aF as Hc,aG as Xc,aH as qc,aI as jc,aJ as Kc,cW as gm,aK as Yc,aL as Qc,aM as Zc,aO as Jc,cX as xm,aP as el,aQ as tl,aR as nl,cY as sl,cZ as al,aS as ol,c_ as Cm,c$ as rl,aT as il,d0 as cl,d1 as $m,aU as ll,aV as ul,R as dl,aW as pl,d2 as hl,aX as fl,d3 as ml,aY as gl,aZ as xl,a_ as Cl,a$ as $l,b0 as bl,d4 as Il,b2 as vl,d5 as yl,b3 as wl,d6 as Sl,b4 as kl,d7 as Rl,S as Nl,b5 as Tl,d8 as El,b6 as Fl,b7 as Dl,b8 as Ol,b9 as Al,ba as Pl,d9 as _l,bb as Ml,bc as Ll,bd as Vl,be as Bl,bf as Wl,bg as zl,bh as Ul,bi as Gl,bj as Hl,bk as Xl,bl as ql,bm as jl,bn as Kl,T as bm,da as Ks,bo as Yl,bp as Ql,bq as Zl,B as Jl,db as eu,br as tu,dc as nu,dd as Im,de as vm,bs as su,_ as au,df as ym,dg as wm,dh as Sm,di as km,dj as Rm,bI as Nm,dk as Tm,dl as Em,dm as Fm,dn as Dm,dp as Om,dq as Am,dr as Pm,ds as _m,bF as Mm,dt as Lm,du as Vm,dv as Bm,dw as Wm,dx as zm,dy as Um,dz as Gm,dA as Hm,dB as Xm,dC as ou,dD as qm,dE as jm,dF as Ve,dG as Km,u as Ym,dH as Qm,dI as Zm,q as Jm,dJ as eg,dK as tg,dL as ng,dM as sg,dN as ag,dO as og,dP as rg,dQ as ig,dR as cg,dS as lg,dT as ug,dU as dg,dV as pg,dW as hg,dX as fg,dY as mg,dZ as gg,d_ as xg,d$ as Cg,e0 as $g,e1 as bg,e2 as Ig,e3 as vg,e4 as yg,e5 as wg,e6 as Sg,e7 as kg,e8 as Rg,e9 as Ng,ea as Tg,eb as Eg,ec as Fg,ed as Dg,bx as At,bu as A,ee as Og,ef as Ag,eg as Pg,o as _g,e as Mg,eh as Lg,ei as Vg,ej as Bg,ek as Wg,el as zg,em as Ug,en as Gg,eo as Hg,ep as Xg,eq as qg,bB as jg,er as Kg,es as Yg,et as Qg,eu as Zg,ev as Jg,ew as ex,ex as tx,ey as nx,ez as sx,i as ax,eA as ox,eB as rx,eC as ix,eD as cx,eE as lx,eF as ux,eG as dx,eH as px,eI as hx,eJ as fx,eK as mx,eL as gx,eM as xx,eN as Cx,eO as $x,eP as bx,eQ as Ix,eR as vx,eS as yx,eT as wx,eU as Sx,eV as kx,eW as Rx,eX as Nx,eY as Tx,eZ as Ex,e_ as Fx,e$ as Dx,f0 as Ox,f1 as Ax,f2 as Px,bH as _x,bD as Mx,f3 as Lx,f4 as Vx,f5 as Bx,f6 as Wx,f7 as zx,f8 as Ux,f9 as Gx,fa as Hx,fb as Xx,fc as qx,fd as jx,bC as Kx,fe as Yx,ff as Qx,fg as Zx,fh as Jx,fi as e1,fj as t1,fk as n1,fl as s1,fm as a1,fn as o1,fo as r1,fp as i1,fq as c1,fr as l1,fs as u1,ft as d1,fu as p1,fv as h1,fw as f1,fx as m1,bA as ru,fy as g1,bt as iu,fz as x1,fA as C1,fB as $1,r as cu,fC as b1,fD as I1,fE as v1,fF as y1,fG as w1,fH as S1,fI as k1,fJ as R1,fK as N1,fL as T1,fM as E1,fN as F1,fO as D1,fP as O1,fQ as A1,fR as P1,v as _1,fS as M1,fT as L1,fU as V1,fV as B1,k as W1,fW as z1,fX as U1,fY as G1,fZ as H1,f_ as X1,f$ as q1,g0 as j1,g1 as K1,g2 as Y1,g3 as Q1,g4 as Z1,g5 as J1,s as eC,g6 as tC,g7 as nC,g8 as sC,g9 as aC,ga as oC,gb as xs,gc as rC,gd as iC,ge as cC,j as lC,b as uC,gf as dC,gg as pC,gh as hC,gi as fC,gj as mC,gk as gC,gl as xC,gm as CC,gn as $C,go as bC,gp as IC,gq as vC,gr as yC,gs as wC,gt as vt,gu as SC,gv as kC,gw as RC,gx as NC,gy as TC,gz as EC,gA as FC,bE as lu,gB as DC,gC as OC,l as AC,gD as PC,gE as _C,w as _e,Q as je,x as Y,gF as yt,gG as Ys,gH as fa,gI as Qs,gJ as MC,gK as ma,gL as cn,H as ht,gM as nt,gN as bn,C as Ae,gO as Zs,gP as za,gQ as ga,gR as Ut,gS as uu,gT as Ua,by as Dt,gU as xa,gV as LC,gW as Cs,bz as VC,gX as BC,O as WC,gY as zC,D as et,E as tt,G as it,J as St,gZ as On,N as An,g_ as $s,g$ as UC,$ as bs,a0 as kt,h0 as Ca,a6 as du,h1 as GC,h2 as HC,aN as XC,b1 as pu}from"./graph_model-9162a669.js";import{K as hu,L as qC,M as jC,N as KC,O as YC,P as QC,Q as ZC,R as JC,t as e0,q as t0,o as n0,x as s0,w as a0,y as o0,v as r0,u as i0,z as Ga,C as c0,B as l0,A as u0,j as d0,r as p0,s as h0,G as f0,H as m0,I as g0,S as Ha,T as Xa,U as $a,p as x0,V as C0,i as $0,c as b0,g as fu,a as mu,b as gu,d as I0,e as v0,h as Zt,f as y0,W as w0,X as S0,Y as k0,Z as R0,_ as N0,$ as T0,a0 as E0,a1 as F0,a2 as D0,a3 as O0,a4 as A0,l as P0,m as _0,n as M0,a5 as L0,a6 as V0,D as B0,E as W0,F as z0,a7 as U0,a8 as G0,J as H0}from"./useCanvas-e82d40eb.js";import{u as X0}from"./useVideo-abc8b4ae.js";import{d as q0,f as Ms,h as j0,c as qa,i as Ls,u as Vs,t as K0,j as Y0,o as ja}from"./index-bce47476.js";import{_ as Q0}from"./_plugin-vue_export-helper-c27b6911.js";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0(s,t,e){const a=Ba(s,"labels","confusionMatrix"),n=Ba(t,"predictions","confusionMatrix");ae(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),ae(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),ae(n.rank===1,()=>`Expected the rank of predictions to be 1, but got ${n.rank}`),ae(a.shape[0]===n.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${n.shape[0]}. Labels and predictions should have the same number of elements.`),ae(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);const o=qs(Jn(a,"int32"),e),r=qs(Jn(n,"int32"),e),c=Wr(o),i=zr(c,r);return Jn(i,"int32")}const J0=Br({confusionMatrix_:Z0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:J0},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xu{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class bt{constructor(){this.classNameMap={}}static getMap(){return bt.instance==null&&(bt.instance=new bt),bt.instance}static register(t){bt.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Rt(s){ae(s.className!=null,()=>"Class being registered does not have the static className property defined."),ae(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),ae(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),bt.register(s)}const t$=Object.freeze(Object.defineProperty({__proto__:null,Serializable:xu,SerializationMap:bt,registerClass:Rt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$=.001,Cu=.1;function s$(s,t,e){return e==null&&(e=ba()),Js(s,t,(a,n)=>Ia(a,n,e))}function ba(){return Ue.backend.floatPrecision()===32?n$:Cu}function Js(s,t,e){let a=!0;if((qt(s)||qt(t))&&(a=!1),qt(s)&&qt(t)&&(a=!0),a){const r=s.constructor.name,c=t.constructor.name;if(r!==c)throw new Error(`Arrays are of different type. Actual: ${r}. Expected: ${c}`)}if(Array.isArray(s)&&Array.isArray(t)){const r=Wa(s),c=Wa(t);if(!Ne(r,c))throw new Error(`Arrays have different shapes. Actual: [${r}]. Expected: [${c}]`)}const n=qt(s)?s:ss(s),o=qt(t)?t:ss(t);if(n.length!==o.length)throw new Error(`Arrays have different lengths actual: ${n.length} vs expected: ${o.length}.
Actual:   ${n}.
Expected: ${o}.`);for(let r=0;r<o.length;++r){const c=n[r],i=o[r];if(!e(c,i))throw new Error(`Arrays differ: actual[${r}] = ${c}, expected[${r}] = ${i}.
Actual:   ${n}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function a$(s,t){s().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function o$(s,t){const e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return In(s)||In(s[0])||In(t)||In(t[0])?Js(s,e,(a,n)=>a==n):Js(s,t,(a,n)=>Ia(a,n,0))}function r$(s,t,e){if(e==null&&(e=ba()),!Ia(s,t,e))throw new Error(`Numbers differ: actual === ${s}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Ia(s,t,e){return!isFinite(s)&&!isFinite(t)?!0:!(isNaN(s)||isNaN(t)||Math.abs(s-t)>e)}function i$(s,t,e){for(let a=0;a<s.length;a++)if(s[a]<t||s[a]>e)throw new Error(`Value out of range:${s[a]} low: ${t}, high: ${e}`)}function c$(s,t){const e=new Float32Array(s),a=new Float32Array(t);if(e.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${e.length}`);for(let n=0;n<a.length;n++)if(e[n]!==a[n])throw new Error(`Expected ArrayBuffer value at ${n} to be ${a[n]} but got ${e[n]} instead`)}function $u(s){for(let t=0;t<s.length;t++){const e=s[t];Array.isArray(e)?$u(e):s[t]=Ur(e)}return s}function l$(s){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(s),new Promise(e=>{t.addEventListener("loadeddata",a=>e(t)),t.load()})}async function u$(s){await s.play(),"requestVideoFrameCallback"in s&&await new Promise(t=>{s.requestVideoFrameCallback(t)})}const d$=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Cu,createVideoElement:l$,encodeStrings:$u,expectArrayBuffersEqual:c$,expectArraysClose:s$,expectArraysEqual:o$,expectNumbersClose:r$,expectPromiseToFail:a$,expectValuesInRange:i$,play:u$,testEpsilon:ba},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const p$="3.21.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nt extends xu{minimize(t,e=!1,a){const{value:n,grads:o}=this.computeGradients(t,a);if(a!=null){const r=a.map(c=>({name:c.name,tensor:o[c.name]}));this.applyGradients(r)}else this.applyGradients(o);return Me(o),e?n:(n.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Gr(t,e)}dispose(){this.iterations_!=null&&Me(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:dt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Nt,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Is extends Nt{constructor(t,e,a=null){super(),this.learningRate=t,this.rho=e,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],a==null&&(this.epsilon=Ue.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,n)=>{const o=Ue.registeredVariables[a],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${a}/accum_grad`,variable:xe(()=>Qe(o).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${a}/accum_var`,variable:xe(()=>Qe(o).variable(r))});const c=Array.isArray(t)?t[n].tensor:t[a];if(c==null)return;const i=this.accumulatedGrads[n].variable,l=this.accumulatedUpdates[n].variable;xe(()=>{const u=re(ne(i,this.rho),ne(It(c),1-this.rho)),d=ne(Ze(Lt(re(l,this.epsilon)),Lt(re(i,this.epsilon))),c),p=re(ne(l,this.rho),ne(It(d),1-this.rho));i.assign(u),l.assign(p);const h=re(ne(d,-this.learningRate),o);o.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Me(this.accumulatedGrads.map(t=>t.variable)),Me(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,a=!1;this.accumulatedGrads=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedUpdates=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}Is.className="Adadelta";Rt(Is);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vs extends Nt{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,n)=>{const o=Ue.registeredVariables[a];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${a}/accumulator`,variable:xe(()=>Hr(o.shape,this.initialAccumulatorValue).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[a];if(r==null)return;const c=this.accumulatedGrads[n].variable;xe(()=>{const i=re(c,It(r));c.assign(i);const l=re(ne(Ze(r,Lt(re(i,Ue.backend.epsilon()))),-this.learningRate),o);o.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Me(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(a=>({originalName:a.name,variable:a.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}vs.className="Adagrad";Rt(vs);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ys extends Nt{constructor(t,e,a,n=null){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],xe(()=>{this.accBeta1=dt(e).variable(),this.accBeta2=dt(a).variable()}),n==null&&(this.epsilon=Ue.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);xe(()=>{const a=Mt(1,this.accBeta1),n=Mt(1,this.accBeta2);e.forEach((o,r)=>{const c=Ue.registeredVariables[o],i=!1;this.accumulatedFirstMoment[r]==null&&(this.accumulatedFirstMoment[r]={originalName:`${o}/m`,variable:xe(()=>Qe(c).variable(i))}),this.accumulatedSecondMoment[r]==null&&(this.accumulatedSecondMoment[r]={originalName:`${o}/v`,variable:xe(()=>Qe(c).variable(i))});const l=Array.isArray(t)?t[r].tensor:t[o];if(l==null)return;const u=this.accumulatedFirstMoment[r].variable,d=this.accumulatedSecondMoment[r].variable,p=re(ne(u,this.beta1),ne(l,1-this.beta1)),h=re(ne(d,this.beta2),ne(It(l),1-this.beta2)),f=Ze(p,a),x=Ze(h,n);u.assign(p),d.assign(h);const m=re(ne(Ze(f,re(Lt(x),this.epsilon)),-this.learningRate),c);c.assign(m)}),this.accBeta1.assign(ne(this.accBeta1,this.beta1)),this.accBeta2.assign(ne(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Me(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Me(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),xe(()=>{this.accBeta1.assign(js(this.beta1,this.iterations_+1)),this.accBeta2.assign(js(this.beta2,this.iterations_+1))});const e=t.length/2,a=!1;this.accumulatedFirstMoment=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}ys.className="Adam";Rt(ys);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ws extends Nt{constructor(t,e,a,n=null,o=0){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=n,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],xe(()=>{this.iteration=dt(0).variable(),this.accBeta1=dt(e).variable()}),n==null&&(this.epsilon=Ue.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);xe(()=>{const a=Mt(1,this.accBeta1),n=Ze(-this.learningRate,re(ne(this.iteration,this.decay),1));e.forEach((o,r)=>{const c=Ue.registeredVariables[o],i=!1;this.accumulatedFirstMoment[r]==null&&(this.accumulatedFirstMoment[r]={originalName:`${o}/m`,variable:Qe(c).variable(i)}),this.accumulatedWeightedInfNorm[r]==null&&(this.accumulatedWeightedInfNorm[r]={originalName:`${o}/v`,variable:Qe(c).variable(i)});const l=Array.isArray(t)?t[r].tensor:t[o];if(l==null)return;const u=this.accumulatedFirstMoment[r].variable,d=this.accumulatedWeightedInfNorm[r].variable,p=re(ne(u,this.beta1),ne(l,1-this.beta1)),h=ne(d,this.beta2),f=Xr(l),x=qr(h,f);u.assign(p),d.assign(x);const m=re(ne(Ze(n,a),Ze(p,re(x,this.epsilon))),c);c.assign(m)}),this.iteration.assign(re(this.iteration,1)),this.accBeta1.assign(ne(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Me(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Me(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}ws.className="Adamax";Rt(ws);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pn extends Nt{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,n)=>{const o=Array.isArray(t)?t[n].tensor:t[a];if(o==null)return;const r=Ue.registeredVariables[a];xe(()=>{const c=re(ne(this.c,o),r);r.assign(c)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=jr(dt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Pn.className="SGD";Rt(Pn);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ss extends Pn{constructor(t,e,a=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=a,this.accumulations=[],this.m=dt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,n)=>{const o=Ue.registeredVariables[a];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${a}/momentum`,variable:xe(()=>Qe(o).variable(!1))});const r=this.accumulations[n].variable,c=Array.isArray(t)?t[n].tensor:t[a];c!=null&&xe(()=>{let i;const l=re(ne(this.m,r),c);this.useNesterov?i=re(ne(this.c,re(c,ne(l,this.m))),o):i=re(ne(this.c,l),o),r.assign(l),o.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Me(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(a=>({originalName:a.name,variable:a.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Ss.className="Momentum";Rt(Ss);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ks extends Nt{constructor(t,e=.9,a=0,n=null,o=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=a,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,n==null&&(this.epsilon=Ue.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,n)=>{const o=Ue.registeredVariables[a],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${a}/rms`,variable:xe(()=>Qe(o).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${a}/momentum`,variable:xe(()=>Qe(o).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${a}/mg`,variable:xe(()=>Qe(o).variable(r))});const c=Array.isArray(t)?t[n].tensor:t[a];if(c==null)return;const i=this.accumulatedMeanSquares[n].variable,l=this.accumulatedMoments[n].variable;xe(()=>{const u=re(ne(i,this.decay),ne(It(c),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[n].variable,p=re(ne(d,this.decay),ne(c,1-this.decay)),h=Ze(ne(c,this.learningRate),Lt(Mt(u,re(It(p),this.epsilon)))),f=re(ne(l,this.momentum),h);i.assign(u),d.assign(p),l.assign(f);const x=Mt(o,f);o.assign(x)}else{const d=re(ne(i,this.decay),ne(It(c),1-this.decay)),p=re(ne(l,this.momentum),Ze(ne(c,this.learningRate),Lt(re(d,this.epsilon))));i.assign(d),l.assign(p);const h=Mt(o,p);o.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Me(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Me(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Me(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,a=!1;this.accumulatedMeanSquares=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedMoments=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}ks.className="RMSProp";Rt(ks);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $t{static sgd(t){return new Pn(t)}static momentum(t,e,a=!1){return new Ss(t,e,a)}static rmsprop(t,e=.9,a=0,n=null,o=!1){return new ks(t,e,a,n,o)}static adam(t=.001,e=.9,a=.999,n=null){return new ys(t,e,a,n)}static adadelta(t=.001,e=.95,a=null){return new Is(t,e,a)}static adamax(t=.002,e=.9,a=.999,n=null,o=0){return new ws(t,e,a,n,o)}static adagrad(t,e=.1){return new vs(t,e)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$={sgd:$t.sgd,momentum:$t.momentum,adadelta:$t.adadelta,adagrad:$t.adagrad,rmsprop:$t.rmsprop,adamax:$t.adamax,adam:$t.adam};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f$=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:s=>s())();function bu(){return new Promise(s=>f$(()=>s()))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Kr,nonMaxSuppressionV4Impl:Yr,nonMaxSuppressionV5Impl:Qr,whereImpl:Zr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$=Object.freeze(Object.defineProperty({__proto__:null,Abs:Jr,Acos:ei,Acosh:ti,AdadeltaOptimizer:Is,AdagradOptimizer:vs,AdamOptimizer:ys,AdamaxOptimizer:ws,Add:ni,AddN:si,All:ai,Any:oi,ArgMax:ri,ArgMin:ii,Asin:ci,Asinh:li,Atan:ui,Atan2:di,Atanh:pi,AvgPool:hi,AvgPool3D:fi,AvgPool3DGrad:mi,AvgPoolGrad:gi,BatchMatMul:xi,BatchToSpaceND:Ci,Bincount:$i,BroadcastArgs:bi,BroadcastTo:cm,Cast:Ii,Ceil:vi,ClipByValue:yi,Complex:wi,ComplexAbs:Si,Concat:ki,Conv2D:Ri,Conv2DBackpropFilter:Ni,Conv2DBackpropInput:Ti,Conv3D:Ei,Conv3DBackpropFilterV2:Fi,Conv3DBackpropInputV2:Di,Cos:Oi,Cosh:Ai,CropAndResize:Pi,Cumprod:_i,Cumsum:Mi,DataStorage:Li,DenseBincount:Vi,DepthToSpace:Bi,DepthwiseConv2dNative:Wi,DepthwiseConv2dNativeBackpropFilter:zi,DepthwiseConv2dNativeBackpropInput:Ui,Diag:Gi,Dilation2D:Hi,Dilation2DBackpropFilter:lm,Dilation2DBackpropInput:um,get ENV(){return dm},Einsum:Xi,Elu:qi,EluGrad:ji,Environment:pm,Equal:Ki,Erf:Yi,Exp:Qi,ExpandDims:Zi,Expm1:Ji,FFT:ec,Fill:tc,FlipLeftRight:nc,Floor:sc,FloorDiv:ac,FromPixels:oc,FusedBatchNorm:rc,FusedConv2D:ic,FusedDepthwiseConv2D:cc,GatherNd:lc,GatherV2:uc,Greater:dc,GreaterEqual:pc,IFFT:hc,Identity:fc,Imag:mc,IsFinite:gc,IsInf:xc,IsNan:Cc,KernelBackend:$c,LRN:bc,LRNGrad:Ic,LeakyRelu:vc,Less:yc,LessEqual:wc,LinSpace:Sc,Log:kc,Log1p:Rc,LogSoftmax:hm,LogicalAnd:Nc,LogicalNot:Tc,LogicalOr:Ec,LogicalXor:fm,LowerBound:mm,Max:Fc,MaxPool:Dc,MaxPool3D:Oc,MaxPool3DGrad:Ac,MaxPoolGrad:Pc,MaxPoolWithArgmax:_c,Maximum:Mc,Mean:Lc,Min:Vc,Minimum:Bc,MirrorPad:Wc,Mod:zc,MomentumOptimizer:Ss,Multinomial:Uc,Multiply:Gc,Neg:Hc,NonMaxSuppressionV3:Xc,NonMaxSuppressionV4:qc,NonMaxSuppressionV5:jc,NotEqual:Kc,OP_SCOPE_SUFFIX:gm,OneHot:Yc,OnesLike:Qc,Optimizer:Nt,OptimizerConstructors:$t,Pack:Zc,PadV2:Jc,Pool:xm,Pow:el,Prelu:tl,Prod:nl,RMSPropOptimizer:ks,RaggedGather:sl,RaggedTensorToTensor:al,Range:ol,get Rank(){return Cm},Real:rl,RealDiv:il,Reciprocal:cl,get Reduction(){return $m},Relu:ll,Relu6:ul,Reshape:dl,ResizeBilinear:pl,ResizeBilinearGrad:hl,ResizeNearestNeighbor:fl,ResizeNearestNeighborGrad:ml,Reverse:gl,RotateWithOffset:xl,Round:Cl,Rsqrt:$l,SGDOptimizer:Pn,ScatterNd:bl,SearchSorted:Il,Select:vl,Selu:yl,Sigmoid:wl,Sign:Sl,Sin:kl,Sinh:Rl,Slice:Nl,Softmax:Tl,Softplus:El,SpaceToBatchND:Fl,SparseFillEmptyRows:Dl,SparseReshape:Ol,SparseSegmentMean:Al,SparseSegmentSum:Pl,SparseToDense:_l,SplitV:Ml,Sqrt:Ll,Square:Vl,SquaredDifference:Bl,Step:Wl,StridedSlice:zl,StringNGrams:Ul,StringSplit:Gl,StringToHashBucketFast:Hl,Sub:Xl,Sum:ql,Tan:jl,Tanh:Kl,Tensor:bm,TensorBuffer:Ks,Tile:Yl,TopK:Ql,Transform:Zl,Transpose:Jl,Unique:eu,Unpack:tu,UnsortedSegmentSum:nu,UpperBound:Im,Variable:vm,ZerosLike:su,_FusedMatMul:au,abs:Xr,acos:ym,acosh:wm,add:re,addN:Sm,all:km,any:Rm,argMax:Nm,argMin:Tm,asin:Em,asinh:Fm,atan:Dm,atan2:Om,atanh:Am,avgPool:Pm,avgPool3d:_m,backend:Mm,backend_util:hu,basicLSTMCell:Lm,batchNorm:Vm,batchNorm2d:Bm,batchNorm3d:Wm,batchNorm4d:zm,batchToSpaceND:Um,bincount:Gm,booleanMaskAsync:Hm,broadcastArgs:Xm,broadcastTo:ou,broadcast_util:qm,browser:jm,buffer:Ve,cast:Jn,ceil:Km,clipByValue:Ym,clone:Qm,complex:Zm,concat:Jm,concat1d:eg,concat2d:tg,concat3d:ng,concat4d:sg,conv1d:ag,conv2d:og,conv2dTranspose:rg,conv3d:ig,conv3dTranspose:cg,copyRegisteredKernels:lg,cos:ug,cosh:dg,cosineWindow:pg,cumprod:hg,cumsum:fg,customGrad:mg,denseBincount:gg,deprecationWarn:xg,depthToSpace:Cg,depthwiseConv2d:$g,device_util:bg,diag:Ig,dilation2d:vg,disableDeprecationWarnings:yg,dispose:Me,disposeVariables:wg,div:Ze,divNoNan:Sg,dot:kg,dropout:Rg,einsum:Ng,elu:Tg,enableDebugMode:Eg,enableProdMode:Fg,enclosingPowerOfTwo:Dg,engine:At,env:A,equal:Og,erf:Ag,euclideanNorm:Pg,exp:_g,expandDims:Mg,expm1:Lg,eye:Vg,fft:Bg,fill:Hr,findBackend:Wg,findBackendFactory:zg,floor:Ug,floorDiv:Gg,fused:Hg,gather:Xg,gatherND:qg,gather_util:qC,getBackend:jg,getGradient:Kg,getKernel:Yg,getKernelsForBackend:Qg,grad:Zg,grads:Jg,greater:ex,greaterEqual:tx,ifft:nx,imag:sx,image:ax,inTopKAsync:ox,io:rx,irfft:ix,isFinite:cx,isInf:lx,isNaN:ux,keep:jr,kernel_impls:m$,leakyRelu:dx,less:px,lessEqual:hx,linalg:fx,linspace:mx,localResponseNormalization:gx,log:xx,log1p:Cx,logSigmoid:$x,logSoftmax:bx,logSumExp:Ix,logicalAnd:vx,logicalNot:yx,logicalOr:wx,logicalXor:Sx,losses:kx,lowerBound:Rx,matMul:zr,math:e$,max:Nx,maxPool:Tx,maxPool3d:Ex,maxPoolWithArgmax:Fx,maximum:qr,mean:Dx,memory:Ox,meshgrid:Ax,min:Px,minimum:_x,mirrorPad:Mx,mod:Lx,moments:Vx,movingAverage:Bx,mul:ne,multiRNNCell:Wx,multinomial:zx,neg:Ux,nextFrame:bu,norm:Gx,notEqual:Hx,oneHot:qs,ones:Xx,onesLike:qx,op:Br,outerProduct:jx,pad:Kx,pad1d:Yx,pad2d:Qx,pad3d:Zx,pad4d:Jx,pool:e1,pow:js,prelu:t1,print:n1,prod:s1,profile:a1,raggedGather:o1,raggedTensorToTensor:r1,rand:i1,randomGamma:c1,randomNormal:l1,randomStandardNormal:u1,randomUniform:d1,range:p1,ready:h1,real:f1,reciprocal:m1,registerBackend:ru,registerGradient:g1,registerKernel:iu,relu:x1,relu6:C1,removeBackend:$1,reshape:cu,reverse:b1,reverse1d:I1,reverse2d:v1,reverse3d:y1,reverse4d:w1,rfft:S1,round:k1,rsqrt:R1,scalar:dt,scatterND:N1,scatter_util:T1,searchSorted:E1,selu:F1,separableConv2d:D1,serialization:t$,setBackend:O1,setPlatform:A1,setdiff1dAsync:P1,sigmoid:_1,sign:M1,signal:L1,sin:V1,sinh:B1,slice:W1,slice1d:z1,slice2d:U1,slice3d:G1,slice4d:H1,slice_util:jC,softmax:X1,softplus:q1,spaceToBatchND:j1,sparse:K1,sparseToDense:Y1,spectral:Q1,split:Z1,sqrt:Lt,square:It,squaredDifference:J1,squeeze:eC,stack:tC,step:nC,stridedSlice:sC,string:aC,sub:Mt,sum:oC,sumOutType:xs,tan:rC,tanh:iC,tensor:cC,tensor1d:lC,tensor2d:uC,tensor3d:dC,tensor4d:pC,tensor5d:hC,tensor6d:fC,tensor_util:mC,test_util:d$,tidy:xe,tile:gC,time:xC,topk:CC,train:h$,transpose:Wr,truncatedNormal:$C,unique:bC,unregisterGradient:IC,unregisterKernel:vC,unsortedSegmentSum:yC,unstack:wC,upcastType:vt,upperBound:SC,util:kC,valueAndGrad:RC,valueAndGrads:NC,variable:TC,variableGrads:Gr,version_core:p$,where:EC,whereAsync:FC,zeros:lu,zerosLike:Qe},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const x$="3.21.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C$=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:DC,deregisterOp:OC,loadGraphModel:AC,loadGraphModelSync:PC,registerOp:_C,version_converter:x$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(s){const t=new Float32Array(s.length);for(let e=0;e<s.length;++e)t[e]=Math.abs(s[e]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(s){return(t,e,a,n,o)=>{const r=_e(t,e),c=r.length,i=je(r),l=Y(r),u=yt(o,l),d=t.length,p=e.length,h=je(t),f=je(e),x=Ys(t,r),m=Ys(e,r);if(x.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=s(a[g%a.length],n[g%n.length]);else for(let g=0;g<u.length;++g){const C=fa(g,c,i),b=C.slice(-d);x.forEach(y=>b[y]=0);const $=Qs(b,d,h),I=C.slice(-p);m.forEach(y=>I[y]=0);const v=Qs(I,p,f);u[g]=s(a[$],n[v])}return[u,r]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(s,t,e,a){if(a==="int32"){const n=Int32Array.from(s);return[t,"int32",n]}if(a==="bool"){const n=MC([0],e),[o,r]=Ge((c,i)=>c!==i?1:0)(t,[],s,n,"bool");return[r,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${a}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I$=Ge((s,t)=>s+t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(s,t,e,a,n){const o=Y(a),r=ma(n,e);for(let c=0;c<s.length;c++){const i=s[c];if(i<0)throw new Error("Input x must be non-negative!");i>=n||(o>0?r[i]+=t[c]:r[i]+=1)}return r}function y$(s,t,e,a=!1){const n=s.shape[0],o=s.shape[1],r=Ve([n,e],t.dtype);for(let c=0;c<n;c++)for(let i=0;i<o;i++){const l=s.get(c,i);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(a?r.set(1,c,l):t.size>0?r.set(r.get(c,l)+t.get(c,i),c,l):r.set(r.get(c,l)+1,c,l))}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(s){return(t,e,a)=>{const n=yt(e,t.length);for(let o=0;o<t.length;++o)n[o]=s(t[o],a);return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w$=Tt(s=>Math.ceil(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S$=Ge((s,t)=>s===t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k$=Tt(s=>Math.exp(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R$=Tt(s=>Math.expm1(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$=Tt(s=>Math.floor(s));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(s,t,e,a,n,o,r,c,i){const l=Ve([a,o],e);for(let u=0;u<a;u++){const d=[];let p=0;for(let h=0;h<n;h++){const f=s[u*n+h];p+=f*r[h],d.push(f)}if(p<0||p>=i/o)throw new Error(`Invalid indices: ${d} does not index into ${c}`);for(let h=0;h<o;h++)l.values[u*o+h]=t.get(...t.indexToLoc(p*o+h))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(s,t,e){const a=Ve(e,s.dtype);for(let n=0;n<a.size;++n){const r=a.indexToLoc(n).slice(),c=r[0],i=r[2],l=t.locToIndex([c,i]);r[2]=t.values[l];const u=s.locToIndex(r);0<=u&&u<s.values.length&&(a.values[n]=s.values[u])}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$=Ge((s,t)=>s>t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$=Ge((s,t)=>s>=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O$=Ge((s,t)=>s<t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$=Ge((s,t)=>s<=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(s,t,e){const a=(t-s)/(e-1),n=ma(e,"float32");n[0]=s;for(let o=1;o<n.length;o++)n[o]=n[o-1]+a;return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$=Tt(s=>Math.log(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(s,t,e,a){const n=yt(a,Y(e));for(let o=0;o<n.length;++o){const r=o*t;let c=s[r];for(let i=0;i<t;++i){const l=s[r+i];(Number.isNaN(l)||l>c)&&(c=l)}n[o]=c}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L$=Ge((s,t)=>Math.max(s,t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$=Ge((s,t)=>Math.min(s,t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu=Ge((s,t)=>s*t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$(s,t,e){const a=cn(-1,e);return Iu([],t,a,s,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=Ge((s,t)=>s!==t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(s,t,e,a,n){const o=t.length,r=Y(t),c=je(t),i=je(n),l=yt(e,Y(n));for(let u=0;u<r;++u){const d=fa(u,o,c),p=new Array(d.length);for(let f=0;f<p.length;f++)p[f]=d[a[f]];const h=Qs(p,o,i);l[h]=s[u]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(s,t,e,a){const[n,o]=ht(s,a),r=vt(t,"int32"),c=ma(Y(n),r),i=Y(o);for(let l=0;l<c.length;++l){const u=l*i;let d=1;for(let p=0;p<i;++p)d*=e[u+p];c[l]=d}return{outVals:c,outShape:n,outDtype:r}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(s,t,e){s.forEach((a,n)=>{if(a<0||a>=e){const o=fa(n,t.length,je(t)).join(",");throw new Error(`indices[${o}] = ${a} is not in [0, ${e})`)}})}function H$(s,t){for(let e=0;e<s.length;++e){const a=s[e],n=e===s.length-1?t:s[e+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>n)throw new Error("Ragged splits must not point past values");for(let o=1;o<a.length;++o)if(a[o-1]>a[o])throw new Error("Ragged splits must be sorted in ascending order")}}function X$(s,t,e,a){const n=[];let o=0;const r=t.length-1+e.length,c=new Array(r).fill(null).map(()=>[0]);H$(e,a);let i=1;for(let l=0;l<t.length-1;++l){i*=t[l];const u=t[l+1];for(let d=1;d<i+1;++d)c[l].push(d*u)}for(let l=0;l<s.length;++l){let u=s[l],d=s[l]+1;for(let p=0;p<e.length;++p){const h=e[p],f=p+t.length-1;if(f>=0){const x=c[f],m=x[x.length-1]-h[u];for(let g=u;g<d;++g)c[f].push(h[g+1]+m)}u=h[u],d=h[d]}d!==u&&(n.push([u,d]),o+=d-u)}return{outSplits:c,valueSlices:n,numValues:o}}function q$(s){const t=[];for(let e=0;e<s.length;++e){const a=s[e].length,n=nt("int32",a);t.push(n),s[e].forEach((o,r)=>n[r]=o)}return t}function Ka(s,t){const e=s.slice(0,t);for(;e.length<t;)e.push(1);for(let a=t;a<s.length;a++)e[t-1]*=s[a];return e}function j$(s,t,e,a,n,o){const r=Ka(t,2)[1],c=Ka(o,2)[1];let i=0;for(const l of e)for(let u=l[0];u<l[1];++u){for(let d=0;d<a;++d)n[i*c+d]=s[u*r+d];++i}}function K$(s,t,e,a,n){const o=t.slice();o[0]=n;const r=nt(e,Y(o)),c=s.length,i=c===0?0:c/t[0];return j$(s,t,a,i,r,o),[r,o]}function Y$(s,t,e,a,n,o,r,c){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const i=t[0][0]-1;if(G$(o,r,i),a.length===0)throw new Error("params.rank must be nonzero");const l=a[0],{outSplits:u,valueSlices:d,numValues:p}=X$(o,r,s,l),h=q$(u),f=K$(e,a,n,d,p);return[h,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var He=JC;let Q$=class ea{constructor(t,e,a,n,o,r,c,i,l,u){this.shape=t,this.shapeShape=e,this.values=a,this.valuesShape=n,this.valuesDType=o,this.defaultValue=r,this.defaultValueShape=c,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=KC(u),this.raggedRank=YC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===He.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===He.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case He.VALUE_ROWIDS:return ea.getMaxWidthValueRowID(e);case He.ROW_SPLITS:return ea.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${He[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let a=0;for(let n=0;n<e-1;++n){const o=t[n+1]-t[n];o>a&&(a=o)}return a}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let a=0,n=t[0],o=0;for(let r=1;r<e;++r){const c=t[r];c!==n&&(n=c,o=Math.max(r-a,o),a=r)}return Math.max(e-a,o)}tensorShapeFromTensor(t,e,a=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Qa(t,a)}calculateOutputSize(t){const e=this.valuesShape,a=this.defaultValueShape;QC(a,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=ZC(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let c=1;c<=this.raggedRank;++c)r[c]<0&&(r[c]=this.getMaxWidth(c));return r}calculateFirstParentOutputIndex(t,e,a){const n=Math.min(t,a),o=[];let r=0;for(let c=0;c<n;++c,r+=e)o.push(r);for(let c=n;c<t;++c)o.push(-1);return ae(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,a,n){const o=t.length,r=[];for(let c=0;c<o-1;++c){const i=t[c+1]-t[c];let l=Math.min(n,i),u=e[c];u===-1&&(l=0);for(let d=0;d<l;++d)r.push(u),u+=a;for(let d=0;d<i-l;++d)r.push(-1)}if(o>0&&r.length!==t[o-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(t,e,a,n){const o=t.length,r=[];if(o===0)return[];let c=0,i=t[0];if(i>=e.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${e.length}`);let l=e[i];r.push(l);for(let u=1;u<o;++u){const d=t[u];if(d===i)l>=0&&(++c,c<n?l+=a:l=-1);else{if(c=0,i=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);l=e[d]}r.push(l)}if(r.length!==t.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(t,e,a,n){const o=this.getRowPartitionTensor(t),r=this.getRowPartitionTypeByDimension(t);switch(r){case He.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,a,n);case He.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,a,n);default:throw new Error(`Unsupported partition type: ${He[r]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case He.FIRST_DIM_SIZE:return t[0];case He.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case He.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${He[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),a=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*a[i+1];const o=Qa(a,!1),r=nt(this.valuesDType,Y(o));if(n[0]*a[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],a[0]);for(let l=1;l<=this.raggedRank;++l)i=this.calculateOutputIndex(l-1,i,n[l],a[l]);this.setOutput(this.raggedRank,i,r,o)}return[o,r]}setOutput(t,e,a,n){if(a.length===0)return;const o=this.values,r=a;let c=n.slice();c=c.slice(t+1);const i=Y(c),l=e.length;let u=this.defaultValue;if(u.length!==i&&u.length!==1){const f=this.defaultValueShape;xe(()=>{const x=cu(u,f);u=ou(x,c).dataSync()})}let d=0,p=0,h=0;for(let f=0;f<=l;++f){let x=f<l?e[f]:-1;if(x===h){++h;continue}if(p<h){const m=o.subarray(d*i),g=r.subarray(p*i),C=(h-p)*i;Ya(g,m,C)}if(f>=l){const m=a.length;x=Math.floor(m/i)}if(x>h)if(this.defaultValue.length===1)r.subarray(h*i,x*i).fill(this.defaultValue[0]),h=x;else for(;x>h;){const m=r.slice(h*i);Ya(m,u,i),++h}x<0?(d=f+1,p=h):(d=f,p=h,h=p+1)}}};function Ya(s,t,e){for(let a=0;a<e;a++)s[a]=t[a]}function Qa(s,t){const e=[];for(let a of s){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}e.push(a)}return e}function Z$(s,t,e,a,n,o,r,c,i,l){return new Q$(s,t,e,a,n,o,r,c,i,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$=Tt(s=>1/Math.sqrt(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eb(s,t,e,a,n,o,r,c,i,l){const u=[a/n,n],d=s.values,p=t.values;if(a===0)return Ve(e,t.dtype);const h=Ve(u,t.dtype);typeof i=="string"||typeof i=="number"?h.values.fill(i):typeof i=="boolean"&&h.values.fill(+i);for(let f=0;f<o;f++){const x=[];let m=0;for(let g=0;g<r;g++){const C=d[f*r+g];x.push(C),m+=C*c[g]}if(m<0||m>=a/n)throw new Error(`Invalid indices: ${x} does not index into ${e}`);for(let g=0;g<n;g++)l?h.values[m*n+g]+=p[f*n+g]:h.values[m*n+g]=t.rank===0?p[0]:p[f*n+g]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tb=Tt(s=>1/(1+Math.exp(-s)));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(s,t,e,a,n,o,r){const c=t[0],i=o[0],l=new Array(i),u=new Array(c),d=t[1];if(i===0){if(c!==0)throw new Error(e0(c));const m=nt(e,0),g=nt(n,0);return[m,[0,d],g,l,u]}let p=!0,h=0;const f=new Array(i).fill(0);for(let m=0;m<c;++m){const g=s[m*d];if(g<0)throw new Error(t0(m,g));if(g>=i)throw new Error(n0(m,g,i));++f[g],p=p&&g>=h,h=g}let x=!0;for(let m=0;m<i;++m){const g=f[m]===0;l[m]=g,x=x&&!g,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(x&&p){const m=s,g=a;for(let C=0;C<c;++C)u[C]=C;return[m,[c,d],g,l,u]}else{const m=f[i-1],g=nt(e,m*d),C=nt(n,m),b=new Array(i).fill(0);for(let $=0;$<c;++$){const I=s[$*d],v=b[I],y=(I===0?0:f[I-1])+v;b[I]++;for(let w=0;w<d;++w)g[y*d+w]=s[$*d+w];C[y]=a[$],u[$]=y}for(let $=0;$<i;++$)if(b[$]===0){const v=$===0?0:f[$-1];g[v*d+0]=$;for(let y=1;y<d;++y)g[v*d+y]=0;C[v]=r}return[g,[m,d],C,l,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(s,t,e,a,n){const o=Y(a),r=t[0],c=n.length,i=[];let l=1,u=-1;for(let m=0;m<c;++m){const g=n[m];if(g===-1){if(u!==-1)throw new Error(s0(u,m));u=m,i.push(1)}else{if(g<0)throw new Error(a0(m,g));l*=g,i.push(g)}}if(u!==-1){if(l<=0)throw new Error(o0());const m=Math.trunc(o/l);if(l*m!==o)throw new Error(r0(a,i));i[u]=m}if(Y(i)!==o)throw new Error(i0(a,i));const p=a.length,h=[];if(p>0){h[p-1]=1;for(let m=p-2;m>=0;--m)h[m]=h[m+1]*a[m+1]}const f=[];if(c>0){f[c-1]=1;for(let m=c-2;m>=0;--m)f[m]=f[m+1]*i[m+1]}const x=nt(e,r*c);for(let m=0;m<r;++m){let g=0;for(let C=0;C<p;++C)g+=s[m*p+C]*h[C];for(let C=0;C<c;++C)x[m*c+C]=Math.trunc(g/f[C]),g%=f[C]}return[x,[r,c],i]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(s,t,e,a,n,o=!1,r=0){const c=a.length,i=[t[0],s.length/t[0]],l=i[1],d=c>0?n[c-1]+1:0;if(d<0)throw new Error(Ga());const p=t.slice();p[0]=d;const h=p.reduce((b,$)=>b*$,1),f=nt(e,h);if(c===0)return d>0&&f.fill(r),[f,p];if(d<=0)throw new Error(Ga());let x=0,m=1,g=0,C=n[x];for(;;){let b=0;if(m<c){if(b=n[m],C===b){++m;continue}if(C>=b)throw new Error(c0())}if(C<0||C>=d)throw new Error(l0(C,d));C>g&&f.fill(r,g*l,C*l);for(let $=x;$<m;++$){const I=a[$];if(I<0||I>=i[0])throw new Error(u0($,a[$],i[0]));for(let v=0;v<l;v++)f[C*l+v]+=s[I*l+v]}if(o)for(let $=0;$<l;$++)f[C*l+$]/=m-x;if(x=m,++m,g=C+1,C=b,m>c)break}return g<d&&f.fill(r,g*l,d*l),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob=Tt(s=>Math.sqrt(s));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rb=Ge((s,t)=>{const e=s-t;return e*e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(s,t,e,a){const n=Ve(s,t.dtype);for(let o=0;o<n.size;o++){const r=n.indexToLoc(o),c=new Array(r.length);for(let i=0;i<c.length;i++)c[i]=r[i]*e[i]+a[i];n.set(t.get(...c),...r)}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cb=Ge((s,t)=>s-t);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(s,t){const e=new Array(s.rank);for(let n=0;n<e.length;n++)e[n]=s.shape[n]*t[n];const a=Ve(e,s.dtype);for(let n=0;n<a.values.length;++n){const o=a.indexToLoc(n),r=new Array(s.rank);for(let i=0;i<r.length;i++)r[i]=o[i]%s.shape[i];const c=s.locToIndex(r);a.values[n]=s.values[c]}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vn=(s,t)=>{const e=t.value-s.value;return e===0?s.index-t.index:e};function vu(s,t,e=0,a=s.length-1){for(;a>e;){if(a-e>600){const c=a-e+1,i=t-e+1,l=Math.log(c),u=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*u*(c-u)/c)*Math.sign(i-c/2),p=Math.max(e,Math.floor(t-i*u/c+d)),h=Math.min(a,Math.floor(t+(c-i)*u/c+d));vu(s,t,p,h)}const n=s[t];let o=e,r=a;for(bn(s,e,t),vn(s[a],n)>0&&bn(s,e,a);o<r;){for(bn(s,o,r),o++,r--;vn(s[o],n)<0;)o=o+1;for(;vn(s[r],n)>0;)r=r-1}vn(s[e],n)===0?bn(s,e,r):(r=r+1,bn(s,r,a)),r<=t&&(e=r+1),t<=r&&(a=r-1)}}function ub(s,t,e,a,n){const o=t[t.length-1],[r,c]=[s.length/o,o],i=yt(e,r*a),l=yt("int32",r*a);for(let d=0;d<r;d++){const p=d*c,h=s.subarray(p,p+c);let f=new Array(h.length);h.forEach((C,b)=>f[b]={value:C,index:b}),a<f.length&&(vu(f,a),f=f.slice(0,a)),n&&f.sort(vn);const x=d*a,m=i.subarray(x,x+a),g=l.subarray(x,x+a);for(let C=0;C<a;C++)m[C]=f[C].value,g[C]=f[C].index}const u=t.slice();return u[u.length-1]=a,[Ve(u,e,i),Ve(u,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(s,t,e,a){const n=Ae(t,e)[0],o=[1,e[0],1];for(let f=0;f<n;f++)o[0]*=e[f];o[1]=e[n];for(let f=n+1;f<e.length;f++)o[2]*=e[f];const r={},c=new Int32Array(e[n]),i=new Ks(o,a,s),l=[],u=o[0]===1&&o[2]===1;for(let f=0;f<e[n];f++){let x;if(u)x=s[f].toString();else{const m=[];for(let g=0;g<o[0];g++)for(let C=0;C<o[2];C++)m.push(i.get(g,f,C));x=m.join(",")}if(r[x]!==void 0)c[f]=r[x];else{const m=Object.keys(r).length;r[x]=m,c[f]=m,l.push(f)}}const d=o.slice();d[1]=Object.keys(r).length;const p=new Ks(d,a);l.forEach((f,x)=>{for(let m=0;m<o[0];m++)for(let g=0;g<o[2];g++)p.set(i.get(m,f,g),m,x,g)});const h=e.slice();return h[n]=d[1],{outputValues:p.values,outputShape:h,indices:c}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pb=Object.freeze(Object.defineProperty({__proto__:null,addImpl:I$,bincountImpl:v$,bincountReduceImpl:y$,castImpl:b$,ceilImpl:w$,concatImpl:d0,equalImpl:S$,expImpl:k$,expm1Impl:R$,floorImpl:N$,gatherNdImpl:T$,gatherV2Impl:E$,greaterEqualImpl:D$,greaterImpl:F$,lessEqualImpl:A$,lessImpl:O$,linSpaceImpl:P$,logImpl:_$,maxImpl:M$,maximumImpl:L$,minimumImpl:V$,multiplyImpl:Iu,negImpl:B$,notEqualImpl:W$,prodImpl:U$,raggedGatherImpl:Y$,raggedTensorToTensorImpl:Z$,rangeImpl:p0,rsqrtImpl:J$,scatterImpl:eb,sigmoidImpl:tb,simpleAbsImpl:$$,sliceImpl:h0,sparseFillEmptyRowsImpl:nb,sparseReshapeImpl:sb,sparseSegmentReductionImpl:ab,sqrtImpl:ob,squaredDifferenceImpl:rb,stridedSliceImpl:ib,stringNGramsImpl:f0,stringSplitImpl:m0,stringToHashBucketFastImpl:g0,subImpl:cb,tileImpl:lb,topKImpl:ub,transposeImpl:z$,uniqueImpl:db},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X(s,t){Array.isArray(s)||(s=[s]),s.forEach(e=>{e!=null&&we(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb=qd;class Rs extends zd{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ud(this,Pa())}nextDataId(){return Rs.nextDataId++}write(t,e,a){this.firstUse&&(this.firstUse=!1,Gd().get("IS_NODE")&&Hd(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const n={id:this.nextDataId()};return this.data.set(n,{values:t,dtype:a,refCount:1}),n}makeTensorInfo(t,e,a){let n;if(e==="string"&&a!=null&&a.length>0&&Xd(a[0])){const o=a.map(r=>Zn(r));n=this.write(o,t,e)}else n=this.write(a,t,e);return{dataId:n,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,a,n,o){this.data.set(t,{values:e,dtype:n,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:a}=this.data.get(t);if(e==="complex64"){const n=this.readSync(a.real.dataId),o=this.readSync(a.imag.dataId);return Qt(n,o)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const a=e.map(n=>Eo(n));return le(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,e)}makeOutput(t,e,a){return Pa().makeTensorFromTensorInfo(this.makeTensorInfo(e,a,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=_a();return t(),{kernelMs:_a()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){X([t],"where");const e=this.readSync(t.dataId);return hb(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Rs.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fb(s){const t=new Float32Array(s.length);for(let e=0;e<s.length;++e)t[e]=Math.abs(s[e]);return t}const mb=s=>{const{x:t}=s.inputs,e=s.backend;X(t,"abs");let a=new Float32Array(H(t.shape));const n=e.data.get(t.dataId).values;return a=fb(n),e.makeOutput(a,t.shape,t.dtype)},gb={kernelName:jd,backendName:"cpu",kernelFunc:mb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ce(s){return(t,e,a,n,o)=>{const r=fs(t,e),c=r.length,i=J(r),l=H(r),u=Re(o,l),d=t.length,p=e.length,h=J(t),f=J(e),x=ts(t,r),m=ts(e,r);if(x.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=s(a[g%a.length],n[g%n.length]);else for(let g=0;g<u.length;++g){const C=on(g,c,i),b=C.slice(-d);x.forEach(y=>b[y]=0);const $=st(b,d,h),I=C.slice(-p);m.forEach(y=>I[y]=0);const v=st(I,p,f);u[g]=s(a[$],n[v])}return[u,r]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(s){const{inputs:t,backend:e}=s,{real:a,imag:n}=t,o=e.data.get(a.dataId).values,r=e.data.get(n.dataId).values,c=e.makeTensorInfo(a.shape,"complex64"),i=e.data.get(c.dataId);return i.complexTensorInfos={real:e.makeTensorInfo(a.shape,"float32",o),imag:e.makeTensorInfo(n.shape,"float32",r)},c}const xb={kernelName:Kd,backendName:"cpu",kernelFunc:Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function as(s,t,e="float32"){if(e==="complex64"){const n=as(s,t,"float32"),o=as(s,t,"float32");return Pe({inputs:{real:n,imag:o},backend:s})}const a=Le(H(t),e);return s.makeTensorInfo(t,e,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(s){const{inputs:t,backend:e}=s,{x:a}=t;return e.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Cb={kernelName:Yd,backendName:"cpu",kernelFunc:at};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(s){const{inputs:t,backend:e}=s,{input:a}=t,n=e.data.get(a.dataId).complexTensorInfos.real,o=e.data.get(n.dataId).values;return e.makeTensorInfo(n.shape,n.dtype,o)}const $b={kernelName:Qd,backendName:"cpu",kernelFunc:Vt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(s,t,e,a){if(a==="int32"){const n=Int32Array.from(s);return[t,"int32",n]}if(a==="bool"){const n=ms([0],e),[o,r]=Ce((c,i)=>c!==i?1:0)(t,[],s,n,"bool");return[r,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${a}`)}function wt(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{dtype:o}=a;if(o==="complex64"){if(n.dtype==="complex64")return at({inputs:{x:n},backend:e});const u=as(e,n.shape,n.dtype),d=wt({inputs:{x:n},backend:e,attrs:{dtype:"float32"}}),p=Pe({inputs:{real:d,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),p}if(n.dtype==="complex64"){const u=Vt({inputs:{input:n},backend:e}),d=wt({inputs:{x:u},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(u),d}if(!Jd(n.dtype,o)){const u=at({inputs:{x:n},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:o}}const r=e.data.get(n.dataId).values,[c,i,l]=bb(r,n.shape,n.dtype,o);return e.makeTensorInfo(c,i,l)}const Ib={kernelName:Zd,backendName:"cpu",kernelFunc:wt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $e(s,t,e,a){return e==null?({inputs:n,backend:o})=>{const{a:r,b:c}=n,i=o;X([r,c],s);const l=i.data.get(r.dataId).values,u=i.data.get(c.dataId).values,d=r.dtype==="string"?ns(l):l,p=r.dtype==="string"?ns(u):u,h=a||r.dtype,[f,x]=t(r.shape,c.shape,d,p,h);return i.makeTensorInfo(x,h,f)}:({inputs:n,backend:o})=>{const{a:r,b:c}=n,i=o;if(r.dtype==="complex64"||c.dtype==="complex64"){const l=wt({inputs:{x:r},backend:i,attrs:{dtype:"complex64"}}),u=i.data.get(l.dataId),d=u.complexTensorInfos.real,p=u.complexTensorInfos.imag,h=i.data.get(d.dataId).values,f=i.data.get(p.dataId).values,x=wt({inputs:{x:c},backend:i,attrs:{dtype:"complex64"}}),m=i.data.get(x.dataId),g=m.complexTensorInfos.real,C=m.complexTensorInfos.imag,b=i.data.get(g.dataId).values,$=i.data.get(C.dataId).values,[I,v,y]=e(r.shape,c.shape,h,f,b,$),w=i.makeTensorInfo(y,"float32",I),k=i.makeTensorInfo(y,"float32",v),S=Pe({inputs:{real:w,imag:k},backend:i});return i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(k),S}else{const l=i.data.get(r.dataId).values,u=i.data.get(c.dataId).values,d=a||r.dtype,[p,h]=t(r.shape,c.shape,l,u,d);return i.makeTensorInfo(h,d,p)}}}function va(s){return(t,e,a,n,o,r)=>{const c=fs(t,e),i=H(c),l=c.length,u=J(c),d=Re("float32",i),p=Re("float32",i),h=ts(t,c),f=ts(e,c),x=Qt(a,n),m=Qt(o,r),g=t.length,C=J(t),b=e.length,$=J(e);if(h.length+f.length===0)for(let I=0;I<d.length;I++){const v=I%x.length,y=I%m.length,w=s(x[v*2],x[v*2+1],m[y*2],m[y*2+1]);d[I]=w.real,p[I]=w.imag}else for(let I=0;I<d.length;I++){const v=on(I,l,u),y=v.slice(-g);h.forEach(O=>y[O]=0);const w=st(y,g,C),k=v.slice(-b);f.forEach(O=>k[O]=0);const S=st(k,b,$),E=s(x[w*2],x[w*2+1],m[S*2],m[S*2+1]);d[I]=E.real,p[I]=E.imag}return[d,p,c]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vb=Ce((s,t)=>s+t),yb=va((s,t,e,a)=>({real:s+e,imag:t+a})),Jt=$e(Fo,vb,yb),wb={kernelName:Fo,backendName:"cpu",kernelFunc:Jt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yu(s,t,e,a,n){const o=H(a),r=Le(n,e);for(let c=0;c<s.length;c++){const i=s[c];if(i<0)throw new Error("Input x must be non-negative!");i>=n||(o>0?r[i]+=t[c]:r[i]+=1)}return r}function Sb(s,t,e,a=!1){const n=s.shape[0],o=s.shape[1],r=le([n,e],t.dtype);for(let c=0;c<n;c++)for(let i=0;i<o;i++){const l=s.get(c,i);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(a?r.set(1,c,l):t.size>0?r.set(r.get(c,l)+t.get(c,i),c,l):r.set(r.get(c,l)+1,c,l))}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(s){return(t,e,a)=>{const n=Re(e,t.length);for(let o=0;o<t.length;++o)n[o]=s(t[o],a);return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(s,t,e){return({inputs:a,attrs:n,backend:o})=>{const{x:r}=a;if(X(r,s),r.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");const c=o,i=c.data.get(r.dataId).values,l=H(r.shape),u=e||r.dtype,d=ye(u,l);for(let p=0;p<l;++p)d[p]=t(i[p],n);return c.makeTensorInfo(r.shape,u,d)}}function un(s,t,e){return({inputs:a,attrs:n,backend:o})=>{const{x:r}=a;if(X(r,s),r.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");const c=o,i=c.data.get(r.dataId).values,l=e||r.dtype,u=t(i,l,n);return c.makeTensorInfo(r.shape,l,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kb=ln(s=>Math.ceil(s)),Rb=un(Do,kb),Nb={kernelName:Do,backendName:"cpu",kernelFunc:Rb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(s,t,e,a){const n=ye(e,H(t));if(a&&e!=="string"){let o=0;s.forEach(r=>{const c=H(r.shape);n.set(r.vals,o),o+=c})}else{let o=0;s.forEach(r=>{const c=e==="string"?ns(r.vals):r.vals;let i=0;for(let l=0;l<r.shape[0];++l){const u=l*t[1]+o;for(let d=0;d<r.shape[1];++d)n[u+d]=c[i++]}o+=r.shape[1]})}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eb=Ce((s,t)=>s===t?1:0),wu=$e(Oo,Eb,null,"bool"),Fb={kernelName:Oo,backendName:"cpu",kernelFunc:wu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Db=ln(s=>Math.exp(s)),Su=un(Ao,Db,"float32"),Ob={kernelName:Ao,backendName:"cpu",kernelFunc:Su};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ab=ln(s=>Math.expm1(s)),Pb=un(Po,Ab),_b={kernelName:Po,backendName:"cpu",kernelFunc:Pb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mb=ln(s=>Math.floor(s)),Lb=un(_o,Mb),Vb={kernelName:_o,backendName:"cpu",kernelFunc:Lb};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bb(s,t,e,a,n,o,r,c,i){const l=le([a,o],e);for(let u=0;u<a;u++){const d=[];let p=0;for(let h=0;h<n;h++){const f=s[u*n+h];p+=f*r[h],d.push(f)}if(p<0||p>=i/o)throw new Error(`Invalid indices: ${d} does not index into ${c}`);for(let h=0;h<o;h++)l.values[u*o+h]=t.get(...t.indexToLoc(p*o+h))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(s,t,e){const a=le(e,s.dtype);for(let n=0;n<a.size;++n){const r=a.indexToLoc(n).slice(),c=r[0],i=r[2],l=t.locToIndex([c,i]);r[2]=t.values[l];const u=s.locToIndex(r);0<=u&&u<s.values.length&&(a.values[n]=s.values[u])}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb=Ce((s,t)=>s>t?1:0),Ub=$e(Mo,zb,null,"bool"),Gb={kernelName:Mo,backendName:"cpu",kernelFunc:Ub};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hb=Ce((s,t)=>s>=t?1:0),Xb=$e(Lo,Hb,null,"bool"),qb={kernelName:Lo,backendName:"cpu",kernelFunc:Xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jb=Ce((s,t)=>s<t?1:0),Kb=$e(Vo,jb,null,"bool"),Yb={kernelName:Vo,backendName:"cpu",kernelFunc:Kb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qb=Ce((s,t)=>s<=t?1:0),Zb=$e(Bo,Qb,null,"bool"),Jb={kernelName:Bo,backendName:"cpu",kernelFunc:Zb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(s,t,e){const a=(t-s)/(e-1),n=Le(e,"float32");n[0]=s;for(let o=1;o<n.length;o++)n[o]=n[o-1]+a;return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tI=ln(s=>Math.log(s)),nI=un(Wo,tI),sI={kernelName:Wo,backendName:"cpu",kernelFunc:nI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(s,t,e,a){const n=Re(a,H(e));for(let o=0;o<n.length;++o){const r=o*t;let c=s[r];for(let i=0;i<t;++i){const l=s[r+i];(Number.isNaN(l)||l>c)&&(c=l)}n[o]=c}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI=Ce((s,t)=>Math.max(s,t)),rI=$e(zo,oI),iI={kernelName:zo,backendName:"cpu",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI=Ce((s,t)=>Math.min(s,t)),lI=$e(Uo,cI),uI={kernelName:Uo,backendName:"cpu",kernelFunc:lI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ku=Ce((s,t)=>s*t),dI=va((s,t,e,a)=>({real:s*e-t*a,imag:s*a+t*e})),Ns=$e(Go,ku,dI),pI={kernelName:Go,backendName:"cpu",kernelFunc:Ns};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(s,t,e){const a=ia(-1,e);return ku([],t,a,s,e)}function fI(s){const{inputs:t,backend:e}=s,{x:a}=t;X(a,"neg");const n=e.data.get(a.dataId).values,[o,r]=hI(n,a.shape,a.dtype);return e.makeTensorInfo(r,a.dtype,o)}const mI={kernelName:ep,backendName:"cpu",kernelFunc:fI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gI=Ce((s,t)=>s!==t?1:0),xI=$e(Ho,gI,null,"bool"),CI={kernelName:Ho,backendName:"cpu",kernelFunc:xI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ru(s,t,e,a,n){const o=t.length,r=H(t),c=J(t),i=J(n),l=Re(e,H(n));for(let u=0;u<r;++u){const d=on(u,o,c),p=new Array(d.length);for(let f=0;f<p.length;f++)p[f]=d[a[f]];const h=st(p,o,i);l[h]=s[u]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function De(s){const{inputs:t,attrs:e,backend:a}=s,{x:n}=t,{perm:o}=e;X(n,"transpose");const r=n.shape.length,c=new Array(r);for(let d=0;d<c.length;d++)c[d]=n.shape[o[d]];const i=a.data.get(n.dataId).values,l=Ru(i,n.shape,n.dtype,o,c);return{dataId:a.write(l,c,n.dtype),shape:c,dtype:n.dtype}}const $I={kernelName:tp,backendName:"cpu",kernelFunc:De};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(s,t,e,a){const[n,o]=pt(s,a),r=Fn(t,"int32"),c=Le(H(n),r),i=H(o);for(let l=0;l<c.length;++l){const u=l*i;let d=1;for(let p=0;p<i;++p)d*=e[u+p];c[l]=d}return{outVals:c,outShape:n,outDtype:r}}function II(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;X(n,"prod");const c=n.shape.length,i=Oe(o,n.shape),l=ot(i,c);let u=i,d=n;const p=[];l!=null&&(d=De({inputs:{x:n},backend:e,attrs:{perm:l}}),p.push(d),u=rt(u.length,c));const h=e.data.get(d.dataId).values,{outVals:f,outShape:x,outDtype:m}=bI(d.shape,d.dtype,h,u);let g=x;return r&&(g=Wt(x,i)),p.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(g,m,f)}const vI={kernelName:np,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(s,t,e){s.forEach((a,n)=>{if(a<0||a>=e){const o=on(n,t.length,J(t)).join(",");throw new Error(`indices[${o}] = ${a} is not in [0, ${e})`)}})}function wI(s,t){for(let e=0;e<s.length;++e){const a=s[e],n=e===s.length-1?t:s[e+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>n)throw new Error("Ragged splits must not point past values");for(let o=1;o<a.length;++o)if(a[o-1]>a[o])throw new Error("Ragged splits must be sorted in ascending order")}}function SI(s,t,e,a){const n=[];let o=0;const r=t.length-1+e.length,c=new Array(r).fill(null).map(()=>[0]);wI(e,a);let i=1;for(let l=0;l<t.length-1;++l){i*=t[l];const u=t[l+1];for(let d=1;d<i+1;++d)c[l].push(d*u)}for(let l=0;l<s.length;++l){let u=s[l],d=s[l]+1;for(let p=0;p<e.length;++p){const h=e[p],f=p+t.length-1;if(f>=0){const x=c[f],m=x[x.length-1]-h[u];for(let g=u;g<d;++g)c[f].push(h[g+1]+m)}u=h[u],d=h[d]}d!==u&&(n.push([u,d]),o+=d-u)}return{outSplits:c,valueSlices:n,numValues:o}}function kI(s){const t=[];for(let e=0;e<s.length;++e){const a=s[e].length,n=ye("int32",a);t.push(n),s[e].forEach((o,r)=>n[r]=o)}return t}function Za(s,t){const e=s.slice(0,t);for(;e.length<t;)e.push(1);for(let a=t;a<s.length;a++)e[t-1]*=s[a];return e}function RI(s,t,e,a,n,o){const r=Za(t,2)[1],c=Za(o,2)[1];let i=0;for(const l of e)for(let u=l[0];u<l[1];++u){for(let d=0;d<a;++d)n[i*c+d]=s[u*r+d];++i}}function NI(s,t,e,a,n){const o=t.slice();o[0]=n;const r=ye(e,H(o)),c=s.length,i=c===0?0:c/t[0];return RI(s,t,a,i,r,o),[r,o]}function TI(s,t,e,a,n,o,r,c){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const i=t[0][0]-1;if(yI(o,r,i),a.length===0)throw new Error("params.rank must be nonzero");const l=a[0],{outSplits:u,valueSlices:d,numValues:p}=SI(o,r,s,l),h=kI(u),f=NI(e,a,n,d,p);return[h,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Xe=up;class os{constructor(t,e,a,n,o,r,c,i,l,u){this.shape=t,this.shapeShape=e,this.values=a,this.valuesShape=n,this.valuesDType=o,this.defaultValue=r,this.defaultValueShape=c,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=sp(u),this.raggedRank=ap(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Xe.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Xe.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Xe.VALUE_ROWIDS:return os.getMaxWidthValueRowID(e);case Xe.ROW_SPLITS:return os.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Xe[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let a=0;for(let n=0;n<e-1;++n){const o=t[n+1]-t[n];o>a&&(a=o)}return a}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let a=0,n=t[0],o=0;for(let r=1;r<e;++r){const c=t[r];c!==n&&(n=c,o=Math.max(r-a,o),a=r)}return Math.max(e-a,o)}tensorShapeFromTensor(t,e,a=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return eo(t,a)}calculateOutputSize(t){const e=this.valuesShape,a=this.defaultValueShape;op(a,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=rp(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let c=1;c<=this.raggedRank;++c)r[c]<0&&(r[c]=this.getMaxWidth(c));return r}calculateFirstParentOutputIndex(t,e,a){const n=Math.min(t,a),o=[];let r=0;for(let c=0;c<n;++c,r+=e)o.push(r);for(let c=n;c<t;++c)o.push(-1);return we(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,a,n){const o=t.length,r=[];for(let c=0;c<o-1;++c){const i=t[c+1]-t[c];let l=Math.min(n,i),u=e[c];u===-1&&(l=0);for(let d=0;d<l;++d)r.push(u),u+=a;for(let d=0;d<i-l;++d)r.push(-1)}if(o>0&&r.length!==t[o-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(t,e,a,n){const o=t.length,r=[];if(o===0)return[];let c=0,i=t[0];if(i>=e.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${e.length}`);let l=e[i];r.push(l);for(let u=1;u<o;++u){const d=t[u];if(d===i)l>=0&&(++c,c<n?l+=a:l=-1);else{if(c=0,i=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);l=e[d]}r.push(l)}if(r.length!==t.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(t,e,a,n){const o=this.getRowPartitionTensor(t),r=this.getRowPartitionTypeByDimension(t);switch(r){case Xe.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,a,n);case Xe.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,a,n);default:throw new Error(`Unsupported partition type: ${Xe[r]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Xe.FIRST_DIM_SIZE:return t[0];case Xe.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Xe.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Xe[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),a=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*a[i+1];const o=eo(a,!1),r=ye(this.valuesDType,H(o));if(n[0]*a[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],a[0]);for(let l=1;l<=this.raggedRank;++l)i=this.calculateOutputIndex(l-1,i,n[l],a[l]);this.setOutput(this.raggedRank,i,r,o)}return[o,r]}setOutput(t,e,a,n){if(a.length===0)return;const o=this.values,r=a;let c=n.slice();c=c.slice(t+1);const i=H(c),l=e.length;let u=this.defaultValue;if(u.length!==i&&u.length!==1){const f=this.defaultValueShape;ip(()=>{const x=cp(u,f);u=lp(x,c).dataSync()})}let d=0,p=0,h=0;for(let f=0;f<=l;++f){let x=f<l?e[f]:-1;if(x===h){++h;continue}if(p<h){const m=o.subarray(d*i),g=r.subarray(p*i),C=(h-p)*i;Ja(g,m,C)}if(f>=l){const m=a.length;x=Math.floor(m/i)}if(x>h)if(this.defaultValue.length===1)r.subarray(h*i,x*i).fill(this.defaultValue[0]),h=x;else for(;x>h;){const m=r.slice(h*i);Ja(m,u,i),++h}x<0?(d=f+1,p=h):(d=f,p=h,h=p+1)}}}function Ja(s,t,e){for(let a=0;a<e;a++)s[a]=t[a]}function eo(s,t){const e=[];for(let a of s){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}e.push(a)}return e}function EI(s,t,e,a,n,o,r,c,i,l){return new os(s,t,e,a,n,o,r,c,i,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(s,t,e,a){const n=s===t,o=s<t&&e<0,r=t<s&&e>1;if(n||o||r)return Le(0,a);const c=Math.abs(Math.ceil((t-s)/e)),i=Le(c,a);t<s&&e===1&&(e=-1),i[0]=s;for(let l=1;l<i.length;l++)i[l]=i[l-1]+e;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DI=ln(s=>1/Math.sqrt(s)),OI=un(Xo,DI),AI={kernelName:Xo,backendName:"cpu",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(s,t,e,a,n,o,r,c,i,l){const u=[a/n,n],d=s.values,p=t.values;if(a===0)return le(e,t.dtype);const h=le(u,t.dtype);typeof i=="string"||typeof i=="number"?h.values.fill(i):typeof i=="boolean"&&h.values.fill(+i);for(let f=0;f<o;f++){const x=[];let m=0;for(let g=0;g<r;g++){const C=d[f*r+g];x.push(C),m+=C*c[g]}if(m<0||m>=a/n)throw new Error(`Invalid indices: ${x} does not index into ${e}`);for(let g=0;g<n;g++)l?h.values[m*n+g]+=p[f*n+g]:h.values[m*n+g]=t.rank===0?p[0]:p[f*n+g]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu=ie(qo,s=>1/(1+Math.exp(-s))),PI={kernelName:qo,backendName:"cpu",kernelFunc:Nu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _I(s,t,e,a,n){const o=fp(a,t,e),r=H(e),c=J(a);if(o){const d=mp(t,c);return n==="string"?s.slice(d,d+r):s.subarray(d,d+r)}const i=n==="string"?ns(s):s,l=le(a,n,i),u=le(e,n);for(let d=0;d<u.size;++d){const p=u.indexToLoc(d),h=p.map((f,x)=>f+t[x]);u.set(l.get(...h),...p)}return n==="string"?gp(u.values):u.values}function Bt(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{begin:o,size:r}=a;X(n,"slice");const[c,i]=pp(n,o,r);hp(n,c,i);const l=e.data.get(n.dataId).values,u=_I(l,c,i,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,u)}const MI={kernelName:dp,backendName:"cpu",kernelFunc:Bt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(s,t,e,a,n,o,r){const c=t[0],i=o[0],l=new Array(i),u=new Array(c),d=t[1];if(i===0){if(c!==0)throw new Error(xp(c));const m=ye(e,0),g=ye(n,0);return[m,[0,d],g,l,u]}let p=!0,h=0;const f=new Array(i).fill(0);for(let m=0;m<c;++m){const g=s[m*d];if(g<0)throw new Error(Cp(m,g));if(g>=i)throw new Error($p(m,g,i));++f[g],p=p&&g>=h,h=g}let x=!0;for(let m=0;m<i;++m){const g=f[m]===0;l[m]=g,x=x&&!g,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(x&&p){const m=s,g=a;for(let C=0;C<c;++C)u[C]=C;return[m,[c,d],g,l,u]}else{const m=f[i-1],g=ye(e,m*d),C=ye(n,m),b=new Array(i).fill(0);for(let $=0;$<c;++$){const I=s[$*d],v=b[I],y=(I===0?0:f[I-1])+v;b[I]++;for(let w=0;w<d;++w)g[y*d+w]=s[$*d+w];C[y]=a[$],u[$]=y}for(let $=0;$<i;++$)if(b[$]===0){const v=$===0?0:f[$-1];g[v*d+0]=$;for(let y=1;y<d;++y)g[v*d+y]=0;C[v]=r}return[g,[m,d],C,l,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(s,t,e,a,n){const o=H(a),r=t[0],c=n.length,i=[];let l=1,u=-1;for(let m=0;m<c;++m){const g=n[m];if(g===-1){if(u!==-1)throw new Error(bp(u,m));u=m,i.push(1)}else{if(g<0)throw new Error(Ip(m,g));l*=g,i.push(g)}}if(u!==-1){if(l<=0)throw new Error(vp());const m=Math.trunc(o/l);if(l*m!==o)throw new Error(yp(a,i));i[u]=m}if(H(i)!==o)throw new Error(wp(a,i));const p=a.length,h=[];if(p>0){h[p-1]=1;for(let m=p-2;m>=0;--m)h[m]=h[m+1]*a[m+1]}const f=[];if(c>0){f[c-1]=1;for(let m=c-2;m>=0;--m)f[m]=f[m+1]*i[m+1]}const x=ye(e,r*c);for(let m=0;m<r;++m){let g=0;for(let C=0;C<p;++C)g+=s[m*p+C]*h[C];for(let C=0;C<c;++C)x[m*c+C]=Math.trunc(g/f[C]),g%=f[C]}return[x,[r,c],i]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(s,t,e,a,n,o=!1,r=0){const c=a.length,i=[t[0],s.length/t[0]],l=i[1],d=c>0?n[c-1]+1:0;if(d<0)throw new Error(Ma());const p=t.slice();p[0]=d;const h=p.reduce((b,$)=>b*$,1),f=ye(e,h);if(c===0)return d>0&&f.fill(r),[f,p];if(d<=0)throw new Error(Ma());let x=0,m=1,g=0,C=n[x];for(;;){let b=0;if(m<c){if(b=n[m],C===b){++m;continue}if(C>=b)throw new Error(Sp())}if(C<0||C>=d)throw new Error(kp(C,d));C>g&&f.fill(r,g*l,C*l);for(let $=x;$<m;++$){const I=a[$];if(I<0||I>=i[0])throw new Error(Rp($,a[$],i[0]));for(let v=0;v<l;v++)f[C*l+v]+=s[I*l+v]}if(o)for(let $=0;$<l;$++)f[C*l+$]/=m-x;if(x=m,++m,g=C+1,C=b,m>c)break}return g<d&&f.fill(r,g*l,d*l),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BI=ie(jo,s=>Math.sqrt(s)),WI={kernelName:jo,backendName:"cpu",kernelFunc:BI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI=Ce((s,t)=>{const e=s-t;return e*e}),UI=$e(Ko,zI),GI={kernelName:Ko,backendName:"cpu",kernelFunc:UI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(s,t,e,a){const n=le(s,t.dtype);for(let o=0;o<n.size;o++){const r=n.indexToLoc(o),c=new Array(r.length);for(let i=0;i<c.length;i++)c[i]=r[i]*e[i]+a[i];n.set(t.get(...c),...r)}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XI{constructor(t,e,a,n,o,r){this.separator=Zn(t),this.nGramWidths=e,this.leftPad=Zn(a),this.rightPad=Zn(n),this.padWidth=o,this.preserveShort=r}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const a=this.getPadWidth(e);return Math.max(0,t+2*a-e+1)}createNGrams(t,e,a,n,o,r){for(let c=0;c<o;++c){const i=this.getPadWidth(r),l=Math.max(0,i-c),u=Math.max(0,i-(o-(c+1))),d=r-(l+u),p=e+(l>0?0:c-i);let h=0;h+=l*this.leftPad.length;for(let C=0;C<d;++C)h+=t[p+C].length;h+=u*this.rightPad.length;const f=l+u+d-1;h+=f*this.separator.length,a[n+c]=new Uint8Array(h);const x=a[n+c];let m=0;const g=C=>C.forEach(b=>x[m++]=b);for(let C=0;C<l;++C)g(this.leftPad),g(this.separator);for(let C=0;C<d-1;++C)g(t[p+C]),g(this.separator);if(d>0){g(t[p+d-1]);for(let C=0;C<u;++C)g(this.separator),g(this.rightPad)}else{for(let C=0;C<u-1;++C)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(t,e){const a=t.length,n=e.length;if(n>0){let i=e[0];if(i!==0)throw new Error(`First split value must be 0, got ${i}`);for(let l=1;l<n;++l){let u=e[l]>=i;if(u=u&&e[l]<=a,!u)throw new Error(`Invalid split value ${e[l]}, must be in [${i}, ${a}]`);i=e[l]}if(i!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${i}`)}const o=n-1,r=ye("int32",n);if(a===0||n===0){const i=new Array(a);for(let l=0;l<=o;++l)r[l]=0;return[i,r]}r[0]=0;for(let i=1;i<=o;++i){const l=e[i]-e[i-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&u===0&&(u=1),r[i]=r[i-1]+u}const c=new Array(r[o]);for(let i=0;i<o;++i){const l=e[i];let u=r[i];if(this.nGramWidths.forEach(d=>{const p=e[i+1]-e[i],h=this.getNumNGrams(p,d);this.createNGrams(t,l,c,u,h,d),u+=h}),this.preserveShort&&u===r[i]){const d=e[i+1]-e[i];if(d===0)continue;const p=d+2*this.padWidth,h=1;this.createNGrams(t,l,c,u,h,p)}}return[c,r]}}function qI(s,t,e,a,n,o,r,c){return new XI(e,a,n,o,r,c).compute(s,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(s,t,e,a){if(!s.length)return;if(t.length===0){for(let o=0;o<s.length;++o)a.push(s.subarray(o,o+1));return}if(t.length===1){const o=t[0];let r=s.indexOf(o);for(;r!==-1;){const c=s.subarray(0,r);(!e||c.length!==0)&&a.push(c),s=s.subarray(r+1),r=s.indexOf(o)}(!e||s.length!==0)&&a.push(s);return}let n=0;for(let o=0;o<s.length+1;o++)if(o===s.length||t.indexOf(s[o])!==-1){const r=s.subarray(n,o);(!e||r.length!==0)&&a.push(r),n=o+1}}function KI(s,t,e){const a=s.length,n=[];let o=0,r=0;const c=new Array(a);for(let p=0;p<a;++p){const h=n.length;jI(s[p],t,e,n);const f=n.length-h;c[p]=f,o+=f,r=Math.max(r,f)}const i=ye("int32",o*2),l=new Array(o),u=[a,r];let d=0;for(let p=0;p<a;++p)for(let h=0;h<c[p];++h)i[d*2]=p,i[d*2+1]=h,l[d]=n[d],++d;return[i,l,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YI(s,t){const e=ye("int32",s.length);for(let a=0;a<s.length;++a)e[a]=Np(s[a]).modulo(t).getLowBitsUnsigned();return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QI=Ce((s,t)=>s-t),ZI=va((s,t,e,a)=>({real:s-e,imag:t-a})),ya=$e(Yo,QI,ZI),JI={kernelName:Yo,backendName:"cpu",kernelFunc:ya};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(s,t){const e=new Array(s.rank);for(let n=0;n<e.length;n++)e[n]=s.shape[n]*t[n];const a=le(e,s.dtype);for(let n=0;n<a.values.length;++n){const o=a.indexToLoc(n),r=new Array(s.rank);for(let i=0;i<r.length;i++)r[i]=o[i]%s.shape[i];const c=s.locToIndex(r);a.values[n]=s.values[c]}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wn=(s,t)=>{const e=t.value-s.value;return e===0?s.index-t.index:e};function Eu(s,t,e=0,a=s.length-1){for(;a>e;){if(a-e>600){const c=a-e+1,i=t-e+1,l=Math.log(c),u=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*u*(c-u)/c)*Math.sign(i-c/2),p=Math.max(e,Math.floor(t-i*u/c+d)),h=Math.min(a,Math.floor(t+(c-i)*u/c+d));Eu(s,t,p,h)}const n=s[t];let o=e,r=a;for($n(s,e,t),wn(s[a],n)>0&&$n(s,e,a);o<r;){for($n(s,o,r),o++,r--;wn(s[o],n)<0;)o=o+1;for(;wn(s[r],n)>0;)r=r-1}wn(s[e],n)===0?$n(s,e,r):(r=r+1,$n(s,r,a)),r<=t&&(e=r+1),t<=r&&(a=r-1)}}function tv(s,t,e,a,n){const o=t[t.length-1],[r,c]=[s.length/o,o],i=Re(e,r*a),l=Re("int32",r*a);for(let d=0;d<r;d++){const p=d*c,h=s.subarray(p,p+c);let f=new Array(h.length);h.forEach((C,b)=>f[b]={value:C,index:b}),a<f.length&&(Eu(f,a),f=f.slice(0,a)),n&&f.sort(wn);const x=d*a,m=i.subarray(x,x+a),g=l.subarray(x,x+a);for(let C=0;C<a;C++)m[C]=f[C].value,g[C]=f[C].index}const u=t.slice();return u[u.length-1]=a,[le(u,e,i),le(u,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(s,t,e,a){const n=Oe(t,e)[0],o=[1,e[0],1];for(let f=0;f<n;f++)o[0]*=e[f];o[1]=e[n];for(let f=n+1;f<e.length;f++)o[2]*=e[f];const r={},c=new Int32Array(e[n]),i=new ke(o,a,s),l=[],u=o[0]===1&&o[2]===1;for(let f=0;f<e[n];f++){let x;if(u)x=s[f].toString();else{const m=[];for(let g=0;g<o[0];g++)for(let C=0;C<o[2];C++)m.push(i.get(g,f,C));x=m.join(",")}if(r[x]!==void 0)c[f]=r[x];else{const m=Object.keys(r).length;r[x]=m,c[f]=m,l.push(f)}}const d=o.slice();d[1]=Object.keys(r).length;const p=new ke(d,a);l.forEach((f,x)=>{for(let m=0;m<o[0];m++)for(let g=0;g<o[2];g++)p.set(i.get(m,f,g),m,x,g)});const h=e.slice();return h[n]=d[1],{outputValues:p.values,outputShape:h,indices:c}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Tp("cpu",()=>new Rs,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fu=ie(Qo,s=>s>=0?s:Math.exp(s)-1),sv={kernelName:Qo,backendName:"cpu",kernelFunc:Fu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Du(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{alpha:o}=a;X([n],"leakyRelu");const r=H(n.shape),c=e.data.get(n.dataId).values,i=Re("float32",r);for(let l=0;l<c.length;l++)i[l]=c[l]<0?o*c[l]:c[l];return e.makeTensorInfo(n.shape,"float32",i)}const av={kernelName:Ep,backendName:"cpu",kernelFunc:Du};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov=Ce((s,t)=>s<0?t*s:s);function Ou(s){const{inputs:t,backend:e}=s,{x:a,alpha:n}=t;X([a,n],"prelu");const o=e.data.get(a.dataId).values,r=e.data.get(n.dataId).values,[c,i]=ov(a.shape,n.shape,o,r,"float32");return e.makeTensorInfo(i,"float32",c)}const rv={kernelName:Fp,backendName:"cpu",kernelFunc:Ou};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Au=ie(Zo,s=>Math.max(0,s)),iv={kernelName:Zo,backendName:"cpu",kernelFunc:Au};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pu=ie(Jo,s=>Math.min(Math.max(0,s),6)),cv={kernelName:Jo,backendName:"cpu",kernelFunc:Pu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rs(s,t,e,a,n){if(e==="linear")return at({inputs:{x:t},backend:s});if(e==="relu")return Au({inputs:{x:t},backend:s});if(e==="elu")return Fu({inputs:{x:t},backend:s});if(e==="relu6")return Pu({inputs:{x:t},backend:s});if(e==="prelu")return Ou({inputs:{x:t,alpha:a},backend:s});if(e==="leakyrelu")return Du({inputs:{x:t},backend:s,attrs:{alpha:n}});if(e==="sigmoid")return Nu({inputs:{x:t},backend:s});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{shape:o}=a,r=H(n.shape),c=Op(o,r),i=H(c);we(r===i,()=>`The new shape (${c}) has ${i} elements and the old shape (${n.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),e.incRef(n.dataId);const l=e.data.get(n.dataId);if(l.complexTensorInfos!=null){const u=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;u.shape=c,d.shape=c}return{dataId:n.dataId,shape:c,dtype:n.dtype}}const lv={kernelName:Dp,backendName:"cpu",kernelFunc:de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _u(s){const{inputs:t,backend:e,attrs:a}=s,{a:n,b:o}=t,{transposeA:r,transposeB:c}=a;X([n,o],"matMul");const i=n.shape.length,l=o.shape.length,u=r?n.shape[i-2]:n.shape[i-1],d=c?o.shape[l-1]:o.shape[l-2],p=r?n.shape[i-1]:n.shape[i-2],h=c?o.shape[l-2]:o.shape[l-1],f=n.shape.slice(0,-2),x=o.shape.slice(0,-2),m=H(f),g=H(x),b=fs(n.shape.slice(0,-2),o.shape.slice(0,-2)).concat([p,h]);we(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${n.shape} and ${o.shape} and transposeA=${r} and transposeB=${c} must match.`);const $=r?[m,u,p]:[m,p,u],I=c?[g,h,d]:[g,d,h],v=de({inputs:{x:n},backend:e,attrs:{shape:$}}),y=de({inputs:{x:o},backend:e,attrs:{shape:I}}),w=r?v.shape[1]:v.shape[2],k=r?v.shape[2]:v.shape[1],S=c?y.shape[1]:y.shape[2],E=Math.max(m,g),O=e.data.get(v.dataId).values,F=e.data.get(y.dataId).values,D=J(v.shape),N=J(y.shape),[T,_,R]=r?[D[0],1,D[1]]:[D[0],D[1],1],[P,L,M]=c?[1,N[1],N[0]]:[N[1],1,N[0]],W=k*S,V=le([E,k,S],v.dtype),z=V.values,B=e.blockSize;for(let G=0;G<E;G++)for(let j=0;j<k;j+=B)for(let Q=0;Q<S;Q+=B)for(let Z=0;Z<w;Z+=B){const ee=Math.min(j+B,k),te=Math.min(Q+B,S),oe=Math.min(Z+B,w);for(let ue=j;ue<ee;ue++)for(let he=Q;he<te;he++){let fe=0;for(let ce=Z;ce<oe;ce++){const me=Math.min(G,m-1)*T,ge=Math.min(G,g-1)*M,ct=O[me+ue*_+ce*R],be=F[ce*P+he*L+ge];fe+=ct*be}z[G*W+(ue*S+he)]+=fe}}return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(y),e.makeTensorInfo(b,V.dtype,V.values)}const uv={kernelName:Ap,backendName:"cpu",kernelFunc:_u};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(s){const{inputs:t,backend:e,attrs:a}=s,{a:n,b:o,bias:r,preluActivationWeights:c}=t,{transposeA:i,transposeB:l,activation:u,leakyreluAlpha:d}=a;let p,h,f;const x=[];p=_u({inputs:{a:n,b:o},attrs:{transposeA:i,transposeB:l},backend:e}),r&&(h=Jt({inputs:{a:p,b:r},backend:e}),x.push(p),p=h),u&&(f=rs(e,p,u,c,d),x.push(p),p=f);for(const g of x)e.disposeIntermediateTensorInfo(g);return p}const pv={kernelName:Pp,backendName:"cpu",kernelFunc:dv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv=ie(er,s=>Math.acos(s)),fv={kernelName:er,backendName:"cpu",kernelFunc:hv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv=ie(tr,s=>Math.acosh(s)),gv={kernelName:tr,backendName:"cpu",kernelFunc:mv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(s){const{inputs:t,backend:e}=s,a=t;X(t,"addN");const n=a.map(c=>e.data.get(c.dataId).values),o=le(a[0].shape,a[0].dtype),r=o.values;for(let c=0;c<a.length;c++){const i=n[c];for(let l=0;l<r.length;l++)r[l]+=i[l]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}const Cv={kernelName:_p,backendName:"cpu",kernelFunc:xv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;X(n,"all");const c=Oe(o,n.shape);let i=c;const l=ot(i,n.shape.length);let u=n;l!=null&&(u=De({inputs:{x:n},backend:e,attrs:{perm:l}}),i=rt(i.length,n.shape.length)),zt("all",i,u.shape.length);const[d,p]=pt(u.shape,i),h=H(p),f=Le(H(d),u.dtype),x=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const C=g*h;let b=x[C];for(let $=0;$<h;++$){const I=x[C+$];b=b&&I}f[g]=b}l!=null&&e.disposeIntermediateTensorInfo(u);const m=e.makeTensorInfo(d,u.dtype,f);if(r){const g=Wt(d,c),C=de({inputs:{x:m},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(m),C}return m}const bv={kernelName:Mp,backendName:"cpu",kernelFunc:$v};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;X(n,"any");const c=Oe(o,n.shape);let i=c;const l=ot(i,n.shape.length);let u=n;l!=null&&(u=De({inputs:{x:n},backend:e,attrs:{perm:l}}),i=rt(i.length,n.shape.length)),zt("any",i,u.shape.length);const[d,p]=pt(u.shape,i),h=H(p),f=Le(H(d),u.dtype),x=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const C=g*h;let b=x[C];for(let $=0;$<h;++$){const I=x[C+$];b=b||I}f[g]=b}l!=null&&e.disposeIntermediateTensorInfo(u);const m=e.makeTensorInfo(d,u.dtype,f);if(r){const g=Wt(d,c),C=de({inputs:{x:m},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(m),C}return m}const vv={kernelName:Lp,backendName:"cpu",kernelFunc:Iv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o}=a;X(n,"argMax");let r=Oe(o,n.shape);const c=ot(r,n.shape.length);let i=n;const l=[];c!=null&&(i=De({inputs:{x:n},backend:e,attrs:{perm:c}}),l.push(i),r=rt(r.length,i.shape.length)),r=[r[0]],zt("argMax",r,i.shape.length);const[u,d]=pt(i.shape,r),p=H(u),h=Le(p,"int32"),f=H(d),x=e.data.get(i.dataId).values;for(let m=0;m<h.length;++m){const g=m*f;let C=x[g],b=0;for(let $=0;$<f;++$){const I=x[g+$];I>C&&(C=I,b=$)}h[m]=b}return l.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(u,"int32",h)}const wv={kernelName:Vp,backendName:"cpu",kernelFunc:yv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o}=a;X(n,"argMin");let r=Oe(o,n.shape);const c=ot(r,n.shape.length);let i=n;const l=[];c!=null&&(i=De({inputs:{x:n},backend:e,attrs:{perm:c}}),l.push(i),r=rt(r.length,i.shape.length)),r=[r[0]],zt("argMin",r,i.shape.length);const[u,d]=pt(i.shape,r),p=H(u),h=Le(p,"int32"),f=H(d),x=e.data.get(i.dataId).values;for(let m=0;m<h.length;++m){const g=m*f;let C=x[g],b=0;for(let $=0;$<f;++$){const I=x[g+$];I<C&&(C=I,b=$)}h[m]=b}return l.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(u,"int32",h)}const kv={kernelName:Bp,backendName:"cpu",kernelFunc:Sv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rv=ie(nr,s=>Math.asin(s)),Nv={kernelName:nr,backendName:"cpu",kernelFunc:Rv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tv=ie(sr,s=>Math.asinh(s)),Ev={kernelName:sr,backendName:"cpu",kernelFunc:Tv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv=ie(ar,s=>Math.atan(s)),Dv={kernelName:ar,backendName:"cpu",kernelFunc:Fv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ov=Ce((s,t)=>Math.atan2(s,t)),Av=$e(or,Ov),Pv={kernelName:or,backendName:"cpu",kernelFunc:Av};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _v=ie(rr,s=>Math.atanh(s)),Mv={kernelName:rr,backendName:"cpu",kernelFunc:_v};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(s,t,e,a,n,o){const r=n.strideHeight,c=n.strideWidth,i=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,d=n.effectiveFilterWidth,p=n.padInfo.top,h=n.padInfo.left,f=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=le(n.outShape,e),m=x.values,g=n.outShape[1]*n.outShape[2]*n.outShape[3],C=n.outShape[2]*n.outShape[3],b=n.outShape[3];for(let $=0;$<n.batchSize;++$){const I=$*g,v=$*a[0];for(let y=0;y<n.inChannels;++y)for(let w=0;w<n.outHeight;++w){const k=w*r-p,S=Math.max(0,k),E=Math.min(n.inHeight,u+k),O=I+w*C;for(let F=0;F<n.outWidth;++F){const D=F*c-h,N=Math.max(0,D),T=Math.min(n.inWidth,d+D);let _=f,R=0,P=0;for(let M=S;M<E;M+=i){const W=v+M*a[1];for(let V=N;V<T;V+=l){const z=W+V*a[2],B=s[z+y];o==="max"&&B>_?_=B:o==="avg"&&(R+=B,P++)}if(isNaN(_))break}const L=O+F*b+y;m[L]=o==="avg"?R/P:_}}}return x}function Mu(s,t,e,a,n=!1,o=!1){const r=le(a.outShape,"int32"),c=a.strideHeight,i=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,p=a.effectiveFilterWidth,h=a.padInfo.top,f=a.padInfo.left,x=le(t,e,s);for(let m=0;m<a.batchSize;++m)for(let g=0;g<a.inChannels;++g)for(let C=0;C<a.outHeight;++C){const b=C*c-h;let $=b;for(;$<0;)$+=l;const I=Math.min(a.inHeight,d+b);for(let v=0;v<a.outWidth;++v){const y=v*i-f;let w=y;for(;w<0;)w+=u;const k=Math.min(a.inWidth,p+y);let S=Number.NEGATIVE_INFINITY,E=-1;for(let O=$;O<I;O+=l){const F=O-b;for(let D=w;D<k;D+=u){const N=D-y,T=x.get(m,O,D,g);T>S&&(S=T,n?E=o?((m*a.inHeight+O)*a.inWidth+D)*a.inChannels+g:(O*a.inWidth+D)*a.inChannels+g:E=F*p+N)}}r.set(E,m,C,v,g)}}return r}function Lu(s,t,e,a,n,o){const r=n.strideDepth,c=n.strideHeight,i=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,d=n.dilationWidth,p=n.effectiveFilterDepth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth,x=n.padInfo.front,m=n.padInfo.top,g=n.padInfo.left,C=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=le(n.outShape,e),$=b.values,I=n.outShape[1]*n.outShape[2]*n.outShape[3]*n.outShape[4],v=n.outShape[2]*n.outShape[3]*n.outShape[4],y=n.outShape[3]*n.outShape[4],w=n.outShape[4];for(let k=0;k<n.batchSize;++k){const S=k*I,E=k*a[0];for(let O=0;O<n.inChannels;++O)for(let F=0;F<n.outDepth;++F){const D=F*r-x;let N=D;for(;N<0;)N+=l;const T=Math.min(n.inDepth,p+D),_=S+F*v;for(let R=0;R<n.outHeight;++R){const P=R*c-m;let L=P;for(;L<0;)L+=u;const M=Math.min(n.inHeight,h+P),W=_+R*y;for(let V=0;V<n.outWidth;++V){const z=V*i-g;let B=z;for(;B<0;)B+=d;const G=Math.min(n.inWidth,f+z),j=W+V*w;let Q=C,Z=0,ee=0;for(let oe=N;oe<T;oe+=l){const ue=E+oe*a[1];for(let he=L;he<M;he+=u){const fe=ue+he*a[2];for(let ce=B;ce<G;ce+=d){const me=fe+ce*a[3],ge=s[me+O];if(o==="max"&&ge>Q?Q=ge:o==="avg"&&(Z+=ge,ee++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}const te=j+O;$[te]=o==="avg"?Z/ee:Q}}}}return b}function Lv(s,t){const e=le(t.outShape,"int32"),a=t.strideDepth,n=t.strideHeight,o=t.strideWidth,r=t.dilationDepth,c=t.dilationHeight,i=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let x=0;x<t.batchSize;++x)for(let m=0;m<t.inChannels;++m)for(let g=0;g<t.outDepth;++g){const C=g*a-p;let b=C;for(;b<0;)b+=r;const $=Math.min(t.inDepth,l+C);for(let I=0;I<t.outHeight;++I){const v=I*n-h;let y=v;for(;y<0;)y+=c;const w=Math.min(t.inHeight,u+v);for(let k=0;k<t.outWidth;++k){const S=k*o-f;let E=S;for(;E<0;)E+=i;const O=Math.min(t.inWidth,d+S);let F=Number.NEGATIVE_INFINITY,D=-1;for(let N=b;N<$;N+=r){const T=N-C;for(let _=y;_<w;_+=c){const R=_-v;for(let P=E;P<O;P+=i){const L=P-S,M=s.get(x,N,_,P,m);M>=F&&(F=M,D=T*u*d+R*u+L)}}}e.set(D,x,g,I,k,m)}}}return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t;X(n,"avgPool");const{filterSize:o,strides:r,pad:c,dimRoundingMode:i}=a,l=1;we(ca(r,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const u=Dn(n.shape,o,r,l,c,i);let d;if(u.filterWidth===1&&u.filterHeight===1&&la(u.inShape,u.outShape))d=at({inputs:{x:n},backend:e});else{const p=e.data.get(n.dataId).values,h=J(n.shape),f=wa(p,n.shape,n.dtype,h,u,"avg");d=e.makeTensorInfo(u.outShape,n.dtype,f.values)}return d}const Bv={kernelName:Wp,backendName:"cpu",kernelFunc:Vv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{filterSize:o,strides:r,pad:c,dimRoundingMode:i,dataFormat:l}=a;X(n,"avgPool3d");const u=gs(n.shape,o,r,1,c,i,l),d=e.data.get(n.dataId).values,p=Lu(d,n.shape,n.dtype,J(n.shape),u,"avg");return e.makeTensorInfo(p.shape,"float32",p.values)}const zv={kernelName:zp,backendName:"cpu",kernelFunc:Wv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,{filterSize:r,strides:c,pad:i,dimRoundingMode:l}=a;X([n,o],"avgPool3DGrad");const u=gs(o.shape,r,c,1,i,l),d=u.strideDepth,p=u.strideHeight,h=u.strideWidth,f=u.filterDepth,x=u.filterHeight,m=u.filterWidth,g=u.dilationDepth,C=u.dilationHeight,b=u.dilationWidth,$=u.effectiveFilterDepth,I=u.effectiveFilterHeight,v=u.effectiveFilterWidth,y=$-1-u.padInfo.front,w=v-1-u.padInfo.left,k=I-1-u.padInfo.top,S=le(o.shape,"float32"),E=1/(f*x*m),O=e.bufferSync(n);for(let F=0;F<u.batchSize;++F)for(let D=0;D<u.inChannels;++D)for(let N=0;N<u.inDepth;++N)for(let T=0;T<u.inHeight;++T)for(let _=0;_<u.inWidth;++_){const R=N-y,P=T-k,L=_-w;let M=0;for(let W=0;W<$;W+=g){const V=(R+W)/d;if(!(V<0||V>=u.outDepth||Math.floor(V)!==V))for(let z=0;z<I;z+=C){const B=(P+z)/p;if(!(B<0||B>=u.outHeight||Math.floor(B)!==B))for(let G=0;G<v;G+=b){const j=(L+G)/h;if(j<0||j>=u.outWidth||Math.floor(j)!==j)continue;const Q=O.get(F,V,B,j,D);M+=Q}}}S.set(M*E,F,N,T,_,D)}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const Gv={kernelName:Up,backendName:"cpu",kernelFunc:Uv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,r=o;X([n,o],"avgPoolGrad");const{filterSize:c,strides:i,pad:l}=a,u=Dn(r.shape,c,i,1,l),d=u.strideHeight,p=u.strideWidth,h=u.filterHeight,f=u.filterWidth,x=u.dilationHeight,m=u.dilationWidth,g=u.effectiveFilterHeight,C=u.effectiveFilterWidth,b=C-1-u.padInfo.left,$=g-1-u.padInfo.top,I=le(r.shape,"float32"),v=1/(h*f),y=e.data.get(n.dataId).values,w=le(n.shape,"float32",y);for(let k=0;k<u.batchSize;++k)for(let S=0;S<u.inChannels;++S)for(let E=0;E<u.inHeight;++E)for(let O=0;O<u.inWidth;++O){const F=E-$,D=O-b;let N=0;for(let T=0;T<g;T+=x){const _=(F+T)/d;if(!(_<0||_>=u.outHeight||Math.floor(_)!==_))for(let R=0;R<C;R+=m){const P=(D+R)/p;if(P<0||P>=u.outWidth||Math.floor(P)!==P)continue;const L=w.get(k,_,P,S);N+=L}}I.set(N*v,k,E,O,S)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const Xv={kernelName:Gp,backendName:"cpu",kernelFunc:Hv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,scale:o,offset:r,mean:c,variance:i}=t;we(c.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),we(r==null||c.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),we(o==null||c.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),X([n,c,i,o,r],"batchNorm");let{varianceEpsilon:l}=a;l==null&&(l=.001);const u=e.data.get(n.dataId).values,d=e.data.get(c.dataId).values,p=e.data.get(i.dataId).values,h=o?e.data.get(o.dataId).values:new Float32Array([1]),f=r?e.data.get(r.dataId).values:new Float32Array([0]),x=new Float32Array(u.length),m=f.length,g=h.length,C=p.length,b=d.length;let $=0,I=0,v=0,y=0;for(let w=0;w<u.length;++w)x[w]=f[$++]+(u[w]-d[I++])*h[v++]/Math.sqrt(p[y++]+l),$>=m&&($=0),I>=b&&(I=0),v>=g&&(v=0),y>=C&&(y=0);return e.makeTensorInfo(n.shape,n.dtype,x)}const jv={kernelName:Hp,backendName:"cpu",kernelFunc:qv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockShape:o,crops:r}=a;X([n],"batchToSpaceND");const c=o.reduce((g,C)=>g*C),i=ir(n.shape,o,c),l=cr(i.length,o.length),u=lr(n.shape,o,c),d=qp(r,o.length),p=jp(u,r,o.length),h=de({inputs:{x:n},backend:e,attrs:{shape:i}}),f=De({inputs:{x:h},backend:e,attrs:{perm:l}}),x=de({inputs:{x:f},backend:e,attrs:{shape:u}}),m=Bt({inputs:{x},backend:e,attrs:{begin:d,size:p}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(x),m}const Yv={kernelName:Xp,backendName:"cpu",kernelFunc:Kv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,weights:o}=t,{size:r}=a,c=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,l=yu(c,i,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,l)}const Zv={kernelName:Kp,backendName:"cpu",kernelFunc:Qv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jv(s){const{inputs:t,backend:e}=s,{s0:a,s1:n}=t,o=e.data.get(a.dataId).values,r=e.data.get(n.dataId).values,c=fs(Array.from(o),Array.from(r));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const ey={kernelName:Yp,backendName:"cpu",kernelFunc:Jv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ty=ie(ur,(s,t)=>{const e=t;return s>e.clipValueMax?e.clipValueMax:s<e.clipValueMin?e.clipValueMin:s}),ny={kernelName:ur,backendName:"cpu",kernelFunc:ty};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sy=s=>{const{x:t}=s.inputs,e=s.backend,a=new Float32Array(H(t.shape)),n=e.data.get(t.dataId),o=n.complexTensorInfos.real,r=n.complexTensorInfos.imag,c=e.data.get(o.dataId).values,i=e.data.get(r.dataId).values;for(let l=0;l<c.length;l++){const u=c[l],d=i[l];a[l]=Math.hypot(u,d)}return e.makeOutput(a,t.shape,"float32")},ay={kernelName:Qp,backendName:"cpu",kernelFunc:sy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(s){const{inputs:t,backend:e}=s,{input:a}=t,n=e.data.get(a.dataId).complexTensorInfos.imag,o=e.data.get(n.dataId).values;return e.makeTensorInfo(n.shape,n.dtype,o)}const oy={kernelName:Zp,backendName:"cpu",kernelFunc:en};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tn(s){const{inputs:t,backend:e,attrs:a}=s,{axis:n}=a,o=Oe(n,t[0].shape)[0],r=t.map(x=>x.shape);eh(r,o);let c=_s(t.map(x=>x.shape),o);if(H(c)===0)return e.makeTensorInfo(c,t[0].dtype,[]);const i=t.filter(x=>H(x.shape)>0);if(i.length===1)return at({inputs:{x:i[0]},backend:e});if(i[0].dtype==="complex64"){const x=i.map($=>Vt({inputs:{input:$},backend:e})),m=i.map($=>en({inputs:{input:$},backend:e})),g=tn({inputs:x,backend:e,attrs:{axis:o}}),C=tn({inputs:m,backend:e,attrs:{axis:o}}),b=Pe({inputs:{real:g,imag:C},backend:e});return x.forEach($=>e.disposeIntermediateTensorInfo($)),m.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(C),b}const l=i.map(x=>{const g=[-1,H(x.shape.slice(o))];return de({inputs:{x},backend:e,attrs:{shape:g}})}),u=l.map(x=>({vals:e.data.get(x.dataId).values,shape:x.shape}));c=_s(l.map(x=>x.shape),1);const d=l[0].shape[0]===1,p=Tb(u,c,t[0].dtype,d),h=_s(i.map(x=>x.shape),o),f=e.makeTensorInfo(h,t[0].dtype,p);return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),f}const ry={kernelName:Jp,backendName:"cpu",kernelFunc:tn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dataFormat:i,dilations:l,dimRoundingMode:u}=a;X([n,o],"conv2d");const d=ua(i),p=rn(n.shape,o.shape,r,l,c,u,!1,d),h=p.filterHeight,f=p.filterWidth,x=p.dilationHeight,m=p.dilationWidth,g=p.padInfo.left,C=p.padInfo.top,b=p.dataFormat==="channelsLast",$=new ke(p.outShape,n.dtype),I=J(n.shape),v=J(o.shape),y=I[0],w=b?I[1]:I[2],k=b?I[2]:1,S=b?1:I[1],E=$.strides[0],O=b?$.strides[1]:$.strides[2],F=b?$.strides[2]:1,D=b?1:$.strides[1],N=e.data.get(n.dataId).values,T=e.data.get(o.dataId).values,_=$.values;for(let R=0;R<p.batchSize;++R){const P=R*y,L=R*E;for(let M=0;M<p.outHeight;++M){const W=L+M*O,V=M*p.strideHeight-C;for(let z=0;z<h;++z){const B=V+z*x;if(B<0||B>=p.inHeight)continue;const G=z*v[0],j=P+B*w;for(let Q=0;Q<p.outWidth;++Q){const Z=W+Q*F,ee=Q*p.strideWidth-g;for(let te=0;te<f;++te){const oe=ee+te*m;if(oe<0||oe>=p.inWidth)continue;const ue=G+te*v[1],he=j+oe*k;let fe=ue;for(let ce=0;ce<p.inChannels;++ce){const me=N[he+ce*S];for(let ge=0;ge<p.outChannels;++ge)_[Z+ge*D]+=me*T[fe+ge];fe+=p.outChannels}}}}}}return e.makeTensorInfo($.shape,$.dtype,_)}const iy={kernelName:th,backendName:"cpu",kernelFunc:Vu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cy(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,pad:c,dataFormat:i,dimRoundingMode:l,filterShape:u}=a;X([n,o],"conv2dBackpropFilter");const d=ua(i),p=rn(n.shape,u,r,1,c,l,!1,d),{strideHeight:h,strideWidth:f,filterHeight:x,filterWidth:m}=p,g=p.dataFormat==="channelsLast",C=new ke(p.filterShape,"float32"),b=p.padInfo.left,$=p.padInfo.top,I=e.data.get(n.dataId).values,v=e.data.get(o.dataId).values,y=new ke(n.shape,n.dtype,I),w=new ke(o.shape,o.dtype,v);for(let k=0;k<x;++k){const S=Math.max(0,Math.ceil(($-k)/h)),E=Math.min(p.outHeight,(p.inHeight+$-k)/h);for(let O=0;O<m;++O){const F=Math.max(0,Math.ceil((b-O)/f)),D=Math.min(p.outWidth,(p.inWidth+b-O)/f);for(let N=0;N<p.inChannels;++N)for(let T=0;T<p.outChannels;++T){let _=0;for(let R=0;R<p.batchSize;++R)for(let P=S;P<E;++P){const L=k+P*h-$;for(let M=F;M<D;++M){const W=O+M*f-b;g?_+=y.get(R,L,W,N)*w.get(R,P,M,T):_+=y.get(R,N,L,W)*w.get(R,T,P,M)}}C.set(_,k,O,N,T)}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const ly={kernelName:nh,backendName:"cpu",kernelFunc:cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uy(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{inputShape:r,strides:c,pad:i,dataFormat:l,dimRoundingMode:u}=a;X([n,o],"conv2dBackpropInput");const d=J(o.shape),p=J(n.shape);let h=ua(l);const f=rn(r,o.shape,c,1,i,u,!1,h),x=new ke(f.inShape,"float32"),m=x.values,g=e.data.get(n.dataId).values,C=e.data.get(o.dataId).values,[b,$,I]=d,{batchSize:v,filterHeight:y,filterWidth:w,inChannels:k,inHeight:S,inWidth:E,outChannels:O,outHeight:F,outWidth:D,strideHeight:N,strideWidth:T}=f;h=f.dataFormat;const _=y-1-f.padInfo.top,R=w-1-f.padInfo.left,P=h==="channelsLast",L=x.strides[0],M=P?x.strides[1]:x.strides[2],W=P?x.strides[2]:1,V=P?1:x.strides[1],z=p[0],B=P?p[1]:p[2],G=P?p[2]:1,j=P?1:p[1];for(let Q=0;Q<v;++Q)for(let Z=0;Z<k;++Z)for(let ee=0;ee<S;++ee){const te=ee-_,oe=Math.max(0,Math.ceil(te/N)),ue=Math.min(F,(y+te)/N);for(let he=0;he<E;++he){const fe=he-R,ce=Math.max(0,Math.ceil(fe/T)),me=Math.min(D,(w+fe)/T);let ge=0;for(let be=oe;be<ue;++be){const mt=be*N-te;for(let We=ce;We<me;++We){const Ft=We*T-fe,Ye=z*Q+B*be+G*We,lt=b*(y-1-mt)+$*(w-1-Ft)+I*Z;for(let gt=0;gt<O;++gt){const xt=g[Ye+j*gt],Ct=C[lt+gt];ge+=xt*Ct}}}const ct=L*Q+M*ee+W*he+V*Z;m[ct]=ge}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const dy={kernelName:sh,backendName:"cpu",kernelFunc:uy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dilations:i}=a;X([n,o],"conv3d");const l=da(n.shape,o.shape,r,i,c),{filterDepth:u,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:x,padInfo:m}=l,g=m.front,C=m.left,b=m.top,$=new ke(l.outShape,n.dtype),I=e.data.get(n.dataId).values,v=e.data.get(o.dataId).values,y=$.values,w=J(n.shape),k=J(o.shape);for(let S=0;S<l.batchSize;++S){const E=S*w[0],O=S*$.strides[0];for(let F=0;F<l.outDepth;++F){const D=O+F*$.strides[1],N=F*l.strideDepth-g;for(let T=0;T<u;++T){const _=N+T*h;if(_<0||_>=l.inDepth)continue;const R=T*k[0],P=E+_*w[1];for(let L=0;L<l.outHeight;++L){const M=D+L*$.strides[2],W=L*l.strideHeight-b;for(let V=0;V<d;++V){const z=W+V*f;if(z<0||z>=l.inHeight)continue;const B=R+V*k[1],G=P+z*w[2];for(let j=0;j<l.outWidth;++j){const Q=M+j*l.outChannels,Z=j*l.strideWidth-C;for(let ee=0;ee<p;++ee){const te=Z+ee*x;if(te<0||te>=l.inWidth)continue;const oe=B+ee*k[2],ue=G+te*l.inChannels;let he=oe;for(let fe=0;fe<l.inChannels;++fe){const ce=I[ue+fe];for(let me=0;me<l.outChannels;++me)y[Q+me]+=ce*v[he+me];he+=l.outChannels}}}}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const hy={kernelName:ah,backendName:"cpu",kernelFunc:py};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fy(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,pad:c,filterShape:i}=a;X([n,o],"conv3dBackpropFilterV2");const l=J(n.shape),u=J(o.shape),d=da(n.shape,i,r,1,c),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,x=d.filterDepth,m=d.filterHeight,g=d.filterWidth,C=new ke(d.filterShape,"float32"),b=C.values,[$,I,v,y]=C.strides,w=e.data.get(o.dataId).values,[k,S,E,O]=u,F=e.data.get(n.dataId).values,[D,N,T,_]=l,R=d.padInfo.front,P=d.padInfo.left,L=d.padInfo.top;for(let M=0;M<x;++M){const W=Math.max(0,Math.ceil((R-M)/p)),V=Math.min(d.outDepth,(d.inDepth+R-M)/p),z=M*$;for(let B=0;B<m;++B){const G=Math.max(0,Math.ceil((L-B)/h)),j=Math.min(d.outHeight,(d.inHeight+L-B)/h),Q=B*I+z;for(let Z=0;Z<g;++Z){const ee=Math.max(0,Math.ceil((P-Z)/f)),te=Math.min(d.outWidth,(d.inWidth+P-Z)/f),oe=Z*v+Q;for(let ue=0;ue<d.inChannels;++ue){const he=ue*y+oe;for(let fe=0;fe<d.outChannels;++fe){let ce=0;for(let me=0;me<d.batchSize;++me){const ge=me*D,ct=me*k;for(let be=W;be<V;++be){const We=(M+be*p-R)*N+ge,Ft=be*S+ct;for(let Ye=G;Ye<j;++Ye){const gt=(B+Ye*h-L)*T+We,xt=Ye*E+Ft;for(let Ct=ee;Ct<te;++Ct){const As=(Z+Ct*f-P)*_+gt,Ps=Ct*O+xt;ce+=F[As+ue]*w[Ps+fe]}}}}b[he+fe]=ce}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const my={kernelName:oh,backendName:"cpu",kernelFunc:fy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gy(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{pad:r,strides:c,inputShape:i}=a;X([n],"conv3dBackpropInputV2");const l=J(n.shape),u=J(o.shape),d=da(i,o.shape,c,1,r),p=new ke(d.inShape,"float32"),h=p.values,[f,x,m,g]=p.strides,C=e.data.get(n.dataId).values,[b,$,I,v]=l,y=e.data.get(o.dataId).values,[w,k,S,E]=u,{batchSize:O,filterDepth:F,filterHeight:D,filterWidth:N,inChannels:T,inDepth:_,inHeight:R,inWidth:P,outChannels:L,outDepth:M,outHeight:W,outWidth:V,strideDepth:z,strideHeight:B,strideWidth:G}=d,j=F-1-d.padInfo.front,Q=D-1-d.padInfo.top,Z=N-1-d.padInfo.left;for(let ee=0;ee<O;++ee)for(let te=0;te<T;++te)for(let oe=0;oe<_;++oe){const ue=oe-j,he=Math.max(0,Math.ceil(ue/z)),fe=Math.min(M,(F+ue)/z);for(let ce=0;ce<R;++ce){const me=ce-Q,ge=Math.max(0,Math.ceil(me/B)),ct=Math.min(W,(D+me)/B);for(let be=0;be<P;++be){const mt=be-Z,We=Math.max(0,Math.ceil(mt/G)),Ft=Math.min(V,(N+mt)/G);let Ye=0;for(let lt=he;lt<fe;++lt){const gt=lt*z-ue;for(let xt=ge;xt<ct;++xt){const Ct=xt*B-me;for(let Cn=We;Cn<Ft;++Cn){const As=Cn*G-mt,Ps=b*ee+$*lt+I*xt+v*Cn,Vd=w*(F-1-gt)+k*(D-1-Ct)+S*(N-1-As)+E*te;for(let Gn=0;Gn<L;++Gn){const Bd=C[Ps+Gn],Wd=y[Vd+Gn];Ye+=Bd*Wd}}}}h[f*ee+x*oe+m*ce+g*be+te]=Ye}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const xy={kernelName:rh,backendName:"cpu",kernelFunc:gy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cy=ie(dr,s=>Math.cos(s)),$y={kernelName:dr,backendName:"cpu",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const by=ie(pr,s=>Math.cosh(s)),Iy={kernelName:pr,backendName:"cpu",kernelFunc:by};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vy(s){const{inputs:t,backend:e,attrs:a}=s,{image:n,boxes:o,boxInd:r}=t,{cropSize:c,method:i,extrapolationValue:l}=a,[u,d,p,h]=n.shape,f=o.shape[0],[x,m]=c,g=le([f,x,m,h],"float32"),C=e.data.get(o.dataId).values,b=e.data.get(r.dataId).values,$=e.data.get(n.dataId).values,I=J(n.shape),v=J(g.shape);for(let y=0;y<f;y++){const w=y*4,k=C[w],S=C[w+1],E=C[w+2],O=C[w+3],F=b[y];if(F>=u)continue;const D=x>1?(E-k)*(d-1)/(x-1):0,N=m>1?(O-S)*(p-1)/(m-1):0;for(let T=0;T<x;T++){const _=x>1?k*(d-1)+T*D:.5*(k+E)*(d-1);if(_<0||_>d-1){for(let R=0;R<m;R++)for(let P=0;P<h;P++){const L=P+R*v[2]+T*v[1]+y*v[0];g.values[L]=l}continue}if(i==="bilinear"){const R=Math.floor(_),P=Math.ceil(_),L=_-R;for(let M=0;M<m;M++){const W=m>1?S*(p-1)+M*N:.5*(S+O)*(p-1);if(W<0||W>p-1){for(let G=0;G<h;G++){const j=G+M*v[2]+T*v[1]+y*v[0];g.values[j]=l}continue}const V=Math.floor(W),z=Math.ceil(W),B=W-V;for(let G=0;G<h;G++){let j=G+V*I[2]+R*I[1]+F*I[0];const Q=$[j];j=G+z*I[2]+R*I[1]+F*I[0];const Z=$[j];j=G+V*I[2]+P*I[1]+F*I[0];const ee=$[j];j=G+z*I[2]+P*I[1]+F*I[0];const te=$[j],oe=Q+(Z-Q)*B,ue=ee+(te-ee)*B;j=G+M*v[2]+T*v[1]+y*v[0],g.values[j]=oe+(ue-oe)*L}}}else for(let R=0;R<m;++R){const P=m>1?S*(p-1)+R*N:.5*(S+O)*(p-1);if(P<0||P>p-1){for(let W=0;W<h;W++){const V=W+R*v[2]+T*v[1]+y*v[0];g.values[V]=l}continue}const L=Math.round(P),M=Math.round(_);for(let W=0;W<h;W++){const V=W+L*I[2]+M*I[1]+F*I[0],z=W+R*v[2]+T*v[1]+y*v[0];g.values[z]=$[V]}}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const yy={kernelName:ih,backendName:"cpu",kernelFunc:vy};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wy(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,exclusive:r,reverse:c}=a;X(n,"cumprod");const i=ot([o],n.shape.length);let l=n;i!=null&&(l=De({inputs:{x:n},backend:e,attrs:{perm:i}}));const u=rt(1,n.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const d=Fn(l.dtype,"int32"),p=lh(H(l.shape),d),h=e.data.get(l.dataId).values,f=l.shape[l.shape.length-1],x=c?(g,C)=>g+f-C-1:(g,C)=>g+C;for(let g=0;g<h.length;g+=f)for(let C=0;C<f;C++){const b=x(g,C);if(C===0)p[b]=r?1:h[b];else{const $=x(g,C-1);p[b]=r?h[$]*p[$]:h[b]*p[$]}}const m=e.makeTensorInfo(l.shape,d,p);if(i!=null){const g=hr(i),C=De({inputs:{x:m},backend:e,attrs:{perm:g}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(l),C}return m}const Sy={kernelName:ch,backendName:"cpu",kernelFunc:wy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ky(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,exclusive:r,reverse:c}=a;X(n,"cumsum");const i=ot([o],n.shape.length);let l=n;i!=null&&(l=De({inputs:{x:n},backend:e,attrs:{perm:i}}));const u=rt(1,n.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const d=Fn(l.dtype,"int32"),p=Le(H(l.shape),d),h=e.data.get(l.dataId).values,f=l.shape[l.shape.length-1],x=c?(g,C)=>g+f-C-1:(g,C)=>g+C;for(let g=0;g<h.length;g+=f)for(let C=0;C<f;C++){const b=x(g,C);if(C===0)p[b]=r?0:h[b];else{const $=x(g,C-1);p[b]=r?h[$]+p[$]:h[b]+p[$]}}const m=e.makeTensorInfo(l.shape,d,p);if(i!=null){const g=hr(i),C=De({inputs:{x:m},backend:e,attrs:{perm:g}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(l),C}return m}const Ry={kernelName:uh,backendName:"cpu",kernelFunc:ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,weights:o}=t,{size:r,binaryOutput:c}=a;if(n.shape.length===1){const i=e.data.get(n.dataId).values,l=e.data.get(o.dataId).values,u=yu(i,l,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,u)}else if(n.shape.length===2){const i=e.bufferSync(n),l=e.bufferSync(o),u=Sb(i,l,r,c);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}const Ty={kernelName:dh,backendName:"cpu",kernelFunc:Ny};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ey(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockSize:o,dataFormat:r}=a;we(r==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`);const c=n.shape[0],i=n.shape[1],l=n.shape[2],u=n.shape[3],d=i*o,p=l*o,h=u/(o*o),f=e.data.get(n.dataId).values,x=new Float32Array(c*d*p*h);let m=0;for(let g=0;g<c;++g)for(let C=0;C<d;++C){const b=Math.floor(C/o),$=C%o;for(let I=0;I<p;++I){const v=Math.floor(I/o),y=I%o,w=($*o+y)*h;for(let k=0;k<h;++k){const E=k+w+u*(v+l*(b+i*g));x[m++]=f[E]}}}return e.makeTensorInfo([c,d,p,h],n.dtype,x)}const Fy={kernelName:ph,backendName:"cpu",kernelFunc:Ey};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bu(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dilations:i,dimRoundingMode:l}=a;X([n,o],"depthwiseConv2DNative");const u=J(n.shape),d=J(o.shape);let p=i;p==null&&(p=[1,1]),we(ca(r,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${p}'`);const h=rn(n.shape,o.shape,r,p,c,l,!0),{filterHeight:f,filterWidth:x,dilationHeight:m,dilationWidth:g,padInfo:C}=h,b=C.left,$=C.top,I=h.outChannels/h.inChannels,v=new ke(h.outShape,n.dtype),y=e.data.get(n.dataId).values,w=e.data.get(o.dataId).values,k=v.values;for(let S=0;S<h.batchSize;++S){const E=S*u[0],O=S*v.strides[0];for(let F=0;F<h.outHeight;++F){const D=O+F*v.strides[1],N=F*h.strideHeight-$;for(let T=0;T<f;++T){const _=N+T*m;if(_<0||_>=h.inHeight)continue;const R=T*d[0],P=E+_*u[1];for(let L=0;L<h.outWidth;++L){const M=D+L*v.strides[2],W=L*h.strideWidth-b;for(let V=0;V<x;++V){const z=W+V*g;if(z<0||z>=h.inWidth)continue;const B=R+V*d[1],G=P+z*h.inChannels;let j=M,Q=B;for(let Z=0;Z<h.inChannels;++Z){const ee=y[G+Z];for(let te=0;te<I;++te)k[j+te]+=ee*w[Q+te];j+=I,Q+=I}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const Dy={kernelName:hh,backendName:"cpu",kernelFunc:Bu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oy(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,dilations:c,pad:i,dimRoundingMode:l,filterShape:u}=a;X([n,o],"depthwiseConv2dNativeBackpropFilter");const d=rn(n.shape,u,r,c,i,l,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:x}=d,m=new ke(d.filterShape,"float32"),g=d.padInfo.left,C=d.padInfo.top,b=d.outChannels/d.inChannels,$=e.data.get(n.dataId).values,I=new ke(n.shape,n.dtype,$),v=e.data.get(o.dataId).values,y=new ke(o.shape,o.dtype,v);for(let w=0;w<f;++w){const k=Math.max(0,Math.ceil((C-w)/p)),S=Math.min(d.outHeight,(d.inHeight+C-w)/p);for(let E=0;E<x;++E){const O=Math.max(0,Math.ceil((g-E)/h)),F=Math.min(d.outWidth,(d.inWidth+g-E)/h);for(let D=0;D<d.outChannels;++D){const N=Math.trunc(D/b),T=D%b;let _=0;for(let R=0;R<d.batchSize;++R)for(let P=k;P<S;++P){const L=w+P*p-C;for(let M=O;M<F;++M){const W=E+M*h-g;_+=I.get(R,L,W,N)*y.get(R,P,M,D)}}m.set(_,w,E,N,T)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const Ay={kernelName:fh,backendName:"cpu",kernelFunc:Oy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{strides:r,dilations:c,pad:i,dimRoundingMode:l,inputShape:u}=a;X([n,o],"depthwiseConv2DNativeBackpropInput");const d=J(n.shape),p=J(o.shape),h=rn(u,o.shape,r,c,i,l,!0),f=new ke(h.inShape,"float32"),x=f.values,[m,g,C]=f.strides,b=e.data.get(n.dataId).values,[$,I,v]=d,y=e.data.get(o.dataId).values,[w,k,S]=p,{batchSize:E,filterHeight:O,filterWidth:F,inChannels:D,inHeight:N,inWidth:T,outChannels:_,outHeight:R,outWidth:P,strideHeight:L,strideWidth:M}=h,W=O-1-h.padInfo.top,V=F-1-h.padInfo.left,z=_/D;for(let B=0;B<E;++B)for(let G=0;G<D;++G)for(let j=0;j<N;++j){const Q=j-W,Z=Math.max(0,Math.ceil(Q/L)),ee=Math.min(R,(O+Q)/L);for(let te=0;te<T;++te){const oe=te-V,ue=Math.max(0,Math.ceil(oe/M)),he=Math.min(P,(F+oe)/M);let fe=0;for(let ce=Z;ce<ee;++ce){const me=ce*L-Q;for(let ge=ue;ge<he;++ge){const ct=ge*M-oe,be=$*B+I*ce+v*ge,mt=w*(O-1-me)+k*(F-1-ct)+S*G;for(let We=0;We<z;++We){const Ft=G*z+We,Ye=b[be+Ft],lt=y[mt+We];fe+=Ye*lt}}}x[m*B+g*j+C*te+G]=fe}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}const _y={kernelName:mh,backendName:"cpu",kernelFunc:Py};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function My(s){const{inputs:t,backend:e}=s,{x:a}=t,n=H(a.shape),o=e.data.get(a.dataId).values,r=le([n,n],a.dtype),c=r.values;for(let l=0;l<o.length;l++)c[l*n+l]=o[l];const i=[...a.shape,...a.shape];return e.makeTensorInfo(i,r.dtype,r.values)}const Ly={kernelName:gh,backendName:"cpu",kernelFunc:My};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vy={kernelName:xh,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:a,filter:n}=s,{strides:o,pad:r,dilations:c}=e,i=t,l=i.data.get(a.dataId).values,u=a.shape.length,d=i.data.get(n.dataId).values,p=n.shape.length,{batchSize:h,inHeight:f,inWidth:x,inChannels:m,outHeight:g,outWidth:C,padInfo:b,strideHeight:$,strideWidth:I,filterHeight:v,filterWidth:y,dilationHeight:w,dilationWidth:k,outShape:S}=pa(a.shape,n.shape,o,r,"NHWC",c),E=H(S),O=S.length,F=ye(a.dtype,E);for(let N=0;N<h;++N)for(let T=0;T<g;++T){const _=T*$-b.top;for(let R=0;R<C;++R){const P=R*I-b.left;for(let L=0;L<m;++L){let M=Number.MIN_SAFE_INTEGER;for(let V=0;V<v;++V){const z=_+V*w;if(z>=0&&z<f)for(let B=0;B<y;++B){const G=P+B*k;if(G>=0&&G<x){const j=st([N,z,G,L],u,J(a.shape)),Q=st([V,B,L],p,J(n.shape)),Z=l[j]+d[Q];Z>M&&(M=Z)}}}const W=st([N,T,R,L],O,J(S));F[W]=M}}}return{dataId:i.write(ms(F,a.dtype),S,a.dtype),shape:S,dtype:a.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const By={kernelName:La,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:a,filter:n,dy:o}=s,{strides:r,pad:c,dilations:i}=e,l=t,u=Yt(a.shape,l.data.get(a.dataId).values),d=Yt(n.shape,l.data.get(n.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:x,outHeight:m,outWidth:g,padInfo:C,strideHeight:b,strideWidth:$,filterHeight:I,filterWidth:v,dilationHeight:y,dilationWidth:w,outShape:k}=pa(a.shape,n.shape,r,c,"NHWC",i);we(o.rank===k.length,()=>`Error in ${La}, dy must have the same rank as output ${k.length}, but got ${o.rank}`);const S=Yt(k,l.data.get(o.dataId).values),E=fr(n.shape,n.dtype);for(let F=0;F<p;++F)for(let D=0;D<m;++D){const N=D*b-C.top;for(let T=0;T<g;++T){const _=T*$-C.left;for(let R=0;R<x;++R){let P=Number.MIN_SAFE_INTEGER,L=0,M=0;for(let W=0;W<I;++W){const V=N+W*y;if(V>=0&&V<h)for(let z=0;z<v;++z){const B=_+z*w;if(B>=0&&B<f){const G=u[F][V][B][R]+d[W][z][R];G>P&&(P=G,L=W,M=z)}}}E[L][M][R]+=S[F][D][T][R]}}}return{dataId:l.write(ms(E,a.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wy={kernelName:Va,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:a,filter:n,dy:o}=s,{strides:r,pad:c,dilations:i}=e,l=t,u=Yt(a.shape,l.data.get(a.dataId).values),d=Yt(n.shape,l.data.get(n.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:x,outHeight:m,outWidth:g,padInfo:C,strideHeight:b,strideWidth:$,filterHeight:I,filterWidth:v,dilationHeight:y,dilationWidth:w,outShape:k}=pa(a.shape,n.shape,r,c,"NHWC",i);we(o.rank===k.length,()=>`Error in ${Va}, dy must have the same rank as output ${k.length}, but got ${o.rank}`);const S=Yt(k,l.data.get(o.dataId).values),E=fr(a.shape,a.dtype);for(let F=0;F<p;++F)for(let D=0;D<m;++D){const N=D*b-C.top;for(let T=0;T<g;++T){const _=T*$-C.left;for(let R=0;R<x;++R){let P=Number.MIN_SAFE_INTEGER,L=N<0?0:N,M=_<0?0:_;for(let W=0;W<I;++W){const V=N+W*y;if(V>=0&&V<h)for(let z=0;z<v;++z){const B=_+z*w;if(B>=0&&B<f){const G=u[F][V][B][R]+d[W][z][R];G>P&&(P=G,L=V,M=B)}}}E[F][L][M][R]+=S[F][D][T][R]}}}return{dataId:l.write(ms(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _n(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;X(n,"sum");let c;n.dtype==="bool"?c=wt({inputs:{x:n},backend:e,attrs:{dtype:"int32"}}):c=at({inputs:{x:n},backend:e});const i=c.shape.length,l=Oe(o,c.shape),u=ot(l,i);let d=l,p=c;u!=null&&(p=De({inputs:{x:c},backend:e,attrs:{perm:u}}),d=rt(d.length,i)),zt("sum",d,p.shape.length);const[h,f]=pt(p.shape,d),x=Fn(p.dtype,"int32");let m=as(e,h,x);const g=H(f),C=e.data.get(m.dataId).values,b=e.data.get(p.dataId).values;for(let $=0;$<C.length;++$){const I=$*g;let v=0;for(let y=0;y<g;++y)v+=b[I+y];C[$]=v}if(r){const $=Wt(m.shape,l),I=m;m=de({inputs:{x:m},backend:e,attrs:{shape:$}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(c),u!=null&&e.disposeIntermediateTensorInfo(p),m}const zy={kernelName:Ch,backendName:"cpu",kernelFunc:_n};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uy(s){const{inputs:t,backend:e,attrs:a}=s,{equation:n}=a,o=t,{allDims:r,summedDims:c,idDims:i}=bh(n,o.length);Ih(r.length,i,o);const{path:l,steps:u}=vh(c,i),d=u.length;let p=null,h=r.length;const f=[];for(let x=0;x<d;++x){for(const m of u[x]){const{permutationIndices:g,expandDims:C}=yh(h,i[m]);let b;wh(g)?b=o[m]:(b=De({inputs:{x:o[m]},backend:e,attrs:{perm:g}}),f.push(b));const $=b.shape.slice();for(let I=0;I<C.length;++I)$.splice(C[I],0,1);la(b.shape,$)||(b=de({inputs:{x:b},backend:e,attrs:{shape:$}}),f.push(b)),p===null?p=b:(p=Ns({inputs:{a:b,b:p},backend:e}),f.push(p))}x<d-1&&(l[x]>=0&&(p=_n({inputs:{x:p},backend:e,attrs:{axis:l[x]-(r.length-h),keepDims:!1}}),f.push(p)),h--)}for(const x of f)x!==p&&e.disposeIntermediateTensorInfo(x);return p}const Gy={kernelName:$h,backendName:"cpu",kernelFunc:Uy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(s){const{inputs:t,backend:e}=s,{dy:a,y:n}=t;X([a,n],"eluGrad");const o=new Float32Array(H(n.shape)),r=e.data.get(n.dataId).values,c=e.data.get(a.dataId).values;for(let i=0;i<r.length;++i){const l=r[i];l>=1?o[i]=c[i]:o[i]=c[i]*(l+1)}return e.makeTensorInfo(n.shape,"float32",o)}const Xy={kernelName:Sh,backendName:"cpu",kernelFunc:Hy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qy=Fh,jy=kh,Ky=Rh,Yy=Nh,Qy=Th,Zy=Eh,Jy=ie(mr,s=>{const t=Math.sign(s),e=Math.abs(s),a=1/(1+qy*e);return t*(1-((((Zy*a+Qy)*a+Yy)*a+Ky)*a+jy)*a*Math.exp(-e*e))}),ew={kernelName:mr,backendName:"cpu",kernelFunc:Jy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(s){const{inputs:t,backend:e,attrs:a}=s,{input:n}=t,{dim:o}=a,r=n.shape.length,c=n.shape.slice();let i=o;return o<0&&(we(-(r+1)<=o,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),i=r+o+1),c.splice(i,0,1),de({inputs:{x:n},backend:e,attrs:{shape:c}})}const tw={kernelName:Dh,backendName:"cpu",kernelFunc:is};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nw=Ce((s,t)=>s/t),Sa=$e(gr,nw),ta={kernelName:gr,backendName:"cpu",kernelFunc:Sa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(s,t,e){const a=s.shape,n=a[0],o=a[1],r=e.data.get(s.dataId),c=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,l=[n,o],u=H(l),d=Re("float32",u),p=Re("float32",u);for(let m=0;m<n;m++){const g=Bt({inputs:{x:c},backend:e,attrs:{begin:[m,0],size:[1,o]}}),C=Bt({inputs:{x:i},backend:e,attrs:{begin:[m,0],size:[1,o]}}),b=Pe({inputs:{real:g,imag:C},backend:e}),{real:$,imag:I}=sw(b,t,e),v=Qt($,I);for(let y=0;y<o;y++){const w=xr(v,y);d[m*o+y]=w.real,p[m*o+y]=w.imag}e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(b)}const h=e.makeTensorInfo(l,"float32",d),f=e.makeTensorInfo(l,"float32",p),x=Pe({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),x}function sw(s,t,e){const a=H(s.shape),n=e.data.get(s.dataId),o=e.data.get(n.complexTensorInfos.real.dataId).values,r=e.data.get(n.complexTensorInfos.imag.dataId).values;if(aw(a)){const c=na(o,r,a,t,e),i=[s.shape[0],s.shape[1]];if(t){const l=e.makeTensorInfo(i,"float32",c.real),u=e.makeTensorInfo(i,"float32",c.imag),d=e.makeTensorInfo([],"float32",ia(a,"float32")),p=at({inputs:{x:d},backend:e}),h=ta.kernelFunc({inputs:{a:l,b:d},backend:e}),f=ta.kernelFunc({inputs:{a:u,b:p},backend:e}),x=e.data.get(h.dataId).values,m=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),{real:x,imag:m}}return c}else{const c=Qt(o,r),i=ow(c,a,t);return Oh(i)}}function aw(s){return(s&s-1)===0}function na(s,t,e,a,n){if(e===1)return{real:s,imag:t};const o=Qt(s,t),r=e/2,c=Ah(o),i=c.real,l=c.imag,u=[i.length],d=n.makeTensorInfo(u,"float32",i),p=n.makeTensorInfo(u,"float32",l),h=Pe({inputs:{real:d,imag:p},backend:n}),f=Ph(o),x=f.real,m=f.imag,g=[x.length],C=n.makeTensorInfo(g,"float32",x),b=n.makeTensorInfo(g,"float32",m),$=Pe({inputs:{real:C,imag:b},backend:n}),I=na(i,l,r,a,n),v=I.real,y=I.imag,w=[v.length],k=n.makeTensorInfo(w,"float32",v),S=n.makeTensorInfo(w,"float32",y),E=Pe({inputs:{real:k,imag:S},backend:n}),O=na(x,m,r,a,n),F=O.real,D=O.imag,N=[F.length],T=n.makeTensorInfo(N,"float32",F),_=n.makeTensorInfo(N,"float32",D),R=Pe({inputs:{real:T,imag:_},backend:n}),P=_h(e,a),L=[P.real.length],M=n.makeTensorInfo(L,"float32",P.real),W=n.makeTensorInfo(L,"float32",P.imag),V=Pe({inputs:{real:M,imag:W},backend:n}),z=Ns({inputs:{a:V,b:R},backend:n}),B=Jt({inputs:{a:E,b:z},backend:n}),G=ya({inputs:{a:E,b:z},backend:n}),j=Vt({inputs:{input:B},backend:n}),Q=Vt({inputs:{input:G},backend:n}),Z=en({inputs:{input:B},backend:n}),ee=en({inputs:{input:G},backend:n}),te=tn({inputs:[j,Q],backend:n,attrs:{axis:0}}),oe=tn({inputs:[Z,ee],backend:n,attrs:{axis:0}}),ue=n.data.get(te.dataId).values,he=n.data.get(oe.dataId).values;return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo($),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(M),n.disposeIntermediateTensorInfo(W),n.disposeIntermediateTensorInfo(V),n.disposeIntermediateTensorInfo(z),n.disposeIntermediateTensorInfo(B),n.disposeIntermediateTensorInfo(G),n.disposeIntermediateTensorInfo(j),n.disposeIntermediateTensorInfo(Z),n.disposeIntermediateTensorInfo(Q),n.disposeIntermediateTensorInfo(ee),n.disposeIntermediateTensorInfo(te),n.disposeIntermediateTensorInfo(oe),{real:ue,imag:he}}function ow(s,t,e){const a=new Float32Array(t*2);for(let n=0;n<t;n++){let o=0,r=0;for(let c=0;c<t;c++){const i=Lh(n*c,t,e),l=xr(s,c);o+=l.real*i.real-l.imag*i.imag,r+=l.real*i.imag+l.imag*i.real}e&&(o/=t,r/=t),Mh(a,o,r,n)}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rw(s){const{inputs:t,backend:e}=s,{input:a}=t,n=H(a.shape),o=a.shape[a.shape.length-1],r=n/o,c=de({inputs:{x:a},backend:e,attrs:{shape:[r,o]}}),i=Wu(c,!1,e),l=de({inputs:{x:i},backend:e,attrs:{shape:a.shape}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(i),l}const iw={kernelName:Vh,backendName:"cpu",kernelFunc:rw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(s){const{backend:t,attrs:e}=s,{shape:a,value:n,dtype:o}=e,r=o||Wh(n),c=ye(r,H(a));return lw(c,n,r),t.makeTensorInfo(a,r,c)}const cw={kernelName:Bh,backendName:"cpu",kernelFunc:ka};function lw(s,t,e){s.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uw={kernelName:zh,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:a}=s,n=e,o=Re(a.dtype,H(a.shape)),[r,c,i,l]=a.shape,u=n.data.get(a.dataId).values;for(let p=0;p<r;p++){const h=p*i*c*l;for(let f=0;f<c;f++){const x=f*(i*l);for(let m=0;m<i;m++){const g=m*l;for(let C=0;C<l;C++){const b=Math.round(i-m-1),$=h+x+g+C;let I=u[$];if(b>=0&&b<i){const v=b*l,y=h+x+v+C;I=u[y]}o[$]=I}}}}return{dataId:n.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dw=Ce((s,t)=>Math.floor(s/t)),pw=$e(Cr,dw,null,"int32"),hw={kernelName:Cr,backendName:"cpu",kernelFunc:pw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o,bias:r,preluActivationWeights:c}=t,{strides:i,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a;let x=Vu({inputs:{x:n,filter:o},backend:e,attrs:{strides:i,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}});if(r){const m=x;if(u==="NCHW"&&r.shape.length===1&&r.shape[0]!==1){const g=de({inputs:{x:r},backend:e,attrs:{shape:[r.shape[0],1,1]}});x=Jt({inputs:{a:x,b:g},backend:e}),e.disposeIntermediateTensorInfo(g)}else x=Jt({inputs:{a:x,b:r},backend:e});e.disposeIntermediateTensorInfo(m)}if(h){const m=x;if(u==="NCHW"&&h==="prelu"&&c.shape.length===1&&c.shape[0]!==1){const g=de({inputs:{x:c},backend:e,attrs:{shape:[c.shape[0],1,1]}});x=rs(e,x,h,g,f),e.disposeIntermediateTensorInfo(g)}else x=rs(e,x,h,c,f);e.disposeIntermediateTensorInfo(m)}return x}const mw={kernelName:Uh,backendName:"cpu",kernelFunc:fw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o,bias:r,preluActivationWeights:c}=t,{strides:i,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a;let x=Bu({inputs:{x:n,filter:o},backend:e,attrs:{strides:i,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}});if(r){const m=x;x=Jt({inputs:{a:x,b:r},backend:e}),e.disposeIntermediateTensorInfo(m)}if(h){const m=x;x=rs(e,x,h,c,f),e.disposeIntermediateTensorInfo(m)}return x}const xw={kernelName:Gh,backendName:"cpu",kernelFunc:gw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(s){const{inputs:t,backend:e}=s,{params:a,indices:n}=t,o=H(a.shape),r=n.shape,c=r[r.length-1],[i,l,u,d]=Xh(a,n);if(l===0)return e.makeTensorInfo(i,a.dtype,[]);const p=e.data.get(n.dataId).values,h=e.bufferSync(a),f=Bb(p,h,a.dtype,l,c,u,d,a.shape,o);return e.makeTensorInfo(i,a.dtype,f.values)}const $w={kernelName:Hh,backendName:"cpu",kernelFunc:Cw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,indices:o}=t,{axis:r,batchDims:c}=a;X([n,o],"gatherV2");const i=Oe(r,n.shape)[0],l=e.data.get(o.dataId).values,u=n.shape[i];for(let $=0;$<l.length;++$){const I=l[$];we(I<=u-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${u-1}]`)}let d=c;c==null&&(d=0);const p=H(o.shape),h=jh(n,o,i,d),f=de({inputs:{x:n},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),x=de({inputs:{x:o},backend:e,attrs:{shape:[h.batchSize,p/h.batchSize]}}),m=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],g=e.bufferSync(x),C=e.bufferSync(f),b=Wb(C,g,m);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(x),e.makeTensorInfo(h.outputShape,b.dtype,b.values)}const Iw={kernelName:qh,backendName:"cpu",kernelFunc:bw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vw(s){const{inputs:t,backend:e}=s,{input:a}=t,n=H(a.shape),o=a.shape[a.shape.length-1],r=n/o,c=de({inputs:{x:a},backend:e,attrs:{shape:[r,o]}}),i=Wu(c,!0,e),l=de({inputs:{x:i},backend:e,attrs:{shape:a.shape}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(i),l}const yw={kernelName:Kh,backendName:"cpu",kernelFunc:vw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ww=ie($r,s=>Number.isFinite(s)?1:0,"bool"),Sw={kernelName:$r,backendName:"cpu",kernelFunc:ww};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kw=ie(br,s=>Math.abs(s)===1/0?1:0,"bool"),Rw={kernelName:br,backendName:"cpu",kernelFunc:kw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nw=ie(Ir,s=>Number.isNaN(s)?1:0,"bool"),Tw={kernelName:Ir,backendName:"cpu",kernelFunc:Nw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(s){const{backend:t,attrs:e}=s,{start:a,stop:n,num:o}=e,r=eI(a,n,o);return t.makeTensorInfo([r.length],"float32",r)}const Fw={kernelName:Yh,backendName:"cpu",kernelFunc:Ew};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dw=ie(vr,s=>Math.log1p(s)),Ow={kernelName:vr,backendName:"cpu",kernelFunc:Dw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aw=Ce((s,t)=>s&&t),Pw=$e(yr,Aw,null,"bool"),_w={kernelName:yr,backendName:"cpu",kernelFunc:Pw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mw=ie(wr,s=>s?0:1,"bool"),Lw={kernelName:wr,backendName:"cpu",kernelFunc:Mw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vw=Ce((s,t)=>s||t),Bw=$e(Sr,Vw,null,"bool"),Ww={kernelName:Sr,backendName:"cpu",kernelFunc:Bw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{depthRadius:o,bias:r,alpha:c,beta:i}=a;X(n,"LRN");const l=n.shape[3],u=l-1,d=e.data.get(n.dataId).values,p=H(n.shape),h=new Float32Array(p);function f(x){const m=x%l;let g=x-m+Math.max(0,m-o);const C=x-m+Math.min(m+o,u);let b=0;for(;g<=C;g++){const $=d[g];b+=$*$}return b}for(let x=0;x<p;x++){const m=f(x),g=d[x]*Math.pow(r+c*m,-i);h[x]=g}return e.makeTensorInfo(n.shape,n.dtype,h)}const Uw={kernelName:Qh,backendName:"cpu",kernelFunc:zw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,y:o,dy:r}=t,{depthRadius:c,bias:i,alpha:l,beta:u}=a;X(r,"LRNGrad");const d=H(r.shape),p=r.shape[3],h=e.data.get(r.dataId).values,f=e.data.get(n.dataId).values,x=e.data.get(o.dataId).values,m=new Float32Array(d),g=d;for(let C=0;C<g;C++){const b=C%p,$=C-b+Math.max(0,b-c),I=C-b+Math.min(p,b+c+1);let v=0;for(let y=$;y<I;y++)v+=Math.pow(f[y],2);v=l*v+i;for(let y=$;y<I;y++){let w=-2*l*u*f[y]*x[C]/v;C===y&&(w+=Math.pow(v,-u)),w*=h[C],m[y]+=w}}return e.makeTensorInfo(r.shape,n.dtype,m)}const Hw={kernelName:Zh,backendName:"cpu",kernelFunc:Gw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{reductionIndices:o,keepDims:r}=a,c=e;let i=n.shape;const l=i.length,u=Oe(o,i);let d=u;const p=ot(d,l);let h=c.data.get(n.dataId).values;if(p!=null){const $=new Array(l);for(let I=0;I<$.length;I++)$[I]=i[p[I]];h=Ru(h,i,n.dtype,p,$),d=rt(d.length,l),i=$}X(n,"max"),zt("max",d,l);const[f,x]=pt(i,d),m=H(x),g=aI(h,m,f,n.dtype),C=c.write(g,f,n.dtype);let b=f;return r&&(b=Wt(f,u)),{dataId:C,shape:b,dtype:n.dtype}}const Xw={kernelName:Jh,backendName:"cpu",kernelFunc:zu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t;X(n,"maxPool");const{filterSize:o,strides:r,pad:c,dimRoundingMode:i}=a,l=1;we(ca(r,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const u=Dn(n.shape,o,r,l,c,i);let d;if(u.filterWidth===1&&u.filterHeight===1&&la(u.inShape,u.outShape))d=at({inputs:{x:n},backend:e});else{const p=e.data.get(n.dataId).values,h=J(n.shape),f=wa(p,n.shape,n.dtype,h,u,"max");d=e.makeTensorInfo(u.outShape,n.dtype,f.values)}return d}const jw={kernelName:ef,backendName:"cpu",kernelFunc:qw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{filterSize:o,strides:r,pad:c,dimRoundingMode:i,dataFormat:l}=a;X(n,"maxPool3d");const u=gs(n.shape,o,r,1,c,i,l),d=e.data.get(n.dataId).values,p=Lu(d,n.shape,n.dtype,J(n.shape),u,"max");return e.makeTensorInfo(p.shape,"float32",p.values)}const Yw={kernelName:tf,backendName:"cpu",kernelFunc:Kw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,{filterSize:r,strides:c,pad:i,dimRoundingMode:l}=a;X([n,o],"maxPool3DGrad");const u=gs(o.shape,r,c,1,i,l),d=e.bufferSync(o),p=Lv(d,u),h=u.strideDepth,f=u.strideHeight,x=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,C=u.dilationWidth,b=u.effectiveFilterDepth,$=u.effectiveFilterHeight,I=u.effectiveFilterWidth,v=b-1-u.padInfo.front,y=I-1-u.padInfo.left,w=$-1-u.padInfo.top,k=le(o.shape,"float32"),S=e.bufferSync(n);for(let E=0;E<u.batchSize;++E)for(let O=0;O<u.inChannels;++O)for(let F=0;F<u.inDepth;++F)for(let D=0;D<u.inHeight;++D)for(let N=0;N<u.inWidth;++N){const T=F-v,_=D-w,R=N-y;let P=0;for(let L=0;L<b;L+=m){const M=(T+L)/h;if(!(M<0||M>=u.outDepth||Math.floor(M)!==M))for(let W=0;W<$;W+=g){const V=(_+W)/f;if(!(V<0||V>=u.outHeight||Math.floor(V)!==V))for(let z=0;z<I;z+=C){const B=(R+z)/x;if(B<0||B>=u.outWidth||Math.floor(B)!==B)continue;const G=b*$*I-1-p.get(E,M,V,B,O),j=L*$*I+W*I+z,Q=G===j?1:0;if(Q===0)continue;const Z=S.get(E,M,V,B,O);P+=Z*Q}}}k.set(P,E,F,D,N,O)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const Zw={kernelName:nf,backendName:"cpu",kernelFunc:Qw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o,output:r}=t,c=o;X([o,r],"maxPoolGrad");const{filterSize:i,strides:l,pad:u,dimRoundingMode:d}=a,p=Dn(c.shape,i,l,1,u,d),h=e.data.get(c.dataId).values,f=le(p.outShape,c.dtype,Mu(h,c.shape,c.dtype,p).values),x=p.strideHeight,m=p.strideWidth,g=p.dilationHeight,C=p.dilationWidth,b=p.effectiveFilterHeight,$=p.effectiveFilterWidth,I=$-1-p.padInfo.left,v=b-1-p.padInfo.top,y=le(c.shape,"float32"),w=e.data.get(n.dataId).values,k=le(n.shape,"float32",w);for(let S=0;S<p.batchSize;++S)for(let E=0;E<p.inChannels;++E)for(let O=0;O<p.inHeight;++O)for(let F=0;F<p.inWidth;++F){const D=O-v,N=F-I;let T=0;for(let _=0;_<b;_+=g){const R=(D+_)/x;if(!(R<0||R>=p.outHeight||Math.floor(R)!==R))for(let P=0;P<$;P+=C){const L=(N+P)/m;if(L<0||L>=p.outWidth||Math.floor(L)!==L)continue;const M=b*$-1-f.get(S,R,L,E),W=_*$+P,V=M===W?1:0;if(V===0)continue;const z=k.get(S,R,L,E);T+=z*V}}y.set(T,S,O,F,E)}return e.makeTensorInfo(y.shape,y.dtype,y.values)}const eS={kernelName:sf,backendName:"cpu",kernelFunc:Jw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(s,t,e,a,n){const o=J(t),r=wa(s,t,e,o,n,"max"),c=Mu(s,t,e,n,!0,a);return[r.values,c.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nS={kernelName:af,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:a}=s,{filterSize:n,strides:o,pad:r,includeBatchInIndex:c}=t,i=e;X(a,"MaxPoolWithArgmax");const l=i.data.get(a.dataId).values,u=Dn(a.shape,n,o,[1,1],r),[d,p]=tS(l,a.shape,a.dtype,c,u),h=i.write(d,u.outShape,a.dtype),f=i.write(p,u.outShape,a.dtype);return[{dataId:h,shape:u.outShape,dtype:a.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a,c=Oe(o,n.shape),l=pt(n.shape,c)[1],u=H(l),d=[],p=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(p);const h=wt({inputs:{x:n},backend:e,attrs:{dtype:"float32"}});d.push(h);const f=Sa({inputs:{a:h,b:p},backend:e});d.push(f);const x=_n({inputs:{x:f},backend:e,attrs:{axis:o,keepDims:r}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),x}const aS={kernelName:of,backendName:"cpu",kernelFunc:sS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;X(n,"min");const c=Oe(o,n.shape);let i=c;const l=ot(i,n.shape.length);let u=n;l!=null&&(u=De({inputs:{x:n},backend:e,attrs:{perm:l}}),i=rt(i.length,n.shape.length)),zt("min",i,u.shape.length);const[d,p]=pt(u.shape,i),h=H(p),f=Le(H(d),u.dtype),x=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const C=g*h;let b=x[C];for(let $=0;$<h;++$){const I=x[C+$];(Number.isNaN(I)||I<b)&&(b=I)}f[g]=b}l!=null&&e.disposeIntermediateTensorInfo(u);const m=e.makeTensorInfo(d,u.dtype,f);if(r){const g=Wt(d,c),C=de({inputs:{x:m},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(m),C}return m}const rS={kernelName:rf,backendName:"cpu",kernelFunc:oS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{paddings:o,mode:r}=a;X(n,"mirrorPad");const c=o.map((b,$)=>b[0]+n.shape[$]+b[1]),i=o.map(b=>b[0]),l=o.map((b,$)=>b[0]+n.shape[$]),u=r==="reflect"?0:1,d=e.data.get(n.dataId).values,p=n.shape.length,h=J(n.shape),f=H(c),x=c.length,m=J(c),g=Re(n.dtype,f);for(let b=0;b<f;b++){let $=on(b,x,m);for(let v=0;v<x;v++)$[v]<i[v]?$[v]=i[v]*2-$[v]-u:$[v]>=l[v]&&($[v]=(l[v]-1)*2-$[v]+u);$=$.map((v,y)=>v-i[y]);const I=st($,p,h);g[b]=d[I]}return{dataId:e.write(g,c,n.dtype),shape:c,dtype:n.dtype}}const cS={kernelName:cf,backendName:"cpu",kernelFunc:iS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lS=Ce((s,t)=>{const e=s%t;return s<0&&t<0||s>=0&&t>=0?e:(e+t)%t}),uS=$e(kr,lS),dS={kernelName:kr,backendName:"cpu",kernelFunc:uS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uu(s){const{inputs:t,backend:e,attrs:a}=s,{logits:n}=t,{dim:o}=a,r=n.shape.length;let c=o;if(c===-1&&(c=r-1),c!==r-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r} and dim was ${c}`);const i=Oe([c],n.shape),l=zu({inputs:{x:n},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=Wt(l.shape,i),d=de({inputs:{x:l},backend:e,attrs:{shape:u}}),p=ya({inputs:{a:n,b:d},backend:e}),h=Su({inputs:{x:p},backend:e}),f=_n({inputs:{x:h},backend:e,attrs:{axis:i,keepDims:!1}}),x=de({inputs:{x:f},backend:e,attrs:{shape:u}}),m=Sa({inputs:{a:h,b:x},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(x),m}const pS={kernelName:lf,backendName:"cpu",kernelFunc:Uu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hS(s){const{inputs:t,backend:e,attrs:a}=s,{logits:n}=t,{numSamples:o,seed:r,normalized:c}=a;X(n,"multinomial");const i=c?n:Uu({inputs:{logits:n},backend:e,attrs:{dim:-1}}),l=i.shape[0],u=i.shape[1],d=e.data.get(i.dataId).values,p=[l,o],h=Le(H(p),"int32");for(let f=0;f<l;++f){const x=f*u,m=new Float32Array(u-1);m[0]=d[x];for(let b=1;b<m.length;++b)m[b]=m[b-1]+d[x+b];const g=df.alea(r.toString()),C=f*o;for(let b=0;b<o;++b){const $=g();h[C+b]=m.length;for(let I=0;I<m.length;I++)if($<m[I]){h[C+b]=I;break}}}return c||e.disposeIntermediateTensorInfo(i),e.makeTensorInfo(p,"int32",h)}const fS={kernelName:uf,backendName:"cpu",kernelFunc:hS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS=hf;function gS(s){const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i}=a;X(n,"NonMaxSuppression");const l=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,{selectedIndices:d}=mS(l,u,r,c,i);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const xS={kernelName:pf,backendName:"cpu",kernelFunc:gS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CS=mf;function $S(s){const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i,padToMaxOutputSize:l}=a;X(n,"NonMaxSuppressionPadded");const u=e.data.get(n.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:p,validOutputs:h}=CS(u,d,r,c,i,l);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([h]))]}const bS={kernelName:ff,backendName:"cpu",kernelFunc:$S};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS=xf;function vS(s){const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i,softNmsSigma:l}=a;X(n,"NonMaxSuppressionWithScore");const u=e.data.get(n.dataId).values,d=e.data.get(o.dataId).values,p=r,h=c,f=i,x=l,{selectedIndices:m,selectedScores:g}=IS(u,d,p,h,f,x);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const yS={kernelName:gf,backendName:"cpu",kernelFunc:vS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(s){const{inputs:t,backend:e,attrs:a}=s,{indices:n}=t,{dtype:o,depth:r,onValue:c,offValue:i}=a;X(n,"oneHot");const l=H(n.shape),u=new Float32Array(l*r);u.fill(i);const d=e.data.get(n.dataId).values;for(let p=0;p<l;++p)d[p]>=0&&d[p]<r&&(u[p*r+d[p]]=c);return e.makeTensorInfo([...n.shape,r],o,u)}const SS={kernelName:Cf,backendName:"cpu",kernelFunc:wS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cs(s){const{inputs:t,backend:e}=s,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){const n=Vt({inputs:{input:a},backend:e}),o=cs({inputs:{x:n},backend:e}),r=en({inputs:{input:a},backend:e}),c=cs({inputs:{x:r},backend:e}),i=Pe({inputs:{real:o,imag:c},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(c),i}else return ka({backend:e,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const kS={kernelName:$f,backendName:"cpu",kernelFunc:cs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gu(s){const{inputs:t,backend:e}=s,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){const n=Vt({inputs:{input:a},backend:e}),o=Gu({inputs:{x:n},backend:e}),r=en({inputs:{input:a},backend:e}),c=cs({inputs:{x:r},backend:e}),i=Pe({inputs:{real:o,imag:c},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(c),i}else return ka({backend:e,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}const RS={kernelName:bf,backendName:"cpu",kernelFunc:Gu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(s){const{inputs:t,backend:e,attrs:a}=s,{axis:n}=a;if(t.length===1)return is({inputs:{input:t[0]},backend:e,attrs:{dim:n}});const o=t[0].shape,r=t[0].dtype;t.forEach(u=>{vf(o,u.shape,"All tensors passed to stack must have matching shapes"),we(r===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const c=[],i=t.map(u=>{const d=is({inputs:{input:u},backend:e,attrs:{dim:n}});return c.push(d),d}),l=tn({inputs:i,backend:e,attrs:{axis:n}});return c.forEach(u=>e.disposeIntermediateTensorInfo(u)),l}const NS={kernelName:If,backendName:"cpu",kernelFunc:Hu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{paddings:o,constantValue:r}=a;X(n,"pad");const c=o.map((C,b)=>C[0]+n.shape[b]+C[1]),i=o.map(C=>C[0]),l=e.data.get(n.dataId).values,u=H(n.shape),d=n.shape.length,p=J(n.shape),h=H(c),f=c.length,x=J(c),m=Re(n.dtype,h);r!==0&&m.fill(r);for(let C=0;C<u;C++){const $=on(C,d,p).map((v,y)=>v+i[y]),I=st($,f,x);m[I]=l[C]}return{dataId:e.write(m,c,n.dtype),shape:c,dtype:n.dtype}}const Xu={kernelName:yf,backendName:"cpu",kernelFunc:TS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ES=Ce((s,t)=>Math.pow(s,t)),FS=$e(Rr,ES),DS={kernelName:Rr,backendName:"cpu",kernelFunc:FS};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(s){const{inputs:t,backend:e,attrs:a}=s,{paramsNestedSplits:n,paramsDenseValues:o,indices:r}=t,c=n.map(m=>e.data.get(m.dataId).values),i=n.map(m=>m.shape),l=e.data.get(o.dataId).values,u=e.data.get(r.dataId).values,[d,p,h]=TI(c,i,l,o.shape,o.dtype,u,r.shape),f=d.map(m=>e.makeTensorInfo([m.length],"int32",m)),x=e.makeTensorInfo(h,o.dtype,p);return f.concat([x])}const AS={kernelName:wf,backendName:"cpu",kernelFunc:OS};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(s){const{inputs:t,backend:e,attrs:a}=s,{shape:n,values:o,defaultValue:r,rowPartitionTensors:c}=t,{rowPartitionTypes:i}=a,l=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,d=e.data.get(r.dataId).values,p=c.map(m=>e.data.get(m.dataId).values),h=c.map(m=>m.shape),[f,x]=EI(l,n.shape,u,o.shape,o.dtype,d,r.shape,p,h,i);return e.makeTensorInfo(f,o.dtype,x)}const _S={kernelName:Sf,backendName:"cpu",kernelFunc:PS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(s){const{backend:t,attrs:e}=s,{start:a,stop:n,dtype:o,step:r}=e,c=FI(a,n,r,o);return t.makeTensorInfo([c.length],o,c)}const LS={kernelName:kf,backendName:"cpu",kernelFunc:MS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VS=ie(Nr,s=>1/s),BS={kernelName:Nr,backendName:"cpu",kernelFunc:VS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(s){const{inputs:t,backend:e,attrs:a}=s,{images:n}=t,{alignCorners:o,halfPixelCenters:r,size:c}=a;X(n,"resizeBilinear");const i=J(n.shape),[l,u]=c,[d,p,h,f]=n.shape,x=e.data.get(n.dataId).values,m=new Float32Array(H([d,l,u,f])),g=[o&&l>1?p-1:p,o&&u>1?h-1:h],C=[o&&l>1?l-1:l,o&&u>1?u-1:u];let b=0;const $=g[0]/C[0],I=g[1]/C[1];for(let v=0;v<d;v++)for(let y=0;y<l;y++){let w;r?w=$*(y+.5)-.5:w=$*y;const k=Math.max(0,Math.floor(w)),S=w-k,E=Math.min(p-1,Math.ceil(w)),O=v*i[0]+k*i[1],F=v*i[0]+E*i[1];for(let D=0;D<u;D++){let N;r?N=I*(D+.5)-.5:N=I*D;const T=Math.max(0,Math.floor(N)),_=N-T,R=Math.min(h-1,Math.ceil(N)),P=O+T*i[2],L=F+T*i[2],M=O+R*i[2],W=F+R*i[2];for(let V=0;V<f;V++){const z=x[P+V],B=x[L+V],G=x[M+V],j=x[W+V],Q=z+(G-z)*_,Z=B+(j-B)*_,ee=Q+(Z-Q)*S;m[b++]=ee}}}return e.makeTensorInfo([d,l,u,f],"float32",m)}const zS={kernelName:Rf,backendName:"cpu",kernelFunc:WS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(s){const{inputs:t,backend:e,attrs:a}=s,{images:n,dy:o}=t,{alignCorners:r}=a;X([o,n],"resizeBilinearGrad");const c=J(n.shape),[i,l,u,d]=n.shape,[,p,h]=o.shape,f=new Float32Array(i*l*u*d),x=[r&&p>1?l-1:l,r&&h>1?u-1:u],m=[r&&p>1?p-1:p,r&&h>1?h-1:h],g=x[0]/m[0],C=x[1]/m[1],b=e.data.get(o.dataId).values;let $=0;for(let I=0;I<i;I++){const v=I*c[0];for(let y=0;y<p;y++){const w=y*g,k=Math.floor(w),S=Math.min(Math.ceil(w),l-1),E=v+k*c[1],O=v+S*c[1],F=w-k,D=1-F;for(let N=0;N<h;N++){const T=N*C,_=Math.floor(T),R=Math.min(Math.ceil(T),u-1),P=T-_,L=1-P,M=E+_*c[2],W=E+R*c[2],V=O+_*c[2],z=O+R*c[2],B=D*L,G=D*P,j=F*L,Q=F*P;for(let Z=0;Z<d;Z++){const ee=b[$++];f[M+Z]+=ee*B,f[W+Z]+=ee*G,f[V+Z]+=ee*j,f[z+Z]+=ee*Q}}}}return e.makeTensorInfo([i,u,l,d],"float32",f)}const GS={kernelName:Nf,backendName:"cpu",kernelFunc:US};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(s){const{inputs:t,backend:e,attrs:a}=s,{images:n}=t,{alignCorners:o,halfPixelCenters:r,size:c}=a;X(n,"resizeNearestNeighbor");const i=J(n.shape),[l,u]=c,[d,p,h,f]=n.shape,x=e.data.get(n.dataId).values,m=new Float32Array(d*l*u*f),g=[o&&l>1?p-1:p,o&&u>1?h-1:h],C=[o&&l>1?l-1:l,o&&u>1?u-1:u],b=g[0]/C[0],$=g[1]/C[1];let I=0;for(let v=0;v<d;v++){const y=v*i[0];for(let w=0;w<l;w++){const k=r?b*(w+.5):b*w;let S=Math.min(p-1,o?Math.round(k):Math.floor(k));r&&(S=Math.max(0,S));const E=y+S*i[1];for(let O=0;O<u;O++){const F=r?$*(O+.5):$*O;let D=Math.min(h-1,o?Math.round(F):Math.floor(F));r&&(D=Math.max(0,D));const N=E+D*i[2];for(let T=0;T<f;T++){const _=x[N+T];m[I++]=_}}}}return e.makeTensorInfo([d,l,u,f],n.dtype,m)}const XS={kernelName:Tf,backendName:"cpu",kernelFunc:HS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(s){const{inputs:t,backend:e,attrs:a}=s,{images:n,dy:o}=t,{alignCorners:r}=a;X([o,n],"resizeNearestNeighborGrad");const c=J(n.shape),i=J(o.shape),[l,u,d,p]=n.shape,[,h,f]=o.shape,x=new Float32Array(l*u*d*p),m=e.data.get(o.dataId).values,g=[r&&h>1?u-1:u,r&&f>1?d-1:d],C=[r&&h>1?h-1:h,r&&f>1?f-1:f],b=g[0]/C[0],$=g[1]/C[1],I=1/b,v=1/$,y=Math.ceil(I)*2+2,w=Math.ceil(v)*2+2;for(let k=0;k<l;k++){const S=k*c[0];for(let E=0;E<u;E++){const O=S+E*c[1],F=Math.floor(E*I),D=Math.floor(F-y/2);for(let N=0;N<d;N++){const T=O+N*c[2],_=Math.floor(N*v),R=Math.floor(_-w/2);for(let P=0;P<p;P++){let L=0;for(let M=0;M<y;M++){const W=M+D;if(W<0||W>=h)continue;const V=S+W*i[1],z=W*b,B=Math.min(u-1,r?Math.round(z):Math.floor(z));if(E===B)for(let G=0;G<w;G++){const j=G+R;if(j<0||j>=f)continue;const Q=V+j*i[2],Z=j*$,ee=Math.min(d-1,r?Math.round(Z):Math.floor(Z));N===ee&&(L+=m[Q+P])}}x[T+P]=L}}}}return e.makeTensorInfo(n.shape,n.dtype,x)}const jS={kernelName:Ef,backendName:"cpu",kernelFunc:qS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{dims:o}=a;X(n,"reverse");const r=n.shape.length,c=Oe(o,n.shape);if(r===0)return at({inputs:{x:n},backend:e});const i=new ke(n.shape,n.dtype),l=e.bufferSync(n);for(let u=0;u<i.size;u++){const d=i.indexToLoc(u),p=d.slice();c.forEach(h=>p[h]=n.shape[h]-1-p[h]),i.set(l.get(...p),...d)}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const YS={kernelName:Ff,backendName:"cpu",kernelFunc:KS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QS={kernelName:Df,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:a}=s,{radians:n,fillValue:o,center:r}=t,c=e,i=Re(a.dtype,H(a.shape)),[l,u,d,p]=a.shape,[h,f]=Of(r,u,d),x=255,m=Math.sin(n),g=Math.cos(n),C=c.data.get(a.dataId).values;for(let $=0;$<l;$++){const I=$*d*u*p;for(let v=0;v<u;v++){const y=v*(d*p);for(let w=0;w<d;w++){const k=w*p;for(let S=0;S<p;S++){const E=[l,v,w,S],O=E[2],F=E[1];let D=(O-h)*g-(F-f)*m,N=(O-h)*m+(F-f)*g;D=Math.round(D+h),N=Math.round(N+f);let T=o;if(typeof o!="number"&&(S===3?T=x:T=o[S]),D>=0&&D<d&&N>=0&&N<u){const R=N*(d*p),P=D*p,L=I+R+P+S;T=C[L]}const _=I+y+k+S;i[_]=T}}}}return{dataId:c.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZS=ie(Tr,s=>{const t=Math.floor(s);return s-t<.5?Math.floor(s):s-t>.5?Math.ceil(s):t%2===0?t:t+1}),JS={kernelName:Tr,backendName:"cpu",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(s){const{inputs:t,backend:e,attrs:a}=s,{indices:n,updates:o}=t,{shape:r}=a,{sliceRank:c,numUpdates:i,sliceSize:l,strides:u,outputSize:d}=Er(o,n,r),p=!0,h=e.bufferSync(n),f=e.bufferSync(o),x=yn(h,f,r,d,l,i,c,u,0,p);return e.makeTensorInfo(r,x.dtype,x.values)}const tk={kernelName:Af,backendName:"cpu",kernelFunc:ek};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(s,t){let e=0,a=s.length,n=0;for(;e<a;)n=Math.floor((e+a)/2),s[n]<t?e=n+1:a=n;return a}function sk(s,t){let e=0,a=s.length,n=0;for(;e<a;)n=Math.floor((e+a)/2),s[n]<=t?e=n+1:a=n;return a}function ak(s,t,e,a,n,o){const r=ye("int32",e*n);for(let c=0;c<e;++c){const i=s.slice(c*a,(c+1)*a),l=c*n;for(let u=0;u<n;++u)r[l+u]=o==="left"?nk(i,t[u+l]):sk(i,t[u+l])}return r}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok(s){const{inputs:t,backend:e,attrs:a}=s,{sortedSequence:n,values:o}=t,{side:r}=a,c=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,l=ak(c,i,n.shape[0],n.shape[1],o.shape[1],r);return e.makeTensorInfo(o.shape,"int32",l)}const rk={kernelName:Pf,backendName:"cpu",kernelFunc:ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(s){const{inputs:t,backend:e}=s,{condition:a,t:n,e:o}=t;X([a,n,o],"select");const r=a.shape.length,c=e.data.get(a.dataId).values,i=e.data.get(n.dataId).values,l=e.data.get(o.dataId).values,u=Fn(n.dtype,o.dtype),d=Le(H(n.shape),u);let p=0;const h=r===0||r>1||n.shape.length===1?1:H(n.shape.slice(1));for(let f=0;f<c.length;f++)for(let x=0;x<h;x++)c[f]===1?d[p++]=i[f]:d[p++]=l[f];return e.makeTensorInfo(n.shape,u,d)}const ck={kernelName:_f,backendName:"cpu",kernelFunc:ik};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lk=Mf,uk=Lf,dk=ie(Fr,s=>s>=0?uk*s:lk*(Math.exp(s)-1)),pk={kernelName:Fr,backendName:"cpu",kernelFunc:dk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk=ie(Dr,s=>s<0?-1:s>0?1:0),fk={kernelName:Dr,backendName:"cpu",kernelFunc:hk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=ie(Or,s=>Math.sin(s)),gk={kernelName:Or,backendName:"cpu",kernelFunc:mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xk=ie(Ar,s=>Math.sinh(s)),Ck={kernelName:Ar,backendName:"cpu",kernelFunc:xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=11920928955078125e-23,to=Math.log($k)+2,bk=ie(Pr,s=>{const t=s>-to,e=s<to,a=Math.exp(s);let n;return e?n=a:t?n=s:n=Math.log(1+a),n}),Ik={kernelName:Pr,backendName:"cpu",kernelFunc:bk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockShape:o,paddings:r}=a;X([n],"spaceToBatchND");const c=H(o),i=[[0,0]];i.push(...r);for(let v=1+o.length;v<n.shape.length;++v)i.push([0,0]);const l=Xu.kernelFunc({inputs:{x:n},backend:e,attrs:{paddings:i,constantValue:0}}),u=ir(l.shape,o,c,!1),d=cr(u.length,o.length,!1),p=lr(l.shape,o,c,!1),x=de({inputs:{x:l},backend:e,attrs:{shape:u}}),C=De({inputs:{x},backend:e,attrs:{perm:d}}),I=de({inputs:{x:C},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(C),I}const yk={kernelName:Vf,backendName:"cpu",kernelFunc:vk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wk(s){const{inputs:t,backend:e}=s,{indices:a,values:n,denseShape:o,defaultValue:r}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${n.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const c=e.data.get(a.dataId).values,i=e.data.get(n.dataId).values,l=e.data.get(o.dataId).values,u=e.data.get(r.dataId).values[0],[d,p,h,f,x]=LI(c,a.shape,a.dtype,i,n.dtype,l,u);return[e.makeTensorInfo(p,a.dtype,d),e.makeTensorInfo([p[0]],n.dtype,h),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([x.length],a.dtype,new Int32Array(x))]}const Sk={kernelName:Bf,backendName:"cpu",kernelFunc:wk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(s){const{inputs:t,backend:e}=s,{inputIndices:a,inputShape:n,newShape:o}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const r=Array.from(e.data.get(n.dataId).values),c=e.data.get(a.dataId).values,i=Array.from(e.data.get(o.dataId).values),[l,u,d]=VI(c,a.shape,a.dtype,r,i);return[e.makeTensorInfo(u,a.dtype,l),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const Rk={kernelName:Wf,backendName:"cpu",kernelFunc:kk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nk(s){const{inputs:t,backend:e}=s,{data:a,indices:n,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${n.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(n.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(a.dataId).values,c=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[l,u]=Tu(r,a.shape,a.dtype,c,i,!0);return e.makeTensorInfo(u,a.dtype,l)}const Tk={kernelName:zf,backendName:"cpu",kernelFunc:Nk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(s){const{inputs:t,backend:e}=s,{data:a,indices:n,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(n.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(a.dataId).values,c=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[l,u]=Tu(r,a.shape,a.dtype,c,i);return e.makeTensorInfo(u,a.dtype,l)}const Fk={kernelName:Uf,backendName:"cpu",kernelFunc:Ek};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dk(s){const{inputs:t,backend:e,attrs:a}=s,{sparseIndices:n,sparseValues:o,defaultValue:r}=t,{outputShape:c}=a,{sliceRank:i,numUpdates:l,sliceSize:u,strides:d,outputSize:p}=Er(o,n,c),h=!1,f=e.bufferSync(n);let x;switch(o.dtype){case"bool":{const m=e.bufferSync(o),g=Boolean(e.data.get(r.dataId).values[0]);x=yn(f,m,c,p,u,l,i,d,g,h);break}case"float32":{const m=e.bufferSync(o),g=e.data.get(r.dataId).values[0];x=yn(f,m,c,p,u,l,i,d,g,h);break}case"int32":{const m=e.bufferSync(o),g=e.data.get(r.dataId).values[0];x=yn(f,m,c,p,u,l,i,d,g,h);break}case"string":{const m=e.bufferSync(o),g=Eo(e.data.get(r.dataId).values[0]);x=yn(f,m,c,p,u,l,i,d,g,h);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(c,x.dtype,x.values)}const Ok={kernelName:Gf,backendName:"cpu",kernelFunc:Dk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ak(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{numOrSizeSplits:o,axis:r}=a,c=Oe(r,n.shape)[0],i=Xf(n,o,c),l=new Array(n.shape.length).fill(0),u=n.shape.slice();return i.map(d=>{const p=[...u];p[c]=d;const h=Bt({inputs:{x:n},backend:e,attrs:{begin:l,size:p}});return l[c]+=d,h})}const Pk={kernelName:Hf,backendName:"cpu",kernelFunc:Ak};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k={kernelName:qf,backendName:"cpu",kernelFunc:({inputs:s,backend:t})=>{const{x:e}=s,a=t;X(e,"square");const n=a.data.get(e.dataId).values,o=new Float32Array(n.length);for(let c=0;c<n.length;++c){const i=n[c];o[c]=i*i}return{dataId:a.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mk=ie(_r,(s,t)=>{const e=t;return isNaN(s)?NaN:s>0?1:e.alpha}),Lk={kernelName:_r,backendName:"cpu",kernelFunc:Mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{begin:o,end:r,strides:c,beginMask:i,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=a;X(n,"stridedSlice");const{finalShapeSparse:h,finalShape:f,isIdentity:x,sliceDim0:m,isSimpleSlice:g,begin:C,end:b,strides:$}=Kf(n.shape,o,r,c,i,l,u,d,p);let I;if(x)I=de({inputs:{x:n},backend:e,attrs:{shape:f}});else if(m||g){we(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);const v=Yf(C,b,$),y=Bt({inputs:{x:n},backend:e,attrs:{begin:C,size:v}});I=de({inputs:{x:y},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(y)}else{const v=e.bufferSync(n),y=HI(h,v,$,C);I=e.makeTensorInfo(f,y.dtype,y.values)}return I}const Bk={kernelName:jf,backendName:"cpu",kernelFunc:Vk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(s){const{inputs:t,backend:e,attrs:a}=s,{separator:n,nGramWidths:o,leftPad:r,rightPad:c,padWidth:i,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,p=e.data.get(u.dataId).values,h=e.data.get(d.dataId).values,[f,x]=qI(p,h,n,o,r,c,i,l);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",x)]}const zk={kernelName:Qf,backendName:"cpu",kernelFunc:Wk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(s){const{inputs:t,backend:e,attrs:a}=s,{skipEmpty:n}=a,{input:o,delimiter:r}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const c=e.data.get(o.dataId).values,i=e.data.get(r.dataId).values[0],[l,u,d]=KI(c,i,n),p=u.length;return[e.makeTensorInfo([p,2],"int32",l),e.makeTensorInfo([p],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const Gk={kernelName:Zf,backendName:"cpu",kernelFunc:Uk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hk(s){const{inputs:t,backend:e,attrs:a}=s,{numBuckets:n}=a,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");const r=e.data.get(o.dataId).values,c=YI(r,n);return e.makeTensorInfo(o.shape,"int32",c)}const Xk={kernelName:Jf,backendName:"cpu",kernelFunc:Hk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qk=ie(Mr,s=>Math.tan(s)),jk={kernelName:Mr,backendName:"cpu",kernelFunc:qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kk=ie(Lr,s=>Math.tanh(s)),Yk={kernelName:Lr,backendName:"cpu",kernelFunc:Kk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qk(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{reps:o}=a;X(n,"tile");const r=ev(e.bufferSync(n),o);return e.makeTensorInfo(r.shape,r.dtype,r.values)}const Zk={kernelName:em,backendName:"cpu",kernelFunc:Qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jk(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{k:o,sorted:r}=a;X(n,"topk");const c=e.data.get(n.dataId).values,[i,l]=tv(c,n.shape,n.dtype,o,r);return[e.makeTensorInfo(i.shape,i.dtype,i.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}const eR={kernelName:tm,backendName:"cpu",kernelFunc:Jk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(s){const{inputs:t,attrs:e,backend:a}=s,{image:n,transforms:o}=t,{interpolation:r,fillMode:c,fillValue:i,outputShape:l}=e,[u,d,p,h]=n.shape,[f,x]=l??[d,p],m=[u,f,x,h],g=J(n.shape),C=g[0],b=g[1],$=g[2],I=J(m),v=I[0],y=I[1],w=I[2],k=Re(n.dtype,H(m));k.fill(i);const S=a.data.get(n.dataId).values,E=a.data.get(o.dataId).values;for(let F=0;F<u;++F){const D=o.shape[0]===1?E:E.subarray(F*8,F*8+8);for(let N=0;N<f;++N)for(let T=0;T<x;++T)for(let _=0;_<h;++_){let R;const P=D[6]*T+D[7]*N+1;if(P===0)continue;const L=(D[0]*T+D[1]*N+D[2])/P,M=(D[3]*T+D[4]*N+D[5])/P,W=no(L,p,c),V=no(M,d,c);switch(r){case"nearest":R=iR(S,d,p,C,b,$,F,V,W,_,i);break;case"bilinear":R=cR(S,d,p,C,b,$,F,V,W,_,i);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${r}`)}const z=F*v+N*y+T*w+_;k[z]=R}return a.makeTensorInfo(m,n.dtype,k)}return{dataId:a.write(k,m,n.dtype),shape:n.shape,dtype:n.dtype}}const nR={kernelName:nm,backendName:"cpu",kernelFunc:tR};function no(s,t,e){switch(e){case"reflect":return sR(s,t);case"wrap":return aR(s,t);case"nearest":return rR(s,t);case"constant":default:return oR(s)}}function sR(s,t){let e=s;if(e<0)if(t<=1)e=0;else{const a=2*t;e<a&&(e=a*Math.trunc(-e/a)+e),e=e<-t?e+a:-e-1}else if(e>t-1)if(t<=1)e=0;else{const a=2*t;e-=a*Math.trunc(e/a),e>=t&&(e=a-e-1)}return ha(0,e,t-1)}function aR(s,t){let e=s;if(e<0)if(t<=1)e=0;else{const a=t-1;e+=t*(Math.trunc(-e/a)+1)}else if(e>t-1)if(t<=1)e=0;else{const a=t-1;e-=t*Math.trunc(e/a)}return ha(0,e,t-1)}function oR(s,t){return s}function rR(s,t){return ha(0,s,t-1)}function Sn(s,t,e,a,n,o,r,c,i,l,u){const d=r*a+c*n+i*o+l;return 0<=c&&c<t&&0<=i&&i<e?s[d]:u}function iR(s,t,e,a,n,o,r,c,i,l,u){const d=Math.round(c),p=Math.round(i);return Sn(s,t,e,a,n,o,r,d,p,l,u)}function cR(s,t,e,a,n,o,r,c,i,l,u){const d=Math.floor(c),p=Math.floor(i),h=d+1,f=p+1,x=(f-i)*Sn(s,t,e,a,n,o,r,d,p,l,u)+(i-p)*Sn(s,t,e,a,n,o,r,d,f,l,u),m=(f-i)*Sn(s,t,e,a,n,o,r,h,p,l,u)+(i-p)*Sn(s,t,e,a,n,o,r,h,f,l,u);return(h-c)*x+(c-d)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(s){const{inputs:t,attrs:e,backend:a}=s,{axis:n}=e,{x:o}=t;X(o,"unique");const r=a.data.get(o.dataId).values,{outputValues:c,outputShape:i,indices:l}=nv(r,n,o.shape,o.dtype);return[a.makeTensorInfo(i,o.dtype,c),a.makeTensorInfo([l.length],"int32",l)]}const uR={kernelName:sm,backendName:"cpu",kernelFunc:lR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(s){const{inputs:t,backend:e,attrs:a}=s,{value:n}=t;let{axis:o}=a;o<0&&(o+=n.shape.length);const r=n.shape.length,c=n.shape[o],i=new Array(r-1);let l=0;for(let h=0;h<r;h++)h!==o&&(i[l++]=n.shape[h]);const u=new Array(r).fill(0),d=n.shape.slice();d[o]=1;const p=new Array(c);for(let h=0;h<p.length;h++){u[o]=h;const f=Bt({inputs:{x:n},backend:e,attrs:{begin:u,size:d}});p[h]=de({inputs:{x:f},backend:e,attrs:{shape:i}}),e.disposeIntermediateTensorInfo(f)}return p}const pR={kernelName:am,backendName:"cpu",kernelFunc:dR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,segmentIds:o}=t,{numSegments:r}=a;X(n,"unsortedSegmentSum");const c=n.shape.length,i=o.shape.length,l=[],u=[],d=c-i;let p=o;for(let f=0;f<d;++f){const x=is({inputs:{input:p},backend:e,attrs:{dim:f+1}});p=x,u.push(x)}for(let f=0;f<r;++f){const x=ia(f,"int32"),m=e.makeTensorInfo([],"int32",x),g=wu({inputs:{a:m,b:p},backend:e}),C=wt({inputs:{x:g},backend:e,attrs:{dtype:"float32"}}),b=Ns({inputs:{a:C,b:n},backend:e}),$=_n({inputs:{x:b},backend:e,attrs:{axis:0,keepDims:!1}});l.push($),u.push(m),u.push(g),u.push(C),u.push(b),u.push($)}const h=Hu({inputs:l,backend:e,attrs:{axis:0}});return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const fR={kernelName:om,backendName:"cpu",kernelFunc:hR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mR=[pv,gb,fv,gv,wb,Cv,bv,vv,wv,kv,Nv,Ev,Dv,Pv,Mv,Bv,zv,Gv,Xv,uv,jv,Yv,Zv,ey,Ib,Nb,ny,xb,ay,ry,iy,ly,dy,hy,my,xy,$y,Iy,yy,Sy,Ry,Ty,Fy,Dy,Ay,_y,Ly,Vy,By,Wy,Gy,sv,Xy,Fb,ew,Ob,tw,_b,iw,cw,uw,Vb,hw,mw,xw,$w,Iw,Gb,qb,Cb,yw,oy,Sw,Rw,Tw,av,Yb,Jb,Fw,sI,Ow,_w,Lw,Ww,Uw,Hw,Xw,iI,jw,Yw,Zw,eS,nS,aS,rS,uI,cS,dS,fS,pI,mI,xS,bS,yS,CI,SS,RS,NS,Xu,DS,rv,vI,AS,_S,LS,$b,ta,BS,iv,cv,lv,zS,GS,XS,jS,YS,QS,JS,AI,tk,rk,ck,pk,PI,fk,gk,Ck,MI,pS,Ik,yk,Sk,Rk,Tk,Fk,Ok,Pk,WI,_k,GI,Lk,Bk,zk,Gk,Xk,JI,zy,jk,Yk,Zk,eR,nR,$I,uR,pR,fR,kS];for(const s of mR)rm(s);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pt={},Hn={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gR(s,t){Pt[s]=t}function Je(s,t){if(!(s in Pt)||t!=null){const a=CR(s,t);if(a!==null)Pt[s]=a;else return console.log("Could not get context for WebGL version",s),null}const e=Pt[s];return e==null||e.isContextLost()?(delete Pt[s],Je(s)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Pt[s])}function xR(s){if(typeof OffscreenCanvas<"u"&&s===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function CR(s,t){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??xR(s);return e.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete Pt[s]},!1),A().getBool("SOFTWARE_WEBGL_ENABLED")&&(Hn.failIfMajorPerformanceCaveat=!1),s===1?e.getContext("webgl",Hn)||e.getContext("experimental-webgl",Hn):e.getContext("webgl2",Hn)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Rn;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(Rn||(Rn={}));var ze;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(ze||(ze={}));var Ie;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ie||(Ie={}));function Mn(s,t){return[t,s]}function $R(s,t){return s*t}function Xn(s){const t=Y(s),e=Math.ceil(t/4);return Zs(e)}function dn(s,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(s/2))]}function bR(s,t){const[e,a]=dn(s,t);return e*a*4}function Ra(s,t){const e=s;let a,n,o,r,c,i,l,u,d,p;return A().getNumber("WEBGL_VERSION")===2?(a=e.R32F,n=e.R16F,o=e.RGBA16F,r=e.RGBA32F,c=e.RED,l=4,u=1,d=e.HALF_FLOAT,p=e.FLOAT,i=e.RGBA8):(a=s.RGBA,n=s.RGBA,o=s.RGBA,r=e.RGBA,c=s.RGBA,l=4,u=4,d=t!=null?t.HALF_FLOAT_OES:null,p=s.FLOAT,i=s.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:n,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:r,textureFormatFloat:c,downloadTextureFormat:i,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q(s,t){const e=t();return A().getBool("DEBUG")&&IR(s),e}function IR(s){const t=s.getError();if(t!==s.NO_ERROR)throw new Error("WebGL Error: "+SR(s,t))}const vR=596e-10,yR=65504;function wR(s){return!!(A().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||vR<Math.abs(s)&&Math.abs(s)<yR)}function SR(s,t){switch(t){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function qn(s,t){return ft(s,()=>s.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function kR(s,t){const e=ft(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(q(s,()=>s.shaderSource(e,t)),q(s,()=>s.compileShader(e)),s.getShaderParameter(e,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function RR(s,t){const e=ft(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(q(s,()=>s.shaderSource(e,t)),q(s,()=>s.compileShader(e)),A().get("ENGINE_COMPILE_ONLY"))return e;if(s.getShaderParameter(e,s.COMPILE_STATUS)===!1)throw qu(t,s.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const NR=/ERROR: [0-9]+:([0-9]+):/g;function qu(s,t){const e=NR.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(s);return}const a=+e[1],n=s.split(`
`),o=n.length.toString().length+2,r=n.map((d,p)=>za((p+1).toString(),o)+d);let c=0;for(let d=0;d<r.length;d++)c=Math.max(r[d].length,c);const i=r.slice(0,a-1),l=r.slice(a-1,a),u=r.slice(a);console.log(i.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${za(l[0],c)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function TR(s){return ft(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function ER(s,t){if(q(s,()=>s.linkProgram(t)),!A().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(t,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Bs(s,t){if(q(s,()=>s.validateProgram(t)),s.getProgramParameter(t,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FR(s,t){const e=ft(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return q(s,()=>s.bindBuffer(s.ARRAY_BUFFER,e)),q(s,()=>s.bufferData(s.ARRAY_BUFFER,t,s.STATIC_DRAW)),e}function DR(s,t){const e=ft(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return q(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e)),q(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,t,s.STATIC_DRAW)),e}function OR(s){return ft(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function AR(s,t){const e=A().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||t<=0){const a=`[${s}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(s>e||t>e){const a=`[${s}x${t}]`,n=`[${e}x${e}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+n+".")}}function PR(s){return ft(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function so(s,t,e,a,n,o,r){const c=s.getAttribLocation(t,e);return c===-1?!1:(q(s,()=>s.bindBuffer(s.ARRAY_BUFFER,a)),q(s,()=>s.vertexAttribPointer(c,n,s.FLOAT,!1,o,r)),q(s,()=>s.enableVertexAttribArray(c)),!0)}function _R(s,t,e){WR(s,e),q(s,()=>s.activeTexture(s.TEXTURE0+e)),q(s,()=>s.bindTexture(s.TEXTURE_2D,t))}function MR(s,t,e){return ft(s,()=>s.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function LR(s,t,e){return s.getUniformLocation(t,e)}function VR(s,t,e,a){q(s,()=>_R(s,t,a)),q(s,()=>s.uniform1i(e,a))}function Ws(s,t,e){q(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,e)),q(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0))}function ao(s,t){q(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,t)),q(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function jn(s){const t=s.checkFramebufferStatus(s.FRAMEBUFFER);if(t!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+BR(s,t))}function BR(s,t){switch(t){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ft(s,t,e){const a=q(s,()=>t());if(a==null)throw new Error(e);return a}function WR(s,t){const e=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+s.TEXTURE0;if(a<s.TEXTURE0||a>e){const n=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${n}.`)}}function nn(s,t=2){return Y(s.slice(0,s.length-t))}function sn(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function zs(s){let t=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(t=[nn(s),...sn(s)]),t}function zR(s,t=!1){let e=A().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=A().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&A().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=e/2),t&&(e=e*2,a=a*2,s=s.map((c,i)=>i>=s.length-2?ga(s[i]):s[i]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=Ut(s).newShape);let n=Y(s),o=null;s.length<=1&&n<=e?o=[1,n]:s.length===2&&s[0]<=e&&s[1]<=e?o=s:s.length===3&&s[0]*s[1]<=e&&s[2]<=e?o=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=e&&s[1]*s[2]<=e?o=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=e&&s[3]<=e?o=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=e&&s[1]*s[2]*s[3]<=e&&(o=[s[0],s[1]*s[2]*s[3]]);const r=o!=null&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(o==null||r)if(t){const c=nn(s);let i=2,l=2;s.length&&([i,l]=sn(s)),n=c*(i/2)*(l/2),o=Zs(n).map(u=>u*2)}else o=Zs(n);return o}function Kn(s){return s%2===0}function ls(s,t){if(s=s.slice(-2),t=t.slice(-2),Ne(s,t)||!s.length||!t.length||s[0]===0||s[1]===0||t[0]===0||t[1]===0)return!0;if(s.length!==t.length){const e=s.slice(-1)[0],a=t.slice(-1)[0];if(e===a||Kn(e)&&Kn(a)&&(s[0]===1||t[0]===1))return!0}return s[1]===t[1]&&Kn(s[0])&&Kn(t[0])}let Us,Gs;function UR(s){if(Us==null){const t=Je(s);Us=t.getParameter(t.MAX_TEXTURE_SIZE)}return Us}function GR(s){if(Gs==null){const t=Je(s);Gs=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Gs)}function HR(s){if(s===0)return 0;let t;const e=Je(s);return qe(e,"EXT_disjoint_timer_query_webgl2")&&s===2?t=2:qe(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function qe(s,t){return s.getExtension(t)!=null}function oo(s){try{if(Je(s)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function XR(s){if(s===0)return!1;const t=Je(s);if(s===1){if(!qe(t,"OES_texture_float"))return!1}else if(!qe(t,"EXT_color_buffer_float"))return!1;return sa(t)}function qR(s){if(s===0)return!1;const t=Je(s);if(s===1){if(!qe(t,"OES_texture_float")||!qe(t,"WEBGL_color_buffer_float"))return!1}else{if(qe(t,"EXT_color_buffer_float"))return sa(t);const a="EXT_color_buffer_half_float";if(qe(t,a)){const n=t.getExtension(a);return jR(t,n)}return!1}return sa(t)}function sa(s){const t=Ra(s),e=s.createTexture();s.bindTexture(s.TEXTURE_2D,e);const a=1,n=1;s.texImage2D(s.TEXTURE_2D,0,t.internalFormatFloat,a,n,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,o),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0);const r=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(e),s.deleteFramebuffer(o),r}function jR(s,t){const e=Ra(s,t),a=s.createTexture();s.bindTexture(s.TEXTURE_2D,a);const n=1,o=1;s.texImage2D(s.TEXTURE_2D,0,e.internalFormatHalfFloat,n,o,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const r=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,r),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,a,0);const c=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(a),s.deleteFramebuffer(r),c}function KR(s){return s!==2?!1:Je(s).fenceSync!=null}function Ln(s,t){Array.isArray(s)||(s=[s]),s.forEach(e=>{e!=null&&ae(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K=A();K.registerFlag("HAS_WEBGL",()=>K.getNumber("WEBGL_VERSION")>0);K.registerFlag("WEBGL_VERSION",()=>oo(2)?2:oo(1)?1:0);K.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);K.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>K.get("WEBGL_VERSION")===2);K.registerFlag("WEBGL_CPU_FORWARD",()=>!0);K.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);K.registerFlag("WEBGL_PACK",()=>K.getBool("HAS_WEBGL"));K.registerFlag("WEBGL_PACK_NORMALIZATION",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_CLIP",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_PACK_REDUCE",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_LAZILY_UNPACK",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_CONV_IM2COL",()=>K.getBool("WEBGL_PACK"));K.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>UR(K.getNumber("WEBGL_VERSION")));K.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>GR(K.getNumber("WEBGL_VERSION")));K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=K.getNumber("WEBGL_VERSION");return s===0?0:HR(s)});K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>K.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!uu());K.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>XR(K.getNumber("WEBGL_VERSION")));K.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>K.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:K.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));K.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>qR(K.getNumber("WEBGL_VERSION")));K.registerFlag("WEBGL_FENCE_API_ENABLED",()=>KR(K.getNumber("WEBGL_VERSION")));K.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>K.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);K.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${s}.`)});K.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>uu()?1:-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${s}.`)});K.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);K.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);K.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);K.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);K.registerFlag("WEBGL_EXP_CONV",()=>!1);K.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>K.getBool("IS_TEST"));K.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);K.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);K.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ee(){let s,t,e,a,n,o,r,c,i,l;return A().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",t="in",e="out",a="in",n="texture",o="outputColor",r="out vec4 outputColor;",c=A().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",i="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",t="attribute",e="varying",a="varying",n="texture2D",o="gl_FragColor",r="",c=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,i=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:t,varyingVs:e,varyingFs:a,texture2D:n,output:o,defineOutput:r,defineSpecialNaN:c,defineSpecialInf:i,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(s,t,e="index"){const a=je(t);return a.map((n,o)=>{const r=`int ${s[o]} = ${e} / ${n}`,c=o===a.length-1?`int ${s[o+1]} = ${e} - ${s[o]} * ${n}`:`index -= ${s[o]} * ${n}`;return`${r}; ${c};`}).join("")}function Ts(s,t,e="index"){const a=je(t);return a.map((n,o)=>{const r=`int ${s[o]} = ${e} / outShapeStrides[${o}]`,c=o===a.length-1?`int ${s[o+1]} = ${e} - ${s[o]} * outShapeStrides[${o}]`:`index -= ${s[o]} * outShapeStrides[${o}]`;return`${r}; ${c};`}).join("")}function YR(s,t){const e=s.length,a=s.map(o=>`${t}[${o}]`),n=new Array(e-1);n[e-2]=a[e-1];for(let o=e-3;o>=0;--o)n[o]=`(${n[o+1]} * ${a[o+1]})`;return n}function QR(s,t,e="index"){const a=s.map((o,r)=>r),n=YR(a,t);return n.map((o,r)=>{const c=`int ${s[r]} = ${e} / ${n[r]}`,i=r===n.length-1?`int ${s[r+1]} = ${e} - ${s[r]} * ${n[r]}`:`index -= ${s[r]} * ${n[r]}`;return`${c}; ${i};`}).join("")}function Na(s){const t=je(s).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Ta(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const ju=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Ku}=hu;function ZR(s,t,e){const a=[];if(s.forEach(h=>{const f=Y(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?a.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(a.push(`uniform sampler2D ${h.name};`),a.push(`uniform int offset${h.name};`)),e.enableShapeUniforms){const{uniformShape:x}=Ea(e.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(x.length){case 1:a.push(`uniform int ${h.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${h.name}Shape;`);break}a.push(`uniform ivec2 ${h.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(h=>{a.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const n=a.join(`
`),o=s.map(h=>JR(h,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),r=t.texShape,c=Ee(),i=nN(c);let l,u,d=oN(c);return t.isPacked?(l=eN(t.logicalShape,r,e.enableShapeUniforms),u=aN(c)):(l=tN(t.logicalShape,r,e.enableShapeUniforms),u=sN(c)),e.packedInputs&&(d+=lN),[d,i,u,n,l,o,e.userCode].join(`
`)}function pn(s,t=!1){const e=s.shapeInfo.logicalShape;switch(e.length){case 0:return IN(s,t);case 1:return yN(s,t);case 2:return SN(s,t);case 3:return RN(s,t);case 4:return TN(s,t);case 5:return EN(s);case 6:return FN(s);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Yu(s,t){switch(s.shapeInfo.logicalShape.length){case 0:return bN(s);case 1:return vN(s,t);case 2:return wN(s,t);case 3:return kN(s,t);default:return NN(s,t)}}function JR(s,t,e=!1,a){let n="";e?n+=Yu(s,a):n+=pn(s,a);const o=s.shapeInfo.logicalShape,r=t.logicalShape;return o.length<=r.length&&(e?n+=DN(s,t):n+=ON(s,t)),n}function eN(s,t,e){switch(s.length){case 0:return Qu();case 1:return uN(s,t,e);case 2:return CN(s,t,e);case 3:return pN(s,t,e);default:return fN(s,t,e)}}function tN(s,t,e){switch(s.length){case 0:return Qu();case 1:return dN(s,t,e);case 2:return $N(s,t,e);case 3:return hN(s,t,e);case 4:return mN(s,t,e);case 5:return gN(s,t);case 6:return xN(s,t);default:throw new Error(`${s.length}-D output sampling is not yet supported`)}}function nN(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${s.texture2D}(textureSampler, uv).r;
    }
  `}function sN(s){return`
    void setOutput(float val) {
      ${s.output} = vec4(val, 0, 0, 0);
    }
  `}function aN(s){return`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `}function oN(s){return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFs} vec2 resultUV;
    ${s.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${s.defineSpecialNaN}
    ${s.defineSpecialInf}
    ${s.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${rN}
    ${iN}
    ${cN}
  `}const rN=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,iN=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cN=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lN=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Qu(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function uN(s,t,e){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function dN(s,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function pN(s,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(s[2]/2),o=n*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec3(b, r, c);
    }
  `}function hN(s,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ts(["r","c","d"],s)}
    return ivec3(r, c, d);
  }
`;const a=Gt(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function fN(s,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(s[s.length-1]/2),o=n*Math.ceil(s[s.length-2]/2);let r=o,c="",i="b, r, c";for(let l=2;l<s.length-1;l++)r*=s[s.length-l-1],c=`
      int b${l} = index / ${r};
      index -= b${l} * ${r};
    `+c,i=`b${l}, `+i;return`
    ivec${s.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${c}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec${s.length}(${i});
    }
  `}function mN(s,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ts(["r","c","d","d2"],s)}
      return ivec4(r, c, d, d2);
    }
  `;const a=Gt(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function gN(s,t){const e=Gt(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function xN(s,t){const e=Gt(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function CN(s,t,e){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ne(s,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;const n=Math.ceil(s[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec2(r, c);
    }
  `}function $N(s,t,e){return Ne(s,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:s[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `}function Ht(s){return`offset${s}`}function bN(s){const t=s.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),a=Ee();return`
    vec4 ${e}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function IN(s,t){const e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1);if(s.shapeInfo.isUniform)return`float ${a}() {return ${e};}`;const[n,o]=s.shapeInfo.texShape;if(n===1&&o===1)return`
      float ${a}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const r=Ht(e);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${r});
      return sampleTexture(${e}, uv);
    }
  `;const[c,i]=s.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${c}, ${i}, ${r});
      return sampleTexture(${e}, uv);
    }
  `}function vN(s,t){const e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1),n=s.shapeInfo.texShape,o=Ee();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${e}, uv);
    }
  `;const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${r[0]}, ${r[1]}, index);
      return ${o.texture2D}(${e}, uv);
    }
  `}function yN(s,t){const e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1);if(s.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${hn(s)}
      }
    `;const n=s.shapeInfo.texShape,o=n[0],r=n[1];if(r===1&&o===1)return`
      float ${a}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const c=Ht(e);return r===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${o}.0);
        return sampleTexture(${e}, uv);
      }
    `:o===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${r}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${c});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${o}, ${r}, index + ${c});
      return sampleTexture(${e}, uv);
    }
  `}function wN(s,t){const e=s.shapeInfo.logicalShape,a=s.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),o=s.shapeInfo.texShape,r=o[0],c=o[1],i=Ee();if(o!=null&&Ne(e,o))return t?`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${i.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${r}.0);

        return ${i.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${n}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${i.texture2D}(${a}, uv);
    }
  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(e[1]/2);return`
    vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${i.texture2D}(${a}, uv);
    }
  `}function SN(s,t){const e=s.shapeInfo.logicalShape,a=s.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),o=s.shapeInfo.texShape;if(o!=null&&Ne(e,o)){if(t)return`
      float ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;const p=o[0],h=o[1];return`
    float ${n}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `}const{newShape:r,keptDims:c}=Ut(e),i=r;if(i.length<e.length){const p=fn(s,i),h=["row","col"];return`
      ${pn(p,t)}
      float ${n}(int row, int col) {
        return ${n}(${mn(h,c)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${hn(s)}
      }
    `;const l=o[0],u=o[1],d=Ht(a);return u===1?t?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${a}, uv);
    }
  `:l===1?t?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${n}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${n}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${a}, uv);
  }
`}function kN(s,t){const e=s.shapeInfo.logicalShape,a=s.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),o=s.shapeInfo.texShape,r=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(e[0]===1){const p=e.slice(1),h=[1,2],f=fn(s,p),x=["b","row","col"];return`
        ${Yu(f,t)}
        vec4 ${n}(int b, int row, int col) {
          return ${n}(${mn(x,h)});
        }
      `}const c=Ee();if(t)return`
    vec4 ${n}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${c.texture2D}(${a}, uv);
    }
  `;const i=r[0],l=r[1],u=Math.ceil(e[2]/2),d=u*Math.ceil(e[1]/2);return`
    vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${i}, ${l}, ${d}, ${u}, b, row, col);
      return ${c.texture2D}(${a}, uv);
    }
  `}function RN(s,t){const e=s.shapeInfo.logicalShape,a=s.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e[1]*e[2],r=e[2],{newShape:c,keptDims:i}=Ut(e),l=c;if(l.length<e.length){const x=fn(s,l),m=["row","col","depth"];return`
        ${pn(x,t)}
        float ${n}(int row, int col, int depth) {
          return ${n}(${mn(m,i)});
        }
      `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${r}, 1)));
        ${hn(s)}
      }
    `;const u=s.shapeInfo.texShape,d=u[0],p=u[1],h=s.shapeInfo.flatOffset;if(p===o&&h==null)return t?`
      float ${n}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${n}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${r}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(p===r&&h==null)return t?`
      float ${n}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${n}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${a}, uv);
    }
  `;const f=Ht(a);return t?`
    float ${n}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${n}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${r} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${a}, uv);
      }
  `}function NN(s,t){const e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Ee();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${n.texture2D}(${e}, uv);
    }
  `;const o=s.shapeInfo.logicalShape,r=o.length,c=s.shapeInfo.texShape,i=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],l=i[0],u=i[1],d=Math.ceil(o[r-1]/2);let p=d*Math.ceil(o[r-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let x=2;x<r-1;x++)h=`int b${x}, `+h,p*=o[r-x-1],f=`b${x} * ${p} + `+f;return`
    vec4 ${a}(${h}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${n.texture2D}(${e}, uv);
    }
  `}function TN(s,t){const e=s.shapeInfo.logicalShape,a=s.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e[3],r=e[2]*o,c=e[1]*r,{newShape:i,keptDims:l}=Ut(e);if(i.length<e.length){const C=fn(s,i),b=["row","col","depth","depth2"];return`
      ${pn(C,t)}
      float ${n}(int row, int col, int depth, int depth2) {
        return ${n}(${mn(b,l)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${c}, ${r}, ${o}, 1)));
        ${hn(s)}
      }
    `;const u=s.shapeInfo.flatOffset,d=s.shapeInfo.texShape,p=d[0],h=d[1],f=`int stride2 = ${a}Shape[3];`,x=`int stride1 = ${a}Shape[2] * stride2;`,m=`int stride0 = ${a}Shape[1] * stride1;`;if(h===c&&u==null)return t?`
      float ${n}(int row, int col, int depth, int depth2) {
        ${f}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${r}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(h===o&&u==null)return t?`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;const g=Ht(a);return t?`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${x}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${g});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${r} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${g});
      return sampleTexture(${a}, uv);
    }
  `}function EN(s){const t=s.shapeInfo.logicalShape,e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1),n=t[4],o=t[3]*n,r=t[2]*o,c=t[1]*r,{newShape:i,keptDims:l}=Ut(t);if(i.length<t.length){const x=fn(s,i),m=["row","col","depth","depth2","depth3"];return`
      ${pn(x)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${mn(m,l)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${r}, ${o}, ${n})) +
          depth3;
        ${hn(s)}
      }
    `;const u=s.shapeInfo.flatOffset,d=s.shapeInfo.texShape,p=d[0],h=d[1];if(h===c&&u==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${r}, ${o}, ${n}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===n&&u==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;const f=Ht(e);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${r} + depth * ${o} +
          depth2 * ${n} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function FN(s){const t=s.shapeInfo.logicalShape,e=s.name,a="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:n,keptDims:o}=Ut(t);if(n.length<t.length){const m=fn(s,n),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${pn(m)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${mn(g,o)});
      }
    `}const r=t[5],c=t[4]*r,i=t[3]*c,l=t[2]*i,u=t[1]*l;if(s.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${i}, ${c})) +
          dot(
            vec2(depth3, depth4),
            vec2(${r}, 1)));
        ${hn(s)}
      }
    `;const d=s.shapeInfo.flatOffset,p=s.shapeInfo.texShape,h=p[0],f=p[1];if(f===u&&d==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${i}, ${c}, ${r})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===r&&d==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${e}, uv);
      }
    `;const x=Ht(e);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${i} +
          depth2 * ${c} + depth3 * ${r} + depth4 + ${x};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function hn(s){const t=s.name,e=Y(s.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function DN(s,t){const e=s.name,a=e.charAt(0).toUpperCase()+e.slice(1),n="get"+a+"AtOutCoords",o=s.shapeInfo.logicalShape.length,r=t.logicalShape.length,c=Ku(s.shapeInfo.logicalShape,t.logicalShape),i=pe(r),l=r-o;let u;const d=["x","y","z","w","u","v"];o===0?u="":r<2&&c.length>=1?u="coords = 0;":u=c.map(C=>`coords.${d[C+l]} = 0;`).join(`
`);let p="";r<2&&o>0?p="coords":p=s.shapeInfo.logicalShape.map((C,b)=>`coords.${d[b+l]}`).join(", ");let h="return outputValue;";const x=Y(s.shapeInfo.logicalShape)===1,g=Y(t.logicalShape)===1;if(o===1&&!x&&!g)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!g)r===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(c.length){const C=o-2,b=o-1;c.indexOf(C)>-1&&c.indexOf(b)>-1?h="return vec4(outputValue.x);":c.indexOf(C)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(b)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${n}() {
      ${i} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${a}(${p});
      ${h}
    }
  `}function ON(s,t){const e=s.name,a=e.charAt(0).toUpperCase()+e.slice(1),n="get"+a+"AtOutCoords",o=t.texShape,r=s.shapeInfo.texShape,c=s.shapeInfo.logicalShape.length,i=t.logicalShape.length;if(!s.shapeInfo.isUniform&&c===i&&s.shapeInfo.flatOffset==null&&Ne(r,o))return`
      float ${n}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const l=pe(i),u=Ku(s.shapeInfo.logicalShape,t.logicalShape),d=i-c;let p;const h=["x","y","z","w","u","v"];c===0?p="":i<2&&u.length>=1?p="coords = 0;":p=u.map(x=>`coords.${h[x+d]} = 0;`).join(`
`);let f="";return i<2&&c>0?f="coords":f=s.shapeInfo.logicalShape.map((x,m)=>`coords.${h[m+d]}`).join(", "),`
    float ${n}() {
      ${l} coords = getOutputCoords();
      ${p}
      return get${a}(${f});
    }
  `}function pe(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error(`GPU for rank ${s} is not yet supported`)}function Ea(s,t,e){const{newShape:a,keptDims:n}=Ut(t),o=t.length,r=s&&o===3&&t[0]===1,c=r?t.slice(1):a,i=!s&&o>1&&!Ne(t,e)&&a.length<o||r;return{useSqueezeShape:i,uniformShape:i?c:t,keptDims:n}}function fn(s,t){const e=JSON.parse(JSON.stringify(s));return e.shapeInfo.logicalShape=t,e}function mn(s,t){return t.map(e=>s[e]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(s,t,e,a){const n=e.map((u,d)=>{const p={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(p.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),o=n.map(u=>u.shapeInfo),r={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},c=ZR(n,r,t),i=RR(s.gl,c),l=s.createProgram(i);return A().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:i,source:c,webGLProgram:l,inShapeInfos:o,outShapeInfo:r,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:i,source:c,webGLProgram:l,inShapeInfos:o,outShapeInfo:r},Zu(s,t,l))}function Zu(s,t,e){const a={},n={},o={},r=[];let c,i,l,u=null,d=null;d=s.getUniformLocation(e,"NAN",!1),A().getNumber("WEBGL_VERSION")===1&&(u=s.getUniformLocation(e,"INFINITY",!1));const p=!1;for(let h=0;h<t.variableNames.length;h++){const f=t.variableNames[h];a[f]=s.getUniformLocation(e,f,p),a[`offset${f}`]=s.getUniformLocation(e,`offset${f}`,p),t.enableShapeUniforms&&(n[`${f}Shape`]=s.getUniformLocation(e,`${f}Shape`,p),o[`${f}TexShape`]=s.getUniformLocation(e,`${f}TexShape`,p))}return t.enableShapeUniforms&&(c=s.getUniformLocation(e,"outShape",p),l=s.getUniformLocation(e,"outShapeStrides",p),i=s.getUniformLocation(e,"outTexShape",p)),t.customUniforms&&t.customUniforms.forEach((h,f)=>{r[f]=s.getUniformLocation(e,h.name,p)}),{uniformLocations:a,customUniformLocations:r,infLoc:u,nanLoc:d,inShapesLocations:n,inTexShapesLocations:o,outShapeLocation:c,outShapeStridesLocation:l,outTexShapeLocation:i}}function ro(s,t){if(s.length!==t.length)throw Error(`Binary was compiled with ${s.length} inputs, but was executed with ${t.length} inputs`);s.forEach((e,a)=>{const n=e.logicalShape,o=t[a],r=o.shape;if(!Ne(n,r))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n} and ${r} must match`);if(e.isUniform&&o.isUniform)return;const c=e.texShape,i=o.isUniform?null:o.texData.texShape;if(!Ne(c,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${c} and ${i} must match`)})}function PN(s,t,e,a,n){t.program.enableShapeUniforms||(ro(t.inShapeInfos,e),ro([t.outShapeInfo],[a]));const o=a.texData.texture,r=a.texData.texShape;a.texData.isPacked?s.setOutputPackedMatrixTexture(o.texture,r[0],r[1]):s.setOutputMatrixTexture(o.texture,r[0],r[1]),s.setProgram(t.webGLProgram),A().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&s.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&s.gl.uniform1f(t.nanLoc,NaN),e.forEach((i,l)=>{const u=t.program.variableNames[l],d=t.uniformLocations[u],p=t.uniformLocations[`offset${u}`],h=t.inShapesLocations[`${u}Shape`],f=t.inTexShapesLocations[`${u}TexShape`];if(h){const{uniformShape:x}=Ea(t.program.packedInputs,i.shape,i.texData.texShape);switch(x.length){case 1:s.gl.uniform1iv(h,new Int32Array(x));break;case 2:s.gl.uniform2iv(h,new Int32Array(x));break;case 3:s.gl.uniform3iv(h,new Int32Array(x));break;case 4:s.gl.uniform4iv(h,new Int32Array(x));break}}if(f&&s.gl.uniform2i(f,i.texData.texShape[0],i.texData.texShape[1]),d!=null){if(i.isUniform){if(Y(i.shape)<2)s.gl.uniform1f(d,i.uniformValues[0]);else{let x=i.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),s.gl.uniform1fv(d,x)}return}i.texData.slice!=null&&p!=null&&s.gl.uniform1i(p,i.texData.slice.flatOffset),s.setInputMatrixTexture(i.texData.texture.texture,d,l)}});const c=t.outShapeLocation;if(c)switch(a.shape.length){case 1:s.gl.uniform1iv(c,new Int32Array(a.shape));break;case 2:s.gl.uniform2iv(c,new Int32Array(a.shape));break;case 3:s.gl.uniform3iv(c,new Int32Array(a.shape));break;case 4:s.gl.uniform4iv(c,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){const i=je(a.shape);switch(a.shape.length){case 2:s.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(i));break;case 3:s.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(i));break;case 4:s.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(i));break}}t.outTexShapeLocation&&s.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&n&&t.program.customUniforms.forEach((i,l)=>{const u=t.customUniformLocations[l],d=n[l];if(i.type==="float")s.gl.uniform1fv(u,d);else if(i.type==="vec2")s.gl.uniform2fv(u,d);else if(i.type==="vec3")s.gl.uniform3fv(u,d);else if(i.type==="vec4")s.gl.uniform4fv(u,d);else if(i.type==="int")s.gl.uniform1iv(u,d);else if(i.type==="ivec2")s.gl.uniform2iv(u,d);else if(i.type==="ivec3")s.gl.uniform3iv(u,d);else if(i.type==="ivec4")s.gl.uniform4iv(u,d);else throw Error(`uniform type ${i.type} is not supported yet.`)}),s.executeProgram()}function _N(s,t,e){let a="";t.concat(e).forEach(r=>{const c=r.texData!=null&&r.texData.slice!=null&&r.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!r.isUniform){const i=r.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:d}=Ea(s.packedInputs,r.shape,i);let p="",h="",f="";if(u.length===1&&s.packedInputs){const I=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];p=`${I[0]>1}_${I[1]>1}`}else if(u.length===2&&!s.packedInputs)h=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!s.packedInputs){const I=je(u);f=`${I[0]===i[1]}_${I[I.length-1]===i[1]}`}const x=r.shape.length,m=u.length===2&&Ne(r.shape,i),g=Y(r.shape)===1,C=Ys(r.shape,e.shape),b=!s.packedInputs&&x===e.shape.length&&Ne(i,e.texData.texShape),$=s.packedInputs||u.length>2?"":`${i[0]>1}_${i[1]>1}`;a+=`${x}_${b}_${l?d:""}_${u.length}_${g}_${C}_${m}_${p}_${h}_${f}_${$}_${c}`}else{const i=r.isUniform?"uniform":r.texData.texShape;a+=`${r.shape}_${i}_${c}`}});const n=s.userCode;let o=s.constructor.name;return o+="_"+a+"_"+n+`${A().getNumber("WEBGL_VERSION")}`,o}function Fe(s){return A().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MN{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Rn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ee();this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ts(["r","c","d"],t):Gt(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LN{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Rn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ee();this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ts(["r","c","d"],t):Gt(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VN{constructor(t){this.variableNames=["A"],this.outTexUsage=ze.DOWNLOAD;const e=Ee();this.outputShape=t,this.userCode=`
      ${ju}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BN{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ze.DOWNLOAD;const e=Ee();this.outputShape=t,this.userCode=`
      ${ju}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WN{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=Ee();this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length);let n="result";e&&(n="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Ta():Na(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${a.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${a.output} = vec4(${n}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zN{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=Ee();this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length);let n="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let r=0;r<=1;r++)for(let c=0;c<=1;c++){const i=r*2+c;n+=`
          localCoords = coords;
          if(localCoords[2] + ${c} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${c};
          if (localCoords[1] + ${r} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${r};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${a.texture2D}(A, uv);

            if (offset == 0) {
              result[${i}] = values[0];
            } else if (offset == 1) {
              result[${i}] = values[1];
            } else if (offset == 2) {
              result[${i}] = values[2];
            } else {
              result[${i}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Ta():Na(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n}

          ${a.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(s){const t=Ee(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return kR(s,e)}function GN(s){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return FR(s,t)}function HN(s){const t=new Uint16Array([0,1,2,2,1,3]);return DR(s,t)}function Vn(s,t,e,a,n,o){AR(t,e);const r=OR(s),c=s.TEXTURE_2D;return q(s,()=>s.bindTexture(c,r)),q(s,()=>s.texParameteri(c,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),q(s,()=>s.texParameteri(c,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),q(s,()=>s.texParameteri(c,s.TEXTURE_MIN_FILTER,s.NEAREST)),q(s,()=>s.texParameteri(c,s.TEXTURE_MAG_FILTER,s.NEAREST)),A().getNumber("WEBGL_VERSION")===1?q(s,()=>s.texImage2D(c,0,a,t,e,0,n,o,null)):q(s,()=>s.texStorage2D(c,1,a,t,e)),q(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:r,texShape:[e,t]}}function Ju(s){return s.internalFormatFloat}function XN(s,t,e,a){const[n,o]=Mn(t,e);return Vn(s,n,o,Ju(a),a.textureFormatFloat,s.FLOAT)}function ed(s){return s.internalFormatHalfFloat}function qN(s,t,e,a){const[n,o]=Mn(t,e);return Vn(s,n,o,ed(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function td(s){return s.downloadTextureFormat}function jN(s,t,e,a){const[n,o]=Mn(t,e);return Vn(s,n,o,td(a),s.RGBA,s.UNSIGNED_BYTE)}function nd(s){return s.internalFormatPackedFloat}function KN(s,t,e,a){const[n,o]=dn(t,e);return Vn(s,n,o,nd(a),s.RGBA,s.FLOAT)}function sd(s){return s.internalFormatPackedHalfFloat}function YN(s,t,e,a){const[n,o]=dn(t,e);return Vn(s,n,o,sd(a),s.RGBA,a.textureTypeHalfFloat)}function QN(s,t,e){return q(s,()=>s.bindBuffer(s.ARRAY_BUFFER,e)),so(s,t,"clipSpacePos",e,3,20,0)&&so(s,t,"uv",e,2,20,12)}function ZN(s,t,e,a,n,o){q(s,()=>s.bindTexture(s.TEXTURE_2D,t));let r,c,i;n instanceof Uint8Array?(r=new Uint8Array(e*a*4),c=s.UNSIGNED_BYTE,i=s.RGBA):(r=new Float32Array(e*a*4),c=s.FLOAT,i=o.internalFormatPackedFloat),r.set(n),A().getNumber("WEBGL_VERSION")===2?q(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,e,a,s.RGBA,c,r)):q(s,()=>s.texImage2D(s.TEXTURE_2D,0,i,e,a,0,s.RGBA,c,r)),q(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function JN(s,t,e){q(s,()=>s.bindTexture(s.TEXTURE_2D,t)),e.data instanceof Uint8Array?A().getNumber("WEBGL_VERSION")===2?q(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,e.width,e.height,s.RGBA,s.UNSIGNED_BYTE,e.data)):q(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,e.width,e.height,0,s.RGBA,s.UNSIGNED_BYTE,e.data)):A().getNumber("WEBGL_VERSION")===2?q(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,e)):q(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,e)),q(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function e2(s,t,e,a){const n=s.createBuffer();q(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,n));const c=4*4*t*e;return q(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,c,s.STREAM_READ)),q(s,()=>s.readPixels(0,0,e,t,s.RGBA,s.FLOAT,0)),q(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),n}function t2(s,t,e){const a=s,n=new Float32Array(e);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,n),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),n}function n2(s,t,e,a){const[n,o]=Mn(t,e),r=4,c=new Uint8Array($R(t*e,r));return q(s,()=>s.readPixels(0,0,n,o,a.downloadTextureFormat,s.UNSIGNED_BYTE,c)),new Float32Array(c.buffer)}function s2(s,t,e,a,n,o,r,c){const i=s,l=new Float32Array(bR(o,r));return i.bindBuffer(i.PIXEL_PACK_BUFFER,t),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,l),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),l}function a2(s,t,e){const a=new Float32Array(t*e*4);return q(s,()=>s.readPixels(0,0,e,t,s.RGBA,s.FLOAT,a)),a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hs{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=A().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,gR(e,t)):this.gl=Je(e);let a="WEBGL_color_buffer_float";const n="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),A().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",r="OES_texture_half_float";if(this.textureFloatExtension=qn(this.gl,o),qe(this.gl,r))this.textureHalfFloatExtension=qn(this.gl,r);else if(A().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),qe(this.gl,n))this.colorBufferHalfFloatExtension=qn(this.gl,n);else if(A().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",qe(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else if(qe(this.gl,n))this.colorBufferHalfFloatExtension=this.gl.getExtension(n);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=GN(this.gl),this.indexBuffer=HN(this.gl),this.framebuffer=PR(this.gl),this.textureConfig=Ra(this.gl,this.textureHalfFloatExtension)}get debug(){return A().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;q(t,()=>t.finish()),q(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),q(t,()=>t.deleteFramebuffer(this.framebuffer)),q(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),q(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),q(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),XN(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),qN(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),jN(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),JN(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,a,n){this.throwIfDisposed(),ZN(this.gl,t,e,a,n,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),YN(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),KN(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(ao(this.gl,this.framebuffer),this.outputTexture=null),q(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,a){return this.downloadMatrixDriver(t,()=>n2(this.gl,e,a,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,a,n,o,r){return s2(this.gl,t,e,a,n,o,r,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return t2(this.gl,t,e)}createBufferFromTexture(t,e,a){this.bindTextureToFrameBuffer(t);const n=e2(this.gl,e,a,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,a;if(A().getBool("WEBGL_FENCE_API_ENABLED")){const n=t,o=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),a=()=>{const r=n.clientWaitSync(o,0,0);return r===n.ALREADY_SIGNALED||r===n.CONDITION_SATISFIED},e=o}else A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),a=()=>this.isQueryAvailable(e,A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):a=()=>!0;return{query:e,isFencePassed:a}}downloadMatrixFromPackedTexture(t,e,a){return this.downloadMatrixDriver(t,()=>a2(this.gl,e,a))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=UN(e));const a=TR(e);return q(e,()=>e.attachShader(a,this.vertexShader)),q(e,()=>e.attachShader(a,t)),ER(e,a),this.debug&&Bs(e,a),this.vertexAttrsAreBound||(this.setProgram(a),this.vertexAttrsAreBound=QN(e,this.program,this.vertexBuffer)),a}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&q(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Bs(this.gl,this.program),q(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,a=!0){return this.throwIfDisposed(),a?MR(this.gl,t,e):LR(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),q(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,a){this.throwIfDisposed(),this.throwIfNoProgram(),VR(this.gl,t,e,a)}setOutputMatrixTexture(t,e,a){this.setOutputMatrixTextureDriver(t,a,e)}setOutputPackedMatrixTexture(t,e,a){this.throwIfDisposed();const[n,o]=dn(e,a);this.setOutputMatrixTextureDriver(t,n,o)}setOutputMatrixWriteRegion(t,e,a,n){this.setOutputMatrixWriteRegionDriver(a,t,n,e)}setOutputPackedMatrixWriteRegion(t,e,a,n){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Bs(this.gl,this.program),jn(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),q(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=qn(this.gl,A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const a=this.gl,n=this.getQueryTimerExtensionWebGL2(),o=a.createQuery();return a.beginQuery(n.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,a=this.getQueryTimerExtensionWebGL2();e.endQuery(a.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await Ua(()=>this.disposed||this.isQueryAvailable(t,A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const a=this.gl;return a.getQueryParameter(t,a.QUERY_RESULT)/1e6}else{const a=this.getQueryTimerExtensionWebGL1();return a.getQueryObjectEXT(t,a.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const a=this.gl,n=this.getQueryTimerExtensionWebGL2(),o=a.getQueryParameter(t,a.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const a=this.getQueryTimerExtensionWebGL1(),n=a.getQueryObjectEXT(t,a.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=o2(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:a}=this.itemsToPoll[e];a()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let a;"setTimeoutCustom"in A().platform&&(a=A().platform.setTimeoutCustom.bind(A().platform)),Ua(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,a)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Ws(this.gl,t,this.framebuffer),this.debug&&jn(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ws(this.gl,this.outputTexture,this.framebuffer),this.debug&&jn(this.gl)):ao(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const a=e();return this.unbindTextureToFrameBuffer(),a}setOutputMatrixTextureDriver(t,e,a){this.throwIfDisposed();const n=this.gl;Ws(n,t,this.framebuffer),this.debug&&jn(n),this.outputTexture=t,q(n,()=>n.viewport(0,0,e,a)),q(n,()=>n.scissor(0,0,e,a))}setOutputMatrixWriteRegionDriver(t,e,a,n){this.throwIfDisposed(),q(this.gl,()=>this.gl.scissor(t,e,a,n))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function o2(s){let t=0;for(;t<s.length&&s[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:r2,bincountImpl:ad,bincountReduceImpl:i2,castImpl:c2,ceilImpl:l2,concatImpl:u2,equalImpl:d2,expImpl:p2,expm1Impl:h2,floorImpl:f2,gatherNdImpl:m2,gatherV2Impl:g2,greaterImpl:x2,greaterEqualImpl:C2,lessImpl:$2,lessEqualImpl:b2,linSpaceImpl:I2,logImpl:v2,maxImpl:y2,maximumImpl:w2,minimumImpl:S2,multiplyImpl:k2,negImpl:R2,notEqualImpl:N2,prodImpl:T2,raggedGatherImpl:E2,raggedTensorToTensorImpl:F2,rangeImpl:D2,rsqrtImpl:O2,scatterImpl:A2,sigmoidImpl:P2,simpleAbsImpl:od,sliceImpl:_2,sparseFillEmptyRowsImpl:M2,sparseReshapeImpl:L2,sparseSegmentReductionImpl:rd,sqrtImpl:V2,stridedSliceImpl:B2,stringNGramsImpl:W2,stringSplitImpl:z2,stringToHashBucketFastImpl:U2,subImpl:G2,tileImpl:H2,topKImpl:X2,transposeImpl:Fa,uniqueImpl:q2}=pb;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(s,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${s}.${e}`)}function Se(s,t){return t===1?[s]:id(s,t)}function j2(s,t){if(s===1)return"rc";let e="";for(let a=0;a<s;a++)e+=t[a],a<s-1&&(e+=",");return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K2{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Fe(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=Se("rc",this.rank),a=pe(this.rank),n=this.getOutOfBoundsCondition(e),o=this.getSetup(e),r=this.getOutput(e);this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${r}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let a=0;a<=1;a++)for(let n=0;n<=1;n++){let o=`${a===0?"r":"rp1"}, ${n===0?"c":"cp1"}`;for(let r=2;r<this.rank;r++)o=`${t[t.length-1-r]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let a=this.rank-2;a<this.rank;a++)e+=`${t[a]} >= ${this.enableShapeUniforms?`outShape[${a}]`:this.outputShape[a]}`,a<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),a=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${a};
      bool rEdge = rp1 >= ${n};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cd{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length);let a="";for(let n=0;n<4;n++){let o="thisRC = rc;";n%2===1&&(o+="thisRC.z += 1;"),n>1&&(o+="thisRC.y += 1;"),a+=`
        ${o}
        ${n>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${n>0?"}":""}
      `}this.userCode=`
      ${Y2(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Ta():Na(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${a}

        setOutput(result);
      }
    `}}function Y2(s,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?QR(["r","c","d"],"inputShape"):Gt(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q2{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,a){const n=co(e,a),o=lo(t,n,a);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const r=io(t,n,this.gpgpu.gl,this.gpgpu.textureConfig,a);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=r,this.log();const i=this.freeTextures[o].shift();return this.usedTextures[o].push(i),i}let c;return n===Ie.PACKED_2X2_FLOAT32?c=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):n===Ie.PACKED_2X2_FLOAT16?c=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):n===Ie.UNPACKED_FLOAT32?c=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):n===Ie.UNPACKED_FLOAT16?c=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):n===Ie.PACKED_4X1_UNSIGNED_BYTE&&(c=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(c),this.numUsedTextures++,this._numBytesAllocated+=r,this.log(),c}releaseTexture(t,e,a,n){if(this.freeTextures==null)return;const o=co(a,n),r=lo(e,o,n);r in this.freeTextures||(this.freeTextures[r]=[]);const c=io(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n),i=A().get("WEBGL_DELETE_TEXTURE_THRESHOLD");i!==-1&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=c):(this.freeTextures[r].push(t),this.numFreeTextures++,this._numBytesFree+=c),this.numUsedTextures--;const l=this.usedTextures[r],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Z2(s,t){const e=s;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===s.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function io(s,t,e,a,n){const o=J2(t,a);let r;if(n){const[i,l]=dn(s[0],s[1]);r=i*l}else{const[i,l]=Mn(s[0],s[1]);r=i*l}const c=Z2(e,o);return r*c}function J2(s,t){switch(s){case Ie.PACKED_2X2_FLOAT32:return nd(t);case Ie.PACKED_2X2_FLOAT16:return sd(t);case Ie.UNPACKED_FLOAT32:return Ju(t);case Ie.UNPACKED_FLOAT16:return ed(t);case Ie.PACKED_4X1_UNSIGNED_BYTE:return td(t);default:throw new Error(`Unknown physical texture type ${s}`)}}function eT(s){return A().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?Ie.PACKED_2X2_FLOAT32:Ie.UNPACKED_FLOAT32:s?Ie.PACKED_2X2_FLOAT16:Ie.UNPACKED_FLOAT16}function co(s,t){if(s===ze.UPLOAD)return Ie.PACKED_2X2_FLOAT32;if(s===ze.RENDER||s==null)return eT(t);if(s===ze.DOWNLOAD||s===ze.PIXELS)return Ie.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${s}`)}function lo(s,t,e){return`${s[0]}_${s[1]}_${t}_${e}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ut{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ke="if (isnan(x)) return x;",tT="return x;",uo="return abs(x);",nT="return (x >= 0.0) ? x : (exp(x) - 1.0);",sT=Ke+`
  return (x < 0.0) ? 0.0 : x;
`,aT=Ke+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jt="return x;",oT="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rT="return x;",iT=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,cT=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lT=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uT="return 1.0 / (1.0 + exp(-1.0 * x));";class _t{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dT{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length);const e=t.length,a=Se("rc",e),n=pe(e),o=j2(e,a),r=a.slice(-2),c=e<=1?"rc":`vec2(${r.join(",")})`;this.userCode=`
      void main() {
        ${n} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${c}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pT=Zr,hT=1e-7,fT=1e-4,Yn={};function mT(s){return s in Yn||(Yn[s]={}),Yn[s]}const gT=A().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),xT=600;function CT(){return A().global.screen==null?1024:A().global.screen.height*A().global.screen.width*window.devicePixelRatio*xT/1024/1024}class Es extends $c{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!A().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Hs)e=t;else{const a=Je(A().getNumber("WEBGL_VERSION"),t);e=new Hs(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const a=Je(A().getNumber("WEBGL_VERSION"));e=new Hs(a),this.binaryCache=mT(A().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Q2(this.gpgpu),this.numMBBeforeWarning=CT(),this.texData=new Li(this,At())}nextDataId(){return Es.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,a){if((A().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||A().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const n={id:this.nextDataId()};return this.texData.set(n,{shape:e,dtype:a,values:t,usage:ze.UPLOAD,refCount:1}),n}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,a,n,o){if(A().getBool("DEBUG")&&this.checkNumericalProblems(e),n==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:n,values:e,usage:ze.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:a,dtype:n,complexTensorInfos:o,slice:r,shape:c,isPacked:i}=e;if(r!=null){let p;i?p=new _t(c,jt):p=new ut(c,jt);const h=this.runWebGLProgram(p,[{dataId:t,shape:c,dtype:n}],n),f=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),f}if(a!=null)return this.convertAndCacheOnCPU(t);if(n==="string")return a;const l=this.activeTimers!=null;let u;l&&(u=Dt());let d;if(n==="complex64"){const p=this.readSync(o.real.dataId),h=this.readSync(o.imag.dataId);d=Ha(p,h)}else d=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=Dt()-u),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(x=>f.push(x))}const e=this.texData.get(t),{values:a,shape:n,slice:o,dtype:r,complexTensorInfos:c,isPacked:i}=e;if(o!=null){let f;i?f=new _t(n,jt):f=new ut(n,jt);const x=this.runWebGLProgram(f,[{dataId:t,shape:n,dtype:r}],r),m=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),m}if(a!=null)return this.convertAndCacheOnCPU(t);if(A().getBool("DEBUG")&&!A().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&A().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,u;if(r!=="complex64"&&A().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const f=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...Xn(n))}this.pendingRead.set(t,[]),r!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(r==="complex64"){const f=await Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)]),x=f[0],m=f[1];d=Ha(x,m)}else if(l==null)d=this.getValuesFromTexture(t);else{const f=Y(n);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),l!=null){const f=this.gpgpu.gl;q(f,()=>f.deleteBuffer(l))}const p=this.convertAndCacheOnCPU(t,d),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(f=>f(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&At().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,e={}){const a=this.texData.get(t),{values:n,shape:o,slice:r,dtype:c,isPacked:i,texture:l}=a;if(c==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(r!=null){let h;i?h=new _t(o,jt):h=new ut(o,jt);const f=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:c}],c),x=this.readToGPU(f,e);return this.disposeIntermediateTensorInfo(f),x}if(l==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(t,e.customTexShape),d=At().makeTensorFromTensorInfo(u),p=this.texData.get(u.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const a=e.map(n=>xa(n));return Ve(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ve(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const a=t[e];if(!wR(a))throw A().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:a,isPacked:n}=this.texData.get(t),o=Y(e);if(A().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(t),h=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Xn(e)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),f}const r=A().getBool("WEBGL_PACK")&&n===!0,c=r?zs(e):e,i=r?new BN(c):new VN(c),l=this.runWebGLProgram(i,[{shape:c,dtype:a,dataId:t}],"float32"),u=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,a=[];let n=!1;this.programTimersStack==null?(this.programTimersStack=a,n=!0):this.activeTimers.push(a),this.activeTimers=a,t();const o=ss(this.activeTimers.map(i=>i.query)).filter(i=>i!=null),r=ss(this.activeTimers.map(i=>i.name)).filter(i=>i!=null);this.activeTimers=e,n&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const i=await Promise.all(o);c.kernelMs=LC(i),c.getExtraProfileInfo=()=>i.map((l,u)=>({name:r[u],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Dt(),endMs:null}}endTimer(t){return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Dt(),t)}async getQueryTime(t){if(A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,e),this.disposeData(a.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:a,texShape:n,usage:o,isPacked:r,slice:c}=this.texData.get(t),i=c&&c.origDataId||t,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),e!=null&&(this.numBytesInGPU-=this.computeBytes(n,a),this.textureManager.releaseTexture(e,n,o,r)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=gT){return A().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&Y(a.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Cs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return pT(t.shape,e)}packedUnaryOp(t,e,a){const n=new _t(t.shape,e),o=this.compileAndRun(n,[t],a);return At().makeTensorFromTensorInfo(o)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const n=od(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,n)}if(A().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,uo,t.dtype);const e=new ut(t.shape,uo),a=this.compileAndRun(e,[t]);return At().makeTensorFromTensorInfo(a)}makeTensorInfo(t,e,a){let n;if(e==="string"&&a!=null&&a.length>0&&In(a[0])){const o=a.map(r=>Ur(r));n=this.write(o,t,e)}else n=this.write(a,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e,a){return At().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,a),this)}unpackTensor(t){const e=new dT(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new K2(t.shape),a=!0;return this.runWebGLProgram(e,[t],t.dtype,null,a)}packedReshape(t,e){const a=[nn(t.shape),...sn(t.shape)],n={dtype:t.dtype,shape:a,dataId:t.dataId},o=[nn(e),...sn(e)],r=new cd(o,a),c=!0,i=[a],l=this.runWebGLProgram(r,[n],t.dtype,i,c);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){const a=this.texData.get(t),{isPacked:n,shape:o,dtype:r}=a;if(e!=null){const p=Y(o),h=e[0]*e[1]*4;ae(p<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const c=zs(o);let i;n?i=new LN(c):i=new MN(c);const l=!0,u=[e??Xn(c)],d=this.runWebGLProgram(i,[{shape:c,dtype:r,dataId:t}],r,u,l,e);return{dtype:r,shape:o,dataId:d.dataId}}runWebGLProgram(t,e,a,n,o=!1,r){const c=this.makeTensorInfo(t.outputShape,a),i=this.texData.get(c.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===Rn.DENSE){const g=r??Xn(t.outputShape);i.texShape=g.map(C=>C*2)}if(t.outTexUsage!=null&&(i.usage=t.outTexUsage),Y(c.shape)===0)return i.values=yt(c.dtype,0),c;const l=[],u=e.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(g.dataId);if(C.texture==null){if(!t.packedInputs&&Y(g.shape)<=A().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:C.values};t.packedInputs&&(C.isPacked=!0,C.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!C.isPacked!=!!t.packedInputs)g=C.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),C=this.texData.get(g.dataId);else if(C.isPacked&&!ls(C.shape,g.shape)){const b=g,$=g.shape;g.shape=C.shape,g=this.packedReshape(g,$),l.push(g),C=this.texData.get(g.dataId),b.shape=$}return{shape:g.shape,texData:C,isUniform:!1}});this.uploadToGPU(c.dataId);const d={shape:c.shape,texData:i,isUniform:!1},p=_N(t,u,d),h=this.getAndSaveBinary(p,()=>AN(this.gpgpu,t,u,d)),f=this.activeTimers!=null;let x;f&&(x=this.startTimer()),A().get("ENGINE_COMPILE_ONLY")||PN(this.gpgpu,h,u,d,n),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(x=this.endTimer(x),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(x)}));const m=A().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const g=Dt();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!A().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&o===!1){const g=this.unpackTensor(c);return this.disposeIntermediateTensorInfo(c),g}return c}compileAndRun(t,e,a,n,o=!1){return a=a||e[0].dtype,this.runWebGLProgram(t,e,a,n,o)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(A().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=xe(()=>{if(!A().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=A().getBool("DEBUG");A().set("DEBUG",!1);const e=this.abs(dt(1e-8)).dataSync()[0];if(A().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?hT:fT}uploadToGPU(t){const e=this.texData.get(t),{shape:a,dtype:n,values:o,texture:r,usage:c,isPacked:i}=e;if(r!=null)return;const l=this.activeTimers!=null;let u;l&&(u=Dt());let d=e.texShape;if(d==null&&(d=zR(a,i),e.texShape=d),o!=null){const p=zs(a);let h,f=d[1],x=d[0];const m=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(i||!m)&&([f,x]=dn(d[0],d[1])),i?h=new zN(p,m):h=new WN(p,m);const g=m?[x,f]:d,C=this.makeTensorInfo(g,n),b=this.texData.get(C.dataId);m?b.usage=ze.PIXELS:b.usage=ze.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),f,x,o);const $=[[x,f]],I=!0,v=this.runWebGLProgram(h,[C],n,$,I),y=this.texData.get(v.dataId);e.texShape=y.texShape,e.isPacked=y.isPacked,e.usage=y.usage,A().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(e.texture=y.texture,e.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(C),l&&(this.uploadWaitMs+=Dt()-u)}else{const p=this.acquireTexture(d,c,n,i);e.texture=p}}convertAndCacheOnCPU(t,e){const a=this.texData.get(t),{dtype:n}=a;return this.releaseGPUData(t),e!=null&&(a.values=$T(e,n)),a.values}acquireTexture(t,e,a,n){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,n)}computeBytes(t,e){return t[0]*t[1]*VC(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const a=new Promise(n=>{try{this.checkCompletion_(e),n(!0)}catch(o){throw o}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await bu(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(qu(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,t]of Object.entries(this.binaryCache)){const{uniformLocations:e,customUniformLocations:a,infLoc:n,nanLoc:o,inShapesLocations:r,inTexShapesLocations:c,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}=Zu(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=a,t.infLoc=n,t.nanLoc=o,t.inShapesLocations=r,t.inTexShapesLocations=c,t.outShapeLocation=i,t.outShapeStridesLocation=l,t.outTexShapeLocation=u}}}Es.nextDataId=0;function $T(s,t){if(t==="float32"||t==="complex64")return s;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let a=0;a<e.length;++a)e[a]=Math.round(s[a]);return e}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */BC()&&ru("webgl",()=>new Es,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Da=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class an{constructor(t,e,a){this.variableNames=["A","B"],this.outputShape=_e(e,a),this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Wn{constructor(t,e,a,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_e(e,a);const o=this.outputShape.length;this.enableShapeUniforms=Fe(o);let r="";if(n)if(o===0||Y(this.outputShape)===1)r=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(r=`
          ${pe(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?r+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:r+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const i=Se("coords",o);this.enableShapeUniforms?r+=`
            bool nextRowOutOfBounds =
              (${i[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${i[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:r+=`
            bool nextRowOutOfBounds =
              (${i[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${i[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${r}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(s){const{inputs:t,backend:e}=s,{x:a}=t;return e.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const bT={kernelName:fc,backendName:"webgl",kernelFunc:Be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(s){const{inputs:t,backend:e}=s,{real:a,imag:n}=t,o=e.makeTensorInfo(a.shape,"complex64"),r=e.texData.get(o.dataId),c=Be({inputs:{x:a},backend:e}),i=Be({inputs:{x:n},backend:e});return r.complexTensorInfos={real:c,imag:i},o}const IT={kernelName:wi,backendName:"webgl",kernelFunc:Et};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ld="return (a < 0.) ? b * a : a;",ud=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function vT(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{alpha:o}=a,r=e.makeTensorInfo([],"float32",cn(o,"float32")),c=A().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wn(ud,n.shape,r.shape):new an(ld,n.shape,r.shape),i=e.runWebGLProgram(c,[n,r],"float32");return e.disposeIntermediateTensorInfo(r),i}const yT={kernelName:vc,backendName:"webgl",kernelFunc:vT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dd="return (a < 0.) ? b * a : a;",pd=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wT(s){const{inputs:t,backend:e}=s,{x:a,alpha:n}=t,o=A().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wn(pd,a.shape,n.shape):new an(dd,a.shape,n.shape);return e.runWebGLProgram(o,[a,n],"float32")}const ST={kernelName:tl,backendName:"webgl",kernelFunc:wT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gn="if (isnan(x)) return x;";function se({opSnippet:s,packedOpSnippet:t,cpuKernelImpl:e,dtype:a}){return({inputs:n,backend:o})=>{const{x:r}=n,c=o,i=a||r.dtype;if(c.shouldExecuteOnCPU([r])&&e!=null){const d=c.texData.get(r.dataId),p=e(d.values,i);return c.makeTensorInfo(r.shape,i,p)}const l=A().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let u;return l?u=new _t(r.shape,t):u=new ut(r.shape,s),c.runWebGLProgram(u,[r],i)}}function ve({opSnippet:s,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:a=!1,cpuKernelImpl:n,dtype:o}){return({inputs:r,backend:c})=>{const{a:i,b:l}=r,u=c;if(a&&i.dtype==="complex64"){const f=u.texData.get(i.dataId),x=u.texData.get(l.dataId),[m,g]=[[f.complexTensorInfos.real,x.complexTensorInfos.real],[f.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(b=>{const[$,I]=b,v={dataId:$.dataId,dtype:$.dtype,shape:i.shape},y={dataId:I.dataId,dtype:I.dtype,shape:l.shape},w=new an(s,i.shape,l.shape);return u.runWebGLProgram(w,[v,y],vt($.dtype,I.dtype))}),C=Et({inputs:{real:m,imag:g},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(g),C}const d=o||vt(i.dtype,l.dtype);if((i.dtype==="string"||l.dtype==="string"||u.shouldExecuteOnCPU([i,l]))&&n!=null){const f=u.texData.get(i.dataId).values,x=u.texData.get(l.dataId).values,m=i.dtype==="string"?Xa(f):f,g=i.dtype==="string"?Xa(x):x,[C,b]=n(i.shape,l.shape,m,g,d),$=u.makeTensorInfo(b,d),I=u.texData.get($.dataId);return I.values=C,$}const p=A().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let h;return p?h=new Wn(t,i.shape,l.shape,e):h=new an(s,i.shape,l.shape),u.runWebGLProgram(h,[i,l],d)}}function Nn(s,t=!1){if(s==="linear")return t?rT:tT;if(s==="relu")return t?cT:sT;if(s==="elu")return t?iT:nT;if(s==="relu6")return t?lT:aT;if(s==="prelu")return t?pd:dd;if(s==="leakyrelu")return t?ud:ld;if(s==="sigmoid")return t?uT:oT;throw new Error(`Activation ${s} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hd{constructor(t,e,a,n=!1,o=!1,r=!1,c=null,i=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=Fe(this.outputShape.length);const u=n?t[1]:t[2],d=Math.ceil(u/2),p=n?"i * 2, rc.y":"rc.y, i * 2",h=o?"rc.z, i * 2":"i * 2, rc.z",f=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";c&&(i?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${c}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${c}
        }`:m=`vec4 activation(vec4 x) {
          ${c}
        }`,g="result = activation(result);");const C=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",$="rc.x";t[0]<e[0]?b=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&($=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${b};
          int batchB = ${$};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${x[0]});
          result += (${f[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${C}

        ${g}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const po={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class ho{constructor(t,e,a){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_e(e,a),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo="return a * b;";function Oa(s){const{inputs:t,backend:e}=s,{a,b:n}=t,o=vt(a.dtype,n.dtype);if(a.dtype==="complex64"){const c=e.texData.get(a.dataId),i=e.texData.get(n.dataId),l=new ho(po.REAL,a.shape,n.shape),u=new ho(po.IMAG,a.shape,n.shape),d=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:a.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape}],p=e.runWebGLProgram(l,d,"float32"),h=e.runWebGLProgram(u,d,"float32"),f=Et({inputs:{real:p,imag:h},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),f}if(e.shouldExecuteOnCPU([a,n])){const c=e.texData.get(a.dataId),i=e.texData.get(n.dataId),[l,u]=k2(a.shape,n.shape,c.values,i.values,o),d=e.makeTensorInfo(u,o),p=e.texData.get(d.dataId);return p.values=l,d}let r;return A().getBool("WEBGL_PACK_BINARY_OPERATIONS")?r=new Wn(fo,a.shape,n.shape):r=new an(fo,a.shape,n.shape),e.runWebGLProgram(r,[a,n],o)}const kT={kernelName:Gc,backendName:"webgl",kernelFunc:Oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RT(s,t,e){const a=[nn(s.shape),...sn(s.shape)],n={dtype:s.dtype,shape:a,dataId:s.dataId},o=[nn(t),...sn(t)],r=new cd(o,a),c=!0,i=[a],l=e.runWebGLProgram(r,[n],s.dtype,i,c);return{dataId:l.dataId,shape:t,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{shape:o}=a,r=e,c=Y(n.shape),i=WC(o,c),l=Y(i);ae(c===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${n.shape}) has ${c} elements. The new shape and old shape must have the same number of elements.`);const u=r.texData.get(n.dataId);return u.isPacked&&!ls(n.shape,i)&&!(u.texture!==null&&ls(u.shape,i))?RT(n,i,r):(r.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype})}const NT={kernelName:dl,backendName:"webgl",kernelFunc:U};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mo{constructor(t,e){this.variableNames=["x"];const{windowSize:a,batchSize:n,inSize:o,outSize:r}=t;this.outputShape=[n,r];const c=Math.floor(a/4)*4,i=a%4;let l="sumValue += dot(values, ones);";if(e!=null){const d=1/e;l=`sumValue += dot(values * ${zC(d)?d.toPrecision(2):d}, ones);`}let u="";o%a>0&&(u=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${c};
        if (${i===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${i===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${i===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TT{constructor(t,e){this.variableNames=["x"];const{windowSize:a,batchSize:n,inSize:o,outSize:r}=t;this.outputShape=[n,r];let c="0.0",i="";e==="prod"?c="1.0":e==="min"?(c="1.0 / 1e-20",i="min"):e==="max"&&(c="-1.0 / 1e-20",i="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");const u=Math.floor(a/4)*4,d=a%4;let p=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${i}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${i}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";e==="all"?(c="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):e==="any"&&(c="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let f="";o%a>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${c};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        vec4 minMaxValue = vec4(${c});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ET(s){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:s[1],a=$a(e);t.push({inSize:e,windowSize:a,outSize:Math.ceil(e/a)})}return t}function Xt(s,t,e,a){const n=ET(s.shape);let o=s;for(let r=0;r<n.length;r++){const{inSize:c,windowSize:i,outSize:l}=n[r];let u,d;e==="mean"?u=r===0?new mo({windowSize:i,inSize:c,batchSize:s.shape[0],outSize:l},c):new mo({windowSize:i,inSize:c,batchSize:s.shape[0],outSize:l}):u=new TT({windowSize:i,inSize:c,batchSize:s.shape[0],outSize:l},e),d=o,o=a.runWebGLProgram(u,[o],t),d.dataId!==s.dataId&&a.disposeIntermediateTensorInfo(d)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FT{constructor(t,e){this.variableNames=["A"];const a=new Array(t.length);for(let r=0;r<a.length;r++)a[r]=t[e[r]];this.outputShape=a,this.rank=a.length;const n=pe(this.rank),o=DT(e);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function DT(s){const t=s.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let n=0;n<s.length;n++)a[s[n]]=e[n];return a.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OT{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const a=new Array(t.length);for(let u=0;u<a.length;u++)a[u]=t[e[u]];if(this.outputShape=a,this.rank=a.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const n=pe(this.rank),o=id("rc",this.rank),r=new Array(this.rank);for(let u=0;u<e.length;u++)r[e[u]]=o[u];const c=`vec2(${r.slice(-2).join()})`,i=`++${o[this.rank-1]} < ${a[this.rank-1]}`,l=`getChannel(getA(${r.join()}), ${c})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${i}) {
        result[1] = ${l};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${a[this.rank-2]}) {
        result[2] = ${l};
        if(${i}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fs(s,t,e){const a=A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OT(s.shape,t):new FT(s.shape,t);return e.runWebGLProgram(a,[s],s.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(s,t,e,a){const n=t,o=s.shape.length,r=Ae(n,s.shape);let c=r;const i=et(c,o),l=i!=null;let u=s;l&&(u=Fs(s,i,a),c=tt(c.length,o)),it("sum",c,o);const[d,p]=ht(u.shape,c);let h=d;e&&(h=St(d,r));const f=Y(p),m=Y(s.shape)/f,g=U({inputs:{x:u},attrs:{shape:[m,f]},backend:a}),C=xs(s.dtype),b=Xt(g,C,"sum",a),$=U({inputs:{x:b},attrs:{shape:h},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),l&&a.disposeIntermediateTensorInfo(u),$}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a;return AT(n,o,r,e)}const PT={kernelName:ql,backendName:"webgl",kernelFunc:Ds};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Te(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{perm:o}=a,r=e,c=n.shape.length,i=new Array(c);for(let u=0;u<i.length;u++)i[u]=n.shape[o[u]];let l;if(r.shouldExecuteOnCPU([n])){const d=r.texData.get(n.dataId).values,p=Fa(d,n.shape,n.dtype,o,i);l=r.makeTensorInfo(i,n.dtype);const h=r.texData.get(l.dataId);h.values=p}else l=Fs(n,o,r);return l}const _T={kernelName:Jl,backendName:"webgl",kernelFunc:Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fd=1e3;function us({a:s,b:t,transposeA:e,transposeB:a,backend:n,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:c=0,activation:i=null}){const l=s.shape.length,u=t.shape.length,d=e?s.shape[l-2]:s.shape[l-1],p=a?t.shape[u-1]:t.shape[u-2],h=e?s.shape[l-1]:s.shape[l-2],f=a?t.shape[u-2]:t.shape[u-1],x=s.shape.slice(0,-2),m=t.shape.slice(0,-2),g=Y(x),C=Y(m),$=_e(s.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);ae(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${s.shape} and ${t.shape} and transposeA=${e} and transposeB=${a} must match.`);const I=e?[g,d,h]:[g,h,d],v=a?[C,f,p]:[C,p,f],y=U({inputs:{x:s},backend:n,attrs:{shape:I}}),w=U({inputs:{x:t},backend:n,attrs:{shape:v}}),k=[y,w],S=Math.max(g,C),E=e?y.shape[1]:y.shape[2],O=o!=null,F=r!=null,D=i==="leakyrelu",N=i!=null?Nn(i,!0):null,T=O||F||D||N!=null;let _;if((h===1||f===1)&&E>fd&&T===!1){let P=y,L=w;e&&(P=Te({inputs:{x:y},backend:n,attrs:{perm:[0,2,1]}}),k.push(P)),a&&(L=Te({inputs:{x:w},backend:n,attrs:{perm:[0,2,1]}}),k.push(L));const M=f!==1,W=f===1;let V=P;M&&(V=U({inputs:{x:P},backend:n,attrs:{shape:[S,E,1]}}),k.push(V));const z=f===1?2:1;let B=L;W&&(B=U({inputs:{x:L},backend:n,attrs:{shape:[S,1,E]}}),k.push(B));const G=Oa({inputs:{a:V,b:B},backend:n});_=Ds({inputs:{x:G},backend:n,attrs:{axis:z,keepDims:!0}}),k.push(G)}else{const P=vt(s.dtype,t.dtype),L=new hd(I,v,[S,h,f],e,a,O,N,F,D),M=[y,w];if(o!=null&&M.push(o),F&&M.push(r),D){const W=n.makeTensorInfo([],"float32",cn(c,"float32"));M.push(W),k.push(W)}_=n.runWebGLProgram(L,M,P)}const R=U({inputs:{x:_},backend:n,attrs:{shape:$}});k.push(_);for(const P of k)n.disposeIntermediateTensorInfo(P);return R}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(s){const{inputs:t,backend:e,attrs:a}=s,{a:n,b:o,bias:r,preluActivationWeights:c}=t,{transposeA:i,transposeB:l,activation:u,leakyreluAlpha:d}=a;return us({a:n,b:o,transposeA:i,transposeB:l,backend:e,bias:r,preluActivationWeights:c,leakyreluAlpha:d,activation:u})}const LT={kernelName:au,backendName:"webgl",kernelFunc:MT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go="return abs(x);";function VT(s){const{inputs:t,backend:e}=s,{x:a}=t;if(e.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){const o=e.texData.get(a.dataId),r=od(o.values);return e.makeTensorInfo(a.shape,a.dtype,r)}let n;return A().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new _t(a.shape,go):n=new ut(a.shape,go),e.runWebGLProgram(n,[a],a.dtype)}const BT={kernelName:Jr,backendName:"webgl",kernelFunc:VT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WT=Ke+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,zT=se({opSnippet:WT}),UT={kernelName:ei,backendName:"webgl",kernelFunc:zT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GT=Ke+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,HT=se({opSnippet:GT}),XT={kernelName:ti,backendName:"webgl",kernelFunc:HT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xo="return a + b;",qT=ve({opSnippet:xo,packedOpSnippet:xo,supportsComplex:!0,cpuKernelImpl:r2}),jT={kernelName:ni,backendName:"webgl",kernelFunc:qT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KT{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,r)=>`T${r}`);const a=[];this.variableNames.forEach(o=>{a.push(`float v${o} = get${o}AtOutCoords();`)});const n=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        float result = ${n};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YT{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,r)=>`T${r}`);const a=[];this.variableNames.forEach(o=>{a.push(`vec4 v${o} = get${o}AtOutCoords();`)});const n=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        vec4 result = ${n};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function es(s){const{inputs:t,backend:e}=s,a=t;if(a.length===1)return Be({inputs:{x:a[0]},backend:e});if(a.length>A().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const i=Math.floor(a.length/2),l=es({inputs:a.slice(0,i),backend:e}),u=es({inputs:a.slice(i),backend:e});return es({inputs:[l,u],backend:e})}const n=a.map(i=>i.dtype).reduce((i,l)=>vt(i,l)),o=a.map(i=>i.shape),c=A().getBool("WEBGL_PACK")?new YT(a[0].shape,o):new KT(a[0].shape,o);return e.runWebGLProgram(c,a,n)}const QT={kernelName:si,backendName:"webgl",kernelFunc:es};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a,c=n.shape.length,i=Ae(o,n.shape);let l=i;const u=et(l,c);let d=n;u!=null&&(d=Te({inputs:{x:n},backend:e,attrs:{perm:u}}),l=tt(l.length,c)),it("all",l,c);const[p,h]=ht(d.shape,l),f=Y(h),x=U({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}}),m=Xt(x,x.dtype,"all",e);let g;if(r){const C=St(p,i);g=U({inputs:{x:m},backend:e,attrs:{shape:C}})}else g=U({inputs:{x:m},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(d),g}const JT={kernelName:ai,backendName:"webgl",kernelFunc:ZT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a,c=n.shape.length,i=Ae(o,n.shape);let l=i;const u=et(l,c);let d=n;u!=null&&(d=Te({inputs:{x:n},backend:e,attrs:{perm:u}}),l=tt(l.length,c)),it("any",l,c);const[p,h]=ht(d.shape,l),f=Y(h),x=U({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}}),m=Xt(x,x.dtype,"any",e);let g;if(r){const C=St(p,i);g=U({inputs:{x:m},backend:e,attrs:{shape:C}})}else g=U({inputs:{x:m},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(d),g}const tE={kernelName:oi,backendName:"webgl",kernelFunc:eE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nE{constructor(t,e,a){this.variableNames=["A"];const{windowSize:n,batchSize:o,outSize:r}=t;a||this.variableNames.push("bestIndicesA"),this.outputShape=[o,r];const c=e==="max"?">":"<",i=a?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${i};
          float candidate = getA(batch, inIdx);
          if (candidate ${c} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sE{constructor(t,e,a,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ae(t.length>2,()=>`Packed arg${a.charAt(0).toUpperCase()+a.slice(1)} supports only inputs with rank above 2.`);const o=t[t.length-1],r=Math.ceil(o/e);this.outputShape=t.slice(0,-1),r>1&&this.outputShape.push(r),n||this.variableNames.push("bestIndicesA");const c=this.outputShape,i=c.length,l=pe(i),u=Se("coords",i);let d,p;if(r===1){p=i+1;const w=pe(p);d=`
        ${w} sourceLocR = ${w}(${u.join()}, 0);
        ++${u[i-1]};
        ${w} sourceLocG = ${w}(${u.join()}, 0);
        ++${u[i-2]};
        ${w} sourceLocA = ${w}(${u.join()}, 0);
        --${u[i-1]};
        ${w} sourceLocB = ${w}(${u.join()}, 0);
        --${u[i-2]};`}else p=i,d=`
        ${l} sourceLocR = coords;
        ++${u[i-1]};
        ${l} sourceLocG = coords;
        ++${u[i-2]};
        ${l} sourceLocA = coords;
        --${u[i-1]};
        ${l} sourceLocB = coords;
        --${u[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],x=h.map(w=>"int "+w),m=Se("sourceLocR",p-1).concat("inIdx.r"),g=Se("sourceLocG",p-1).concat("inIdx.g"),C=Se("sourceLocB",p-1).concat("inIdx.b"),b=Se("sourceLocA",p-1).concat("inIdx.a"),$=a==="max"?"greaterThan":"lessThan",I=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${C.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,y=n?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${y}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[i-1]} < ${c[i-1]-1};
        bool hasNextRow = ${u[i-2]} < ${c[i-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function md(s,t,e,a=null){let n=t.shape[0],o=t.shape[1];a!=null&&(n=a.shape[0],o=a.shape[1]);const r=$a(o),c={windowSize:r,inSize:o,batchSize:n,outSize:Math.ceil(o/r)},i=new nE(c,e,a==null),l=[t];a!=null&&l.push(a);const u=s.runWebGLProgram(i,l,"int32");if(u.shape[1]===1)return u;const d=md(s,t,e,u);return s.disposeIntermediateTensorInfo(u),d}function gd(s,t,e,a=null){const n=a!=null?a.shape:t.shape,o=n[n.length-1],r=$a(o),c=new sE(n,r,e,a==null),i=a==null?[t]:[t,a],l=s.runWebGLProgram(c,i,"int32");if(l.shape.length===t.shape.length){const u=gd(s,t,e,l);return s.disposeIntermediateTensorInfo(l),u}return l}function xd(s,t,e,a){const n=[e];if(it("arg"+a.charAt(0).toUpperCase()+a.slice(1),n,t.shape.length),!A().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],r=s.texData.get(t.dataId),c=r!==null&&r.isPacked;let i=t;c&&(i=s.unpackTensor(t),o.push(i));const[l,u]=ht(i.shape,n),d=Y(u),p=U({inputs:{x:i},backend:s,attrs:{shape:[-1,d]}});o.push(p);const h=md(s,p,a);o.push(h);const f=U({inputs:{x:h},backend:s,attrs:{shape:l}});return o.forEach(x=>s.disposeIntermediateTensorInfo(x)),f}return gd(s,t,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o}=a;let r=Ae(o,n.shape);const c=et(r,n.shape.length);let i=n;const l=[];c!=null&&(i=Te({inputs:{x:n},backend:e,attrs:{perm:c}}),l.push(i),r=tt(r.length,i.shape.length)),it("argMax",[r[0]],i.shape.length);const u=xd(e,i,r[0],"max");return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}const oE={kernelName:ri,backendName:"webgl",kernelFunc:aE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o}=a;let r=Ae(o,n.shape);const c=et(r,n.shape.length);let i=n;const l=[];c!=null&&(i=Te({inputs:{x:n},backend:e,attrs:{perm:c}}),l.push(i),r=tt(r.length,i.shape.length)),it("argMin",[r[0]],i.shape.length);const u=xd(e,i,r[0],"min");return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}const iE={kernelName:ii,backendName:"webgl",kernelFunc:rE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE=Ke+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,lE=se({opSnippet:cE}),uE={kernelName:ci,backendName:"webgl",kernelFunc:lE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE=Ke+"return log(x + sqrt(x * x + 1.0));",pE=se({opSnippet:dE}),hE={kernelName:li,backendName:"webgl",kernelFunc:pE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fE=Ke+`
  return atan(x);
`,mE=se({opSnippet:fE}),gE={kernelName:ui,backendName:"webgl",kernelFunc:mE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xE=Da+`
  return atan(a, b);
`,CE=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bn+`
  return result;
`,$E=ve({opSnippet:xE,packedOpSnippet:CE}),bE={kernelName:di,backendName:"webgl",kernelFunc:$E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE=Ke+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,vE=se({opSnippet:IE}),yE={kernelName:pi,backendName:"webgl",kernelFunc:vE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tn{constructor(t,e,a,n=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&a)throw new Error("Cannot compute positions for average pool.");const r=t.filterWidth,c=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,h=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const x=e==="avg",m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let C="0.0";if(x||(C="-1.0 / 1e-20"),a){const w=">=";this.userCode=`
        const ivec2 strides = ivec2(${c}, ${i});
        const ivec2 pads = ivec2(${h}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${w} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?o?m:g:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let $=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&($="avgValue / count");const I=Math.floor(r/4)*4,v=r%4,y=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${c}, ${i});
      const ivec2 pads = ivec2(${h}, ${f});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${y}
          }

          int xC = xCCorner + ${I};
          if (${v===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${y}
          } else if (${v===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${y}
          } else if (${v===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${y}
          }
        }
        setOutput(${$});
      }
    `}}class Aa{constructor(t,e,a,n=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&a)throw new Error("Cannot compute positions for average pool.");const r=t.filterWidth,c=t.strideDepth,i=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,p=t.dilationWidth,h=t.effectiveFilterDepth,f=t.effectiveFilterHeight,x=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,C=t.padInfo.left;this.outputShape=t.outShape;const b=e==="avg";let $="0.0";if(b||($="-1.0 / 1e-20"),a){const S=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${c}, ${i}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${C});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${S} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(v="avgValue / count");const y=Math.floor(r/4)*4,w=r%4,k=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${c}, ${i}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${C});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${k}
            }

            int xC = xCCorner + ${y};
            if (${w===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${w===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${w===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${k}
            }
          }
          setOutput(${v});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t;Ln(n,"avgPool");const{filterSize:o,strides:r,pad:c,dimRoundingMode:i}=a,l=1;ae(On(r,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const u=An(n.shape,o,r,l,c,i);if(u.filterWidth===1&&u.filterHeight===1&&Ne(u.inShape,u.outShape))return Be({inputs:{x:n},backend:e});const d=new Tn(u,"avg",!1);return e.runWebGLProgram(d,[n],"float32")}const SE={kernelName:hi,backendName:"webgl",kernelFunc:wE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{filterSize:o,strides:r,pad:c,dimRoundingMode:i,dataFormat:l}=a,u=[1,1,1],d=$s(n.shape,o,r,u,c,i,l),p=new Aa(d,"avg",!1);return e.runWebGLProgram(p,[n],"float32")}const RE={kernelName:fi,backendName:"webgl",kernelFunc:kE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NE{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,a=t.filterWidth,n=t.strideHeight,o=t.strideWidth,r=t.dilationHeight,c=t.dilationWidth,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=i-1-t.padInfo.top,d=l-1-t.padInfo.left,p=1/(e*a);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
            wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${c}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class TE{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,a=t.filterHeight,n=t.filterWidth,o=t.strideDepth,r=t.strideHeight,c=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=d-1-t.padInfo.front,x=p-1-t.padInfo.top,m=h-1-t.padInfo.left,g=1/(e*a*n);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${x}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${c}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,r=o,{filterSize:c,strides:i,pad:l,dimRoundingMode:u}=a,d=[1,1,1],p=$s(r.shape,c,i,d,l,u),h=new TE(p);return e.runWebGLProgram(h,[n],r.dtype)}const FE={kernelName:mi,backendName:"webgl",kernelFunc:EE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DE(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,r=o;Ln([n,o],"avgPoolGrad");const{filterSize:c,strides:i,pad:l}=a,u=An(r.shape,c,i,1,l),d=new NE(u);return e.runWebGLProgram(d,[n],r.dtype)}const OE={kernelName:gi,backendName:"webgl",kernelFunc:DE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(s){const{inputs:t,backend:e,attrs:a}=s,{a:n,b:o}=t,{transposeA:r,transposeB:c}=a;return us({a:n,b:o,transposeA:r,transposeB:c,backend:e})}const PE={kernelName:xi,backendName:"webgl",kernelFunc:AE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _E{constructor(t,e,a,n,o,r){this.outputShape=[],this.variableNames=["x","mean","variance"],_e(t,e),_e(t,a);let c="0.0";n!=null&&(_e(t,n),this.variableNames.push("offset"),c="getOffsetAtOutCoords()");let i="1.0";o!=null&&(_e(t,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${c};
        float scale = ${i};
        float inv = scale * inversesqrt(variance + float(${r}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ME{constructor(t,e,a,n,o,r){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_e(t,e),_e(t,a);let c="vec4(0.0)";n!=null&&(_e(t,n),this.variableNames.push("offset"),c="getOffsetAtOutCoords()");let i="vec4(1.0)";o!=null&&(_e(t,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${c};
        vec4 scale = ${i};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${r}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LE=({inputs:s,backend:t,attrs:e})=>{const{x:a,mean:n,variance:o,offset:r,scale:c}=s;ae(n.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ae(r==null||n.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ae(c==null||n.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:i}=e;i==null&&(i=.001);const l=[a,n,o];let u=null;r!=null&&(u=r.shape,l.push(r));let d=null;c!=null&&(d=c.shape,l.push(c));const p=A().getBool("WEBGL_PACK_NORMALIZATION")?new ME(a.shape,n.shape,o.shape,u,d,i):new _E(a.shape,n.shape,o.shape,u,d,i);return t.runWebGLProgram(p,l,l[0].dtype)},VE={kernelName:rc,backendName:"webgl",kernelFunc:LE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BE{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=pe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const a=WE(this.rank);let n;const o=t.map((r,c)=>`sourceLoc.${aa[c]} = start[${c}] + coords.${aa[c]};`);n=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${n}
        setOutput(getSource(${a}));
      }
    `}}const aa=["x","y","z","w","u","v"];function WE(s){if(s===1)return"sourceLoc";if(s<=6)return aa.slice(0,s).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zE{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=pe(this.rank),a=Se("coords",this.rank),n=Se("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${n.slice(-2).join()})`,r=`getChannel(getSource(${n.join()}), ${o})`,c=`
      result.x = ${r};
      if (++${a[this.rank-1]} < ${t[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${r};
        --${n[this.rank-1]};
      }
    `,i=this.rank===1?"":`
      --${a[this.rank-1]};
      if (++${a[this.rank-2]} < ${t[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${r};
        if (++${a[this.rank-1]} < ${t[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${r};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${n[d]} = ${a[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${c}
        ${i}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(s,t,e,a){const n=a.texData.get(s.dataId),o=a.makeTensorInfo(e,s.dtype),r=a.texData.get(o.dataId);Object.assign(r,n),r.refCount=1,r.shape=e,r.dtype=s.dtype;let c=b0(t,je(s.shape));n.slice&&(c+=n.slice.flatOffset),r.slice={flatOffset:c,origDataId:n.slice&&n.slice.origDataId||s.dataId};const i=a.dataRefCount.get(r.slice.origDataId)||1;return a.dataRefCount.set(r.slice.origDataId,i+1),o}function xn(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{begin:o,size:r}=a,[c,i]=x0(n,o,r);if(C0(n,c,i),Y(i)===0)return e.makeTensorInfo(i,n.dtype,[]);if(e.shouldExecuteOnCPU([n])||n.dtype==="string"){const d=e.texData.get(n.dataId),p=_2(d.values,c,i,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,p)}const{isPacked:l}=e.texData.get(n.dataId),u=$0(n.shape,c,i);if(l||!u){const d=A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zE(i):new BE(i),p=[c];return e.runWebGLProgram(d,[n],n.dtype,p)}return e.uploadToGPU(n.dataId),UE(n,c,i,e)}const GE={kernelName:Nl,backendName:"webgl",kernelFunc:xn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=s=>{const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockShape:o,crops:r}=a;ae(n.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const c=o.reduce((C,b)=>C*b),i=fu(n.shape,o,c),l=mu(i.length,o.length),u=gu(n.shape,o,c),d=I0(r,o.length),p=v0(u,r,o.length),h=[],f=U({inputs:{x:n},backend:e,attrs:{shape:i}}),x=Te({inputs:{x:f},backend:e,attrs:{perm:l}}),m=U({inputs:{x},backend:e,attrs:{shape:u}}),g=xn({inputs:{x:m},backend:e,attrs:{begin:d,size:p}});return h.push(f),h.push(x),h.push(m),h.forEach(C=>e.disposeIntermediateTensorInfo(C)),g},XE={kernelName:Ci,backendName:"webgl",kernelFunc:HE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qE(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,weights:o}=t,{size:r}=a,c=e.readSync(n.dataId),i=e.readSync(o.dataId),l=ad(c,i,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,l)}const jE={kernelName:$i,backendName:"webgl",kernelFunc:qE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KE(s){const{inputs:t,backend:e}=s,{s0:a,s1:n}=t,o=e.readSync(a.dataId),r=e.readSync(n.dataId),c=_e(Array.from(o),Array.from(r));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const YE={kernelName:bi,backendName:"webgl",kernelFunc:KE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE="return float(a != b);",Cd=ve({opSnippet:QE,cpuKernelImpl:N2,dtype:"bool"}),ZE={kernelName:Kc,backendName:"webgl",kernelFunc:Cd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(s){const{inputs:t,backend:e}=s,{input:a}=t,n=e.texData.get(a.dataId);return Be({inputs:{x:n.complexTensorInfos.real},backend:e})}const JE={kernelName:rl,backendName:"webgl",kernelFunc:zn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eF="return float(int(x));";function tF(s,t){const e=new ut(s.shape,eF),a=t.runWebGLProgram(e,[s],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{dtype:o}=a;if(o==="complex64"){if(n.dtype==="complex64")return Be({inputs:{x:n},backend:e});const r=lu(n.shape),c=oa({inputs:{x:n},backend:e,attrs:{dtype:"float32"}}),i=Et({inputs:{real:c,imag:r},backend:e});return r.dispose(),e.disposeIntermediateTensorInfo(c),i}if(n.dtype==="complex64"){const r=zn({inputs:{input:n},backend:e}),c=oa({inputs:{x:r},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(r),c}if(!UC(n.dtype,o)){const r=Be({inputs:{x:n},backend:e});return{dataId:r.dataId,shape:r.shape,dtype:o}}if(e.shouldExecuteOnCPU([n])){const r=e.texData.get(n.dataId).values,[c,i,l]=c2(r,n.shape,n.dtype,o);return e.makeTensorInfo(c,i,l)}if(o==="int32")return tF(n,e);if(o==="bool"){const r=e.makeTensorInfo([],"bool",yt("bool",1)),i=Cd({inputs:{a:n,b:r},backend:e});return e.disposeIntermediateTensorInfo(r),i}throw new Error(`Error in Cast: failed to cast ${n.dtype} to ${o}`)}const nF={kernelName:Ii,backendName:"webgl",kernelFunc:oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Co="return ceil(x);",sF=se({opSnippet:Co,packedOpSnippet:Co,cpuKernelImpl:l2}),aF={kernelName:vi,backendName:"webgl",kernelFunc:sF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oF{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rF{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{clipValueMin:o,clipValueMax:r}=a;let c;A().getBool("WEBGL_PACK_CLIP")?c=new rF(n.shape):c=new oF(n.shape);const i=[[o],[r]];return e.runWebGLProgram(c,[n],n.dtype,i)}const cF={kernelName:yi,backendName:"webgl",kernelFunc:iF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lF{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(s,t){return{dataId:t.dataId,dtype:t.dtype,shape:s.shape}}function uF(s){const{inputs:t,backend:e}=s,{x:a}=t,n=e.texData.get(a.dataId),o=new lF(a.shape),r=[$o(a,n.complexTensorInfos.real),$o(a,n.complexTensorInfos.imag)];return e.runWebGLProgram(o,r,r[0].dtype)}const dF={kernelName:Si,backendName:"webgl",kernelFunc:uF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pF{constructor(t){this.outputShape=[],this.outputShape=Zt(t,1),this.variableNames=t.map((r,c)=>`T${c}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let r=1;r<e.length;r++)e[r]=e[r-1]+t[r][1];const a=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<e.length;r++){const c=e[r-1];a.push(`else if (yC < ${e[r]}) setOutput(getT${r}(yR, yC-${c}));`)}const n=e.length,o=e[e.length-1];a.push(`else setOutput(getT${n}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${a.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hF{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zt(t,e);const a=this.outputShape,n=a.length,o=pe(n),r=Se("coords",n),c=["x","y","z","w","u","v"].slice(0,n);this.variableNames=t.map((x,m)=>`T${m}`);const i=new Array(t.length-1);i[0]=t[0][e];for(let x=1;x<i.length;x++)i[x]=i[x-1]+t[x][e];const l=c[e],u=c.slice(-2),d=c.join();let p=`if (${l} < ${i[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;for(let x=1;x<i.length;x++){const m=i[x-1];p+=`
        if (${l} < ${i[x]}  && ${l} >= ${i[x-1]}) {
          return getChannel(
            getT${x}(${Qn(c,l,m)}),
            vec2(${Qn(u,l,m)}));
        }`}const h=i.length,f=i[i.length-1];p+=`
        return getChannel(
          getT${h}(${Qn(c,l,f)}),
          vec2(${Qn(u,l,f)}));`,this.userCode=`
      float getValue(${c.map(x=>"int "+x)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${r}), 0., 0., 0.);

        ${r[n-1]} = ${r[n-1]} + 1;
        if (${r[n-1]} < ${a[n-1]}) {
          result.g = getValue(${r});
        }

        ${r[n-2]} = ${r[n-2]} + 1;
        if (${r[n-2]} < ${a[n-2]}) {
          result.a = getValue(${r});
        }

        ${r[n-1]} = ${r[n-1]} - 1;
        if (${r[n-2]} < ${a[n-2]} &&
            ${r[n-1]} < ${a[n-1]}) {
          result.b = getValue(${r});
        }
        setOutput(result);
      }
    `}}function Qn(s,t,e){const a=s.indexOf(t);return s.map((o,r)=>r===a?`${o} - ${e}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(s){const{inputs:t,backend:e}=s,{input:a}=t,n=e.texData.get(a.dataId);return Be({inputs:{x:n.complexTensorInfos.imag},backend:e})}const fF={kernelName:mc,backendName:"webgl",kernelFunc:Os};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(s,t,e){const a=s[0].dtype;if(a==="complex64"){const d=s.map(m=>zn({inputs:{input:m},backend:e})),p=s.map(m=>Os({inputs:{input:m},backend:e})),h=kn(d,t,e),f=kn(p,t,e),x=Et({inputs:{real:h,imag:f},backend:e});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),x}let n=e.shouldExecuteOnCPU(s);if(a==="string"&&(n=!0),n){const d=s.map(C=>{const $=[-1,Y(C.shape.slice(t))];return U({inputs:{x:C},backend:e,attrs:{shape:$}})}),p=d.map(C=>({vals:e.readSync(C.dataId),shape:C.shape})),h=Zt(d.map(C=>C.shape),1),f=d[0].shape[0]===1,x=u2(p,h,a,f),m=Zt(s.map(C=>C.shape),t),g=e.makeTensorInfo(m,a,x);return d.forEach(C=>e.disposeIntermediateTensorInfo(C)),g}const o=A().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const d=[];for(let h=0;h<s.length;h+=o){const f=s.slice(h,h+o);d.push(kn(f,t,e))}const p=kn(d,t,e);for(const h of d)e.disposeIntermediateTensorInfo(h);return p}if(A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1){const d=new hF(s.map(p=>p.shape),t);return e.runWebGLProgram(d,s,a)}const{tensors2D:r,outShape:c}=mF(s,t,e),i=new pF(r.map(d=>d.shape)),l=e.runWebGLProgram(i,r,a);r.forEach(d=>e.disposeIntermediateTensorInfo(d));const u=U({inputs:{x:l},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(l),u}function mF(s,t,e){const a=Zt(s.map(o=>o.shape),t);return{tensors2D:s.map(o=>U({inputs:{x:o},attrs:{shape:[-1,Y(o.shape.slice(t))]},backend:e})),outShape:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(s){const{inputs:t,backend:e,attrs:a}=s,{axis:n}=a,o=Ae(n,t[0].shape)[0],r=t.map(l=>l.shape);y0(r,o);const c=Zt(t.map(l=>l.shape),o);if(Y(c)===0)return e.makeTensorInfo(c,t[0].dtype,[]);const i=t.filter(l=>Y(l.shape)>0);return i.length===1?Be({inputs:{x:i[0]},backend:e}):kn(i,o,e)}const gF={kernelName:ki,backendName:"webgl",kernelFunc:$d};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bd{constructor(t,e=!1,a=null,n=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const r=t.padInfo.top,c=t.padInfo.left,i=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,h=t.filterWidth,f=Math.floor(t.inChannels/4)*4,x=t.inChannels%4,m=t.dataFormat==="channelsLast",g=m?1:2,C=m?2:3,b=m?3:1;let $="",I="";a&&(n?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:o?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:$=`
          float activation(float x) {
            ${a}
          }
        `,I="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${r}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${C}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v}
        ${I}
        setOutput(result);
      }
    `}}class xF{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,a=t.padInfo.top,n=t.padInfo.left,o=t.strideDepth,r=t.strideHeight,c=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,p=t.filterHeight,h=t.filterWidth,f=Math.floor(t.inChannels/4)*4,x=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${r}, ${c});
      const ivec3 pads = ivec3(${e}, ${a}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${i};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Id{constructor(t,e=!1,a=null,n=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const r=t.padInfo.left,c=t.strideWidth,i=t.dilationWidth,l=t.filterHeight,u=t.filterWidth,d=u;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)p+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;p+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)p+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(d+1)/2;m++){const g=m*2;if(p+=`
           xC = xCCorner + ${g*i};
           `,c===1){if(g<u&&(r%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,i===1&&g>0?p+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<u)){const C=r%2===0?ga(i):i;i%2===0&&r%2===1||i%2!==0&&r%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${C};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,i>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:p+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):C===1?p+=`
                     xC${g+1} = xTexelC${g};
                     `:p+=`
                     xCOffset = xC + ${C};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<u&&(r%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<u&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<u&&(p+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<u&&(p+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<u&&(p+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let h="",f="";a&&(n?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${a}
         }`:o?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${a}
         }`:h=`vec4 activation(vec4 x) {
           ${a}
         }`,f="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CF{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Fe(this.outputShape.length);const{dataFormat:a}=e,n=Ee(),o=a==="channelsLast",r=o?1:2,c=o?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${u};

          ${i}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${r}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${c}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds(s,t){const e=s.length;return e>=3?t?[...s.slice(0,-3),s[e-3]*s[e-2],s[e-1]]:[...s.slice(0,-3),s[e-3],s[e-2]*s[e-1]]:!t&&e===1&&s[0]>1?[s[0],1]:null}function vd({x:s,filter:t,convInfo:e,backend:a,bias:n=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:c=null}){const i=s.shape,l=a.texData.get(s.dataId),u=e.inChannels,d=i[0]*i[1]*i[2],p=e.outChannels,h=e.dataFormat==="channelsLast",f=!1,x=!1;let m;const g=[];if(o!=null){const $=ds(o.shape,h);$!=null&&(o=U({inputs:{x:o},backend:a,attrs:{shape:$}}),g.push(o))}if(n!=null){const $=ds(n.shape,h);$!=null&&(n=U({inputs:{x:n},backend:a,attrs:{shape:$}}),g.push(n))}if(!((d===1||p===1)&&u>fd)&&l.isPacked&&h&&l.texture!=null&&i[2]%2!==0&&Ne(l.shape.slice(-3),i.slice(-3))){const $=i[0]*i[1]*(i[2]+1),I={dataId:s.dataId,shape:[1,$,e.inChannels],dtype:s.dtype},v=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,ae(ls(l.shape,I.shape),()=>`packed reshape ${l.shape} to ${I.shape} isn't free`);const y=U({inputs:{x:t},backend:a,attrs:{shape:[1,e.inChannels,e.outChannels]}});g.push(y);const w=us({a:I,b:y,backend:a,transposeA:f,transposeB:x,bias:n,activation:c,preluActivationWeights:o,leakyreluAlpha:r}),k=a.texData.get(w.dataId);ae(k.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=v,k.shape=e.outShape,m=Be({inputs:{x:w},backend:a}),m.shape=e.outShape,g.push(w)}else{const $=e.outHeight*e.outWidth,I=U({inputs:{x:s},backend:a,attrs:{shape:h?[e.batchSize,$,e.inChannels]:[e.batchSize,e.inChannels,$]}}),v=U({inputs:{x:t},backend:a,attrs:{shape:[1,e.inChannels,e.outChannels]}}),y=us({a:h?I:v,b:h?v:I,transposeA:!h,transposeB:x,backend:a,bias:n,activation:c,preluActivationWeights:o,leakyreluAlpha:r});m=U({inputs:{x:y},backend:a,attrs:{shape:e.outShape}}),g.push(I),g.push(v),g.push(y)}for(const $ of g)a.disposeIntermediateTensorInfo($);return m}function yd({x:s,filter:t,convInfo:e,backend:a,bias:n=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:c=null}){const{filterWidth:i,filterHeight:l,inChannels:u,outWidth:d,outHeight:p,dataFormat:h}=e,f=h==="channelsLast",x=i*l*u,m=p*d,g=[e.batchSize,x,m],C=!0,b=!1,$=[];if(o!=null){const R=ds(o.shape,f);R!=null&&(o=U({inputs:{x:o},backend:a,attrs:{shape:R}}),$.push(o))}if(n!=null){const R=ds(n.shape,f);R!=null&&(n=U({inputs:{x:n},backend:a,attrs:{shape:R}}),$.push(n))}const I=U({inputs:{x:t},backend:a,attrs:{shape:[1,x,Y(t.shape)/x]}});$.push(I);const v=new CF(g,e),y=[s.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],w=a.runWebGLProgram(v,[s],"float32",y),k=U({inputs:{x:w},backend:a,attrs:{shape:g}});$.push(w),$.push(k);const S=n!=null,E=o!=null,O=c==="leakyrelu",F=c?Nn(c,!0):null,D=new hd(f?k.shape:I.shape,f?I.shape:k.shape,f?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],C,b,S,F,E,O),N=f?[k,I]:[I,k];if(n&&N.push(n),E&&N.push(o),O){const R=a.makeTensorInfo([],"float32",cn(r,"float32"));N.push(R),$.push(R)}const T=a.runWebGLProgram(D,N,"float32"),_=U({inputs:{x:T},backend:a,attrs:{shape:e.outShape}});$.push(T);for(const R of $)a.disposeIntermediateTensorInfo(R);return _}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dataFormat:i,dilations:l,dimRoundingMode:u}=a,d=bs(i),p=kt(n.shape,o.shape,r,l,c,u,!1,d);let h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=vd({x:n,filter:o,convInfo:p,backend:e});else if(p.strideWidth<=2&&d==="channelsLast"&&A().getBool("WEBGL_EXP_CONV")){const x=new Id(p),m=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=e.runWebGLProgram(x,[n,o],"float32",m)}else if(A().getBool("WEBGL_CONV_IM2COL"))h=yd({x:n,filter:o,convInfo:p,backend:e});else{const x=new bd(p);h=e.runWebGLProgram(x,[n,o],"float32")}const f=U({inputs:{x:h},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(h),f}const bF={kernelName:Ri,backendName:"webgl",kernelFunc:$F};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IF{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,a=t.strideWidth,n=t.padInfo.top,o=t.padInfo.left,r=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${n};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${r}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vF{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,a=t.filterWidth,n=t.strideHeight,o=t.strideWidth,r=t.dataFormat==="channelsLast",c=e-1-t.padInfo.top,i=a-1-t.padInfo.left,l=r?1:2,u=r?2:3,d=r?3:1;this.userCode=`
      const ivec2 pads = ivec2(${c}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${r}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yF{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,a=t.strideHeight,n=t.strideWidth,o=t.padInfo.front,r=t.padInfo.top,c=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${o};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${a} - ${r};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${c};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wF{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,a=t.filterHeight,n=t.filterWidth,o=t.strideDepth,r=t.strideHeight,c=t.strideWidth,i=e-1-t.padInfo.front,l=a-1-t.padInfo.top,u=n-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${i}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${a}; wR++) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${a} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${c}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,pad:c,dataFormat:i,dimRoundingMode:l,filterShape:u}=a,d=bs(i),p=kt(n.shape,u,r,1,c,l,!1,d),h=new IF(p);return e.runWebGLProgram(h,[n,o],"float32")}const kF={kernelName:Ni,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{inputShape:r,strides:c,pad:i,dataFormat:l,dimRoundingMode:u}=a,d=bs(l),p=kt(r,o.shape,c,1,i,u,!1,d),h=new vF(p);return e.runWebGLProgram(h,[n,o],"float32")}const NF={kernelName:Ti,backendName:"webgl",kernelFunc:RF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dilations:i}=a,l=Ca(n.shape,o.shape,r,i,c),u=new xF(l);return e.runWebGLProgram(u,[n,o],"float32")}const EF={kernelName:Ei,backendName:"webgl",kernelFunc:TF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,pad:c,filterShape:i}=a,l=Ca(n.shape,i,r,1,c),u=new yF(l);return e.runWebGLProgram(u,[n,o],"float32")}const DF={kernelName:Fi,backendName:"webgl",kernelFunc:FF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{pad:r,strides:c,inputShape:i}=a,l=Ca(i,o.shape,c,1,r),u=new wF(l);return e.runWebGLProgram(u,[n,o],"float32")}const AF={kernelName:Di,backendName:"webgl",kernelFunc:OF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PF=gn+`
  return cos(x);
`,_F=se({opSnippet:PF}),MF={kernelName:Oi,backendName:"webgl",kernelFunc:_F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,VF=se({opSnippet:LF}),BF={kernelName:Ai,backendName:"webgl",kernelFunc:VF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WF{constructor(t,e,a,n,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,c,i,l]=t,[u]=e,[d,p]=a;this.outputShape=[u,d,p,l];const h=n==="bilinear"?1:0,[f,x]=[`${c-1}.0`,`${i-1}.0`],[m,g,C]=d>1?[`${(c-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,$,I]=p>1?[`${(i-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${r}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${$};

        float in_y = ${C};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=s=>{const{inputs:t,backend:e,attrs:a}=s,{image:n,boxes:o,boxInd:r}=t,{cropSize:c,method:i,extrapolationValue:l}=a,u=new WF(n.shape,o.shape,c,i,l);return e.runWebGLProgram(u,[n,o,r],"float32")},UF={kernelName:Pi,backendName:"webgl",kernelFunc:zF};var En;(function(s){s.Prod="*",s.Sum="+"})(En||(En={}));class bo{constructor(t,e,a,n){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,r=this.op===En.Prod?"1.0":"0.0",c=a?r:`getX(${Io(o,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let l="",u="";a?(l=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${pe(o)} coords = getOutputCoords();
        int end = ${vo(o,"coords",this.op)};
        float val = ${c};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${vo(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${Io(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Io(s,t,e){if(s===1)return`${t}`;if(s===2)return`${t}.x, ${t}.y`;if(s===3)return`${t}.x, ${t}.y, ${t}.z`;if(s===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${s} is not yet supported`)}function vo(s,t,e){if(s===1)return`${t}`;if(s===2)return`${t}.y`;if(s===3)return`${t}.z`;if(s===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(s,t,e,a,n,o){const r=t.shape.length,c=et([a],r);let i=t;c!=null&&(i=Te({inputs:{x:t},backend:e,attrs:{perm:c}}));const l=tt(1,r)[0];if(l!==r-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);const u=i.shape[l];let d=Be({inputs:{x:i},backend:e});for(let p=0;p<=Math.ceil(Math.log2(u))-1;p++){const h=new bo(s,i.shape,!1,o),f=[[p]],x=d;d=e.runWebGLProgram(h,[d],d.dtype,f),e.disposeIntermediateTensorInfo(x)}if(n){const p=new bo(s,i.shape,n,o),h=d;d=e.runWebGLProgram(p,[d],d.dtype),e.disposeIntermediateTensorInfo(h)}if(c!=null){const p=du(c),h=Te({inputs:{x:d},backend:e,attrs:{perm:p}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(i),h}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,exclusive:r,reverse:c}=a;return wd(En.Prod,n,e,o,r,c)}const HF={kernelName:_i,backendName:"webgl",kernelFunc:GF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,exclusive:r,reverse:c}=a;return wd(En.Sum,n,e,o,r,c)}const qF={kernelName:Mi,backendName:"webgl",kernelFunc:XF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,weights:o}=t,{size:r,binaryOutput:c}=a;if(n.shape.length===1){const i=e.readSync(n.dataId),l=e.readSync(o.dataId),u=ad(i,l,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,u)}else if(n.shape.length===2){const i=e.bufferSync(n),l=e.bufferSync(o),u=i2(i,l,r,c);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}const KF={kernelName:Vi,backendName:"webgl",kernelFunc:jF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YF{constructor(t,e,a){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=a,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockSize:o,dataFormat:r}=a,c=n.shape[0],i=r==="NHWC"?n.shape[1]:n.shape[2],l=r==="NHWC"?n.shape[2]:n.shape[3],u=r==="NHWC"?n.shape[3]:n.shape[1],d=i*o,p=l*o,h=u/(o*o),f=r==="NHWC"?[c,d,p,h]:[c,h,d,p],x=new YF(f,o,r);return e.runWebGLProgram(x,[n],n.dtype)}const ZF={kernelName:Bi,backendName:"webgl",kernelFunc:QF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sd{constructor(t,e=!1,a=null,n=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const r=t.filterHeight,c=t.filterWidth,i=t.outChannels/t.inChannels;let l="",u="";a&&(n?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:o?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:l=`
          float activation(float x) {
            ${a}
          }
        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${r}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${c}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kd{constructor(t,e=!1,a=null,n=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const r=t.outChannels/t.inChannels,c=t.padInfo.left,i=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,p=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<d;g++)h+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<d;g++)h+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(p+1)/2;g++){const C=g*2;if(h+=`
          xC = xCCorner + ${C*l};
          `,i===1){if(C<d&&(c%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }
              `,l===1&&C>0?h+=`
                xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                  } else {
                    xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xC${C} = xTexelC${C};
                `,C+1<d)){const b=c%2===0?ga(l):l;l%2===0&&c%2===1||l%2!==0&&c%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                    xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${C+1}.zw = vec2(0.0);
                    }
                    xTexelC${C+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                    } else {
                     xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                    }
                    `:h+=`
                    xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                    `):b===1?h+=`
                    xC${C+1} = xTexelC${C};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                      xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${C+1}.zw = vec2(0.0);
                      }
                      xTexelC${C+1}Ready = 1;
                    }

                    xC${C+1} = xTexelC${C+1};
                    `}}else C<d&&(c%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.0);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
              `,C+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(
                  xTexelC${C}.xy, xTexelC${C+1}.xy);
              `,C+1<d&&(h+=`
                  xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                `)));C<d&&(h+=`
            wTexel = getW(r, ${C}, d1, q);
            dotProd += xC${C} * vec4(wTexel.xz, wTexel.xz);
          `,C+1<d&&(h+=`
              wTexel = getW(r, ${C+1}, d1, q);
              dotProd += xC${C+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let f="",x="";a&&(n?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:f=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${r};
        int q = d2 - d1 * ${r};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dilations:i,dimRoundingMode:l}=a;let u=i;u==null&&(u=[1,1]),ae(On(r,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`);const d=kt(n.shape,o.shape,r,u,c,l,!0);let p;A().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new kd(d):p=new Sd(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return e.runWebGLProgram(p,[n,o],"float32",h)}const eD={kernelName:Wi,backendName:"webgl",kernelFunc:JF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,a=t.strideWidth,n=t.padInfo.top,o=t.padInfo.left,r=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${r} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${n};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,a=t.filterWidth,n=t.strideHeight,o=t.strideWidth,r=e-1-t.padInfo.top,c=a-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${i}; dm++) {
              int d2 = d1 * ${i} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,dy:o}=t,{strides:r,dilations:c,pad:i,dimRoundingMode:l,filterShape:u}=a,d=kt(n.shape,u,r,c,i,l,!0),p=new tD(d);return e.runWebGLProgram(p,[n,o],"float32")}const aD={kernelName:zi,backendName:"webgl",kernelFunc:sD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,filter:o}=t,{strides:r,dilations:c,pad:i,dimRoundingMode:l,inputShape:u}=a,d=kt(u,o.shape,r,c,i,l,!0),p=new nD(d);return e.runWebGLProgram(p,[n,o],"float32")}const rD={kernelName:Ui,backendName:"webgl",kernelFunc:oD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iD{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(s){const{inputs:t,backend:e}=s,{x:a}=t,n=[...a.shape,...a.shape],o=Y(a.shape),r=U({inputs:{x:a},backend:e,attrs:{shape:[o]}}),c=new iD(o),i=e.runWebGLProgram(c,[r],r.dtype),l=U({inputs:{x:i},backend:e,attrs:{shape:n}});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),l}const lD={kernelName:Gi,backendName:"webgl",kernelFunc:cD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uD{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:a,padInfo:n,strideHeight:o,strideWidth:r,filterHeight:c,filterWidth:i,dilationHeight:l,dilationWidth:u}=t,{top:d,left:p}=n;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${r});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${c}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${i}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${a}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o}=t,{strides:r,pad:c,dilations:i}=a,l=GC(n.shape,o.shape,r,c,"NHWC",i);let u;const d=new uD(l);u=e.runWebGLProgram(d,[n,o],"float32");const p=U({inputs:{x:u},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(u),p}const pD={kernelName:Hi,backendName:"webgl",kernelFunc:dD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(s){const{inputs:t,backend:e,attrs:a}=s,{equation:n}=a,o=t,{allDims:r,summedDims:c,idDims:i}=w0(n,o.length);S0(r.length,i,o);const{path:l,steps:u}=k0(c,i),d=u.length;let p=null,h=r.length;const f=[];for(let x=0;x<d;++x){for(const m of u[x]){const{permutationIndices:g,expandDims:C}=R0(h,i[m]);let b;N0(g)?b=o[m]:(b=Te({inputs:{x:o[m]},backend:e,attrs:{perm:g}}),f.push(b));const $=b.shape.slice();for(let I=0;I<C.length;++I)$.splice(C[I],0,1);Ne(b.shape,$)||(b=U({inputs:{x:b},backend:e,attrs:{shape:$}}),f.push(b)),p===null?p=b:(p=Oa({inputs:{a:b,b:p},backend:e}),f.push(p))}x<d-1&&(l[x]>=0&&(p=Ds({inputs:{x:p},backend:e,attrs:{axis:l[x]-(r.length-h),keepDims:!1}}),f.push(p)),h--)}for(const x of f)x!==p&&e.disposeIntermediateTensorInfo(x);return p}const fD={kernelName:Xi,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD="return (x >= 0.0) ? x : (exp(x) - 1.0);",gD=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,xD=se({opSnippet:mD,packedOpSnippet:gD}),CD={kernelName:qi,backendName:"webgl",kernelFunc:xD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D="return (b >= 1.0) ? a : a * (b + 1.0);",bD=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ID=s=>{const{inputs:t,backend:e}=s,{dy:a,y:n}=t,o=A().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wn(bD,a.shape,n.shape):new an($D,a.shape,n.shape);return e.runWebGLProgram(o,[a,n],a.dtype)},vD={kernelName:ji,backendName:"webgl",kernelFunc:ID};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yD=`
  return vec4(equal(a, b));
`,wD="return float(a == b);",SD=ve({opSnippet:wD,packedOpSnippet:yD,dtype:"bool",cpuKernelImpl:d2}),kD={kernelName:Ki,backendName:"webgl",kernelFunc:SD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RD=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T0};
  float a1 = ${E0};
  float a2 = ${F0};
  float a3 = ${D0};
  float a4 = ${O0};
  float a5 = ${A0};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ND=se({opSnippet:RD}),TD={kernelName:Yi,backendName:"webgl",kernelFunc:ND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ED=gn+`
  return exp(x);
`,FD=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Rd=se({opSnippet:ED,packedOpSnippet:FD,cpuKernelImpl:p2,dtype:"float32"}),DD={kernelName:Qi,backendName:"webgl",kernelFunc:Rd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(s){const{inputs:t,attrs:e,backend:a}=s,{dim:n}=e,{input:o}=t,r=o.shape.length,c=o.shape.slice();let i=n;return n<0&&(ae(-(r+1)<=n,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),i=r+n+1),c.splice(i,0,1),U({inputs:{x:o},backend:a,attrs:{shape:c}})}const OD={kernelName:Zi,backendName:"webgl",kernelFunc:ra};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo="return exp(x) - 1.0;",AD=se({opSnippet:yo,packedOpSnippet:yo,cpuKernelImpl:h2}),PD={kernelName:Ji,backendName:"webgl",kernelFunc:AD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wo{constructor(t,e,a){this.variableNames=["real","imag"];const n=e[1];this.outputShape=e;const o=a?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,r=a?`${n}.0`:"1.0";let c;if(t==="real")c="return real * expR - imag * expI;";else if(t==="imag")c="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${c}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${n});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${n}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${r};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nd(s,t,e){const a=e.texData.get(s.dataId),n=Y(s.shape),o=s.shape[s.shape.length-1],r=n/o,c=U({inputs:{x:s},backend:e,attrs:{shape:[r,o]}}),i=c.shape,l=new wo("real",i,t),u=new wo("imag",i,t),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],p=e.runWebGLProgram(l,d,"float32"),h=e.runWebGLProgram(u,d,"float32"),f=Et({inputs:{real:p,imag:h},backend:e});e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h);const x=U({inputs:{x:f},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(f),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(s){const{inputs:t,backend:e}=s,{input:a}=t;return Nd(a,!1,e)}const MD={kernelName:ec,backendName:"webgl",kernelFunc:_D};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LD{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(s){const{backend:t,attrs:e}=s,{shape:a,value:n}=e;let{dtype:o}=e;if(o=o||HC(n),o==="string"){const r=nt(o,Y(a));return r.fill(n),t.makeTensorInfo(a,o,r)}else{const r=new LD(a,n),c=[[n]];return t.runWebGLProgram(r,[],o,c)}}const VD={kernelName:tc,backendName:"webgl",kernelFunc:Un};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BD{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WD={kernelName:nc,backendName:"webgl",kernelFunc:({inputs:s,backend:t})=>{const{image:e}=s,a=t,n=new BD(e.shape);return a.runWebGLProgram(n,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So="return floor(x);",zD=se({opSnippet:So,packedOpSnippet:So,cpuKernelImpl:f2}),UD={kernelName:sc,backendName:"webgl",kernelFunc:zD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,HD=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,XD=ve({opSnippet:GD,packedOpSnippet:HD,dtype:"int32"}),qD={kernelName:ac,backendName:"webgl",kernelFunc:XD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jD{constructor(t){this.variableNames=["A"];const e=Ee(),[a,n]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${a}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KD{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ee(),[a,n]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${a}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD={kernelName:oc,backendName:"webgl",kernelFunc:QD};let Kt,Xs=A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function QD(s){const{inputs:t,backend:e,attrs:a}=s;let{pixels:n}=t;const{numChannels:o}=a,r=typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement,c=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,[i,l]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height],u=[l,i],d=[l,i,o];if(c||r){const x=A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Kt==null||x!==Xs)&&(Xs=x,Kt=document.createElement("canvas").getContext("2d",{willReadFrequently:Xs})),Kt.canvas.width=i,Kt.canvas.height=l,Kt.drawImage(n,0,0,i,l),n=Kt.canvas}const p=e.makeTensorInfo(u,"int32");e.texData.get(p.dataId).usage=ze.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(p.dataId),n);const h=A().getBool("WEBGL_PACK")?new KD(d):new jD(d),f=e.runWebGLProgram(h,[p],"int32");return e.disposeData(p.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o,bias:r,preluActivationWeights:c}=t,{strides:i,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a,x=bs(u),m=kt(n.shape,o.shape,i,d,l,p,!1,x);let g;const C=[],b=r!=null,$=c!=null,I=h==="leakyrelu",v=()=>{const w=[n,o],k=(S,E)=>{if(E==="NCHW"&&S.shape.length===1&&S.shape[0]!==1){const O=U({inputs:{x:S},backend:e,attrs:{shape:[S.shape[0],1,1]}});return C.push(O),O}return S};if(b&&w.push(k(r,u)),$&&w.push(k(c,u)),I){const S=e.makeTensorInfo([],"float32",cn(f,"float32"));w.push(S),C.push(S)}return w};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=vd({x:n,filter:o,convInfo:m,backend:e,bias:r,activation:h,preluActivationWeights:c,leakyreluAlpha:f});else if(m.strideWidth<=2&&x==="channelsLast"&&A().getBool("WEBGL_EXP_CONV")){const w=h?Nn(h,!0):null,k=new Id(m,b,w,$,I),S=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],E=v();g=e.runWebGLProgram(k,E,"float32",S)}else if(A().getBool("WEBGL_CONV_IM2COL"))g=yd({x:n,filter:o,convInfo:m,backend:e,bias:r,activation:h,preluActivationWeights:c,leakyreluAlpha:f});else{const w=h?Nn(h,!1):null,k=new bd(m,b,w,$,I),S=v();g=e.runWebGLProgram(k,S,"float32")}const y=U({inputs:{x:g},backend:e,attrs:{shape:m.outShape}});return C.push(g),C.forEach(w=>e.disposeIntermediateTensorInfo(w)),y}const JD={kernelName:ic,backendName:"webgl",kernelFunc:ZD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,filter:o,bias:r,preluActivationWeights:c}=t,{strides:i,pad:l,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=a,f=[];let x=u;x==null&&(x=[1,1]),ae(On(i,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${x}'`);const m=kt(n.shape,o.shape,i,x,l,d,!0),g=A().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,C=p?Nn(p,g):null,b=[n,o],$=r!=null,I=c!=null,v=p==="leakyrelu";if($&&b.push(r),I&&b.push(c),v){const S=e.makeTensorInfo([],"float32",cn(h,"float32"));b.push(S),f.push(S)}let y;g?y=new kd(m,$,C,I,v):y=new Sd(m,$,C,I,v);const w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],k=e.runWebGLProgram(y,b,"float32",w);return f.forEach(S=>e.disposeIntermediateTensorInfo(S)),k}const tO={kernelName:cc,backendName:"webgl",kernelFunc:eO};class nO{constructor(t,e,a,n){this.sliceDim=t,this.strides=e,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=a;const o=pe(a.length);let r=`
    int index;`;for(let c=0;c<this.sliceDim;c++)r+=`
          index = round(getIndices(coords[0], ${c}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[c]};
          flattenIndex += index * ${this.strides[c]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${r}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(s){const{inputs:t,backend:e}=s,{params:a,indices:n}=t,o=n.shape,r=o[o.length-1],c=Y(a.shape),[i,l,u,d]=P0(a,n),p=U({inputs:{x:n},backend:e,attrs:{shape:[l,r]}}),h=U({inputs:{x:a},backend:e,attrs:{shape:[Y(a.shape)/u,u]}});if(e.shouldExecuteOnCPU([a,n])||a.dtype==="string"){const g=e.readSync(n.dataId),C=e.bufferSync(a),b=m2(g,C,a.dtype,l,r,u,d,a.shape,c);return e.makeTensorInfo(i,a.dtype,b.values)}const f=new nO(r,d,[l,u],a.shape),x=e.runWebGLProgram(f,[h,p],h.dtype),m=U({inputs:{x},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(x),m}const aO={kernelName:lc,backendName:"webgl",kernelFunc:sO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oO{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const a=pe(this.rank),n=rO(t);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}}function rO(s,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let n=0;n<s.length;n++)n===2?a.push("index"):a.push(`${e[n]}`);return a.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,indices:o}=t,{axis:r,batchDims:c}=a,i=Ae(r,n.shape)[0];if(A().get("DEBUG")){const C=e.readSync(o.dataId),b=n.shape[i];for(let $=0;$<C.length;++$){const I=C[$];ae(I<=b-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${b-1}]`)}}const l=_0(n,o,i,c),u=Y(o.shape),d=[],p=U({inputs:{x:n},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),h=U({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(p),d.push(h);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){const C=e.bufferSync(h),b=e.bufferSync(p),$=g2(b,C,f);return d.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(l.outputShape,$.dtype,$.values)}const x=new oO(p.shape,f),m=e.runWebGLProgram(x,[p,h],p.dtype);d.push(m);const g=U({inputs:{x:m},backend:e,attrs:{shape:l.outputShape}});return d.forEach(C=>e.disposeIntermediateTensorInfo(C)),g}const iO={kernelName:uc,backendName:"webgl",kernelFunc:Td};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cO="return float(a > b);",lO=`
  return vec4(greaterThan(a, b));
`,uO=ve({opSnippet:cO,packedOpSnippet:lO,cpuKernelImpl:x2,dtype:"bool"}),dO={kernelName:dc,backendName:"webgl",kernelFunc:uO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pO="return float(a >= b);",hO=`
  return vec4(greaterThanEqual(a, b));
`,fO=ve({opSnippet:pO,packedOpSnippet:hO,dtype:"bool",cpuKernelImpl:C2}),mO={kernelName:pc,backendName:"webgl",kernelFunc:fO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(s){const{inputs:t,backend:e}=s,{input:a}=t;return Nd(a,!0,e)}const xO={kernelName:hc,backendName:"webgl",kernelFunc:gO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CO="return float(!isnan(x) && !isinf(x));",$O=se({opSnippet:CO,dtype:"bool"}),bO={kernelName:gc,backendName:"webgl",kernelFunc:$O};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IO="return float(isinf(x));",vO=se({opSnippet:IO,dtype:"bool"}),yO={kernelName:xc,backendName:"webgl",kernelFunc:vO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO="return float(isnan(x));",SO=se({opSnippet:wO,dtype:"bool"}),kO={kernelName:Cc,backendName:"webgl",kernelFunc:SO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RO="return float(a < b);",NO=`
  return vec4(lessThan(a, b));
`,TO=ve({opSnippet:RO,packedOpSnippet:NO,cpuKernelImpl:$2,dtype:"bool"}),EO={kernelName:yc,backendName:"webgl",kernelFunc:TO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO="return float(a <= b);",DO=`
  return vec4(lessThanEqual(a, b));
`,OO=ve({opSnippet:FO,packedOpSnippet:DO,cpuKernelImpl:b2,dtype:"bool"}),AO={kernelName:wc,backendName:"webgl",kernelFunc:OO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(s){const{backend:t,attrs:e}=s,{start:a,stop:n,num:o}=e,r=I2(a,n,o);return t.makeTensorInfo([r.length],"float32",r)}const _O={kernelName:Sc,backendName:"webgl",kernelFunc:PO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MO=gn+`
  return x < 0.0 ? 0./0. : log(x);
`,LO=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,VO=se({opSnippet:MO,packedOpSnippet:LO,cpuKernelImpl:v2}),BO={kernelName:kc,backendName:"webgl",kernelFunc:VO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WO=gn+`
  return log(1.0 + x);
`,zO=se({opSnippet:WO}),UO={kernelName:Rc,backendName:"webgl",kernelFunc:zO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO="return float(a >= 1.0 && b >= 1.0);",HO=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,XO=ve({opSnippet:GO,packedOpSnippet:HO,dtype:"bool"}),qO={kernelName:Nc,backendName:"webgl",kernelFunc:XO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO="return float(!(x >= 1.0));",KO=se({opSnippet:jO}),YO={kernelName:Tc,backendName:"webgl",kernelFunc:KO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QO="return float(a >= 1.0 || b >= 1.0);",ZO=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,JO=ve({opSnippet:QO,packedOpSnippet:ZO,dtype:"bool"}),eA={kernelName:Ec,backendName:"webgl",kernelFunc:JO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tA{constructor(t,e,a,n,o){this.variableNames=["x"],this.outputShape=[];const r=e,c=t[3]-1;this.outputShape=t;let i;const l=`float(${a}) + float(${n}) * sum`;o===.5?i=`inversesqrt(${l})`:o===1?i=`1.0/(${l})`:i=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${r}; j <= ${r}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${c}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${i};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nA{constructor(t,e,a,n,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=e,c=t[3]-1;this.outputShape=t;let i;const l=`float(${a}) + float(${n}) * sum`;o===.5?i=`inversesqrt(${l})`:o===1?i=`1.0/(${l})`:i=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${r};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${r}; j <= ${r}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${c}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sA=s=>{const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{depthRadius:o,bias:r,alpha:c,beta:i}=a,l=A().getBool("WEBGL_PACK_NORMALIZATION")?new nA(n.shape,o,r,c,i):new tA(n.shape,o,r,c,i);return e.runWebGLProgram(l,[n],n.dtype)},aA={kernelName:bc,backendName:"webgl",kernelFunc:sA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oA{constructor(t,e,a,n,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=a,this.alpha=n,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${a});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rA=s=>{const{inputs:t,backend:e,attrs:a}=s,{x:n,y:o,dy:r}=t,{depthRadius:c,bias:i,alpha:l,beta:u}=a,d=new oA(n.shape,c,i,l,u);return e.runWebGLProgram(d,[n,o,r],n.dtype)},iA={kernelName:Ic,backendName:"webgl",kernelFunc:rA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(s,t,e,a){const n=Y(t),r=Y(s.shape)/n,c=U({inputs:{x:s},attrs:{shape:[r,n]},backend:a}),i=Xt(c,s.dtype,"max",a),l=U({inputs:{x:i},attrs:{shape:e},backend:a});return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(i),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{reductionIndices:o,keepDims:r}=a,c=n.shape.length,i=Ae(o,n.shape);let l=i;const u=et(l,c),d=u!=null,p=e.shouldExecuteOnCPU([n]);let h=n;if(d){if(p){const b=e.texData.get(h.dataId).values,$=new Array(c);for(let y=0;y<$.length;y++)$[y]=n.shape[u[y]];const I=Fa(b,n.shape,n.dtype,u,$);h=e.makeTensorInfo($,n.dtype);const v=e.texData.get(h.dataId);v.values=I}else h=Fs(n,u,e);l=tt(l.length,c)}it("max",l,c);const[f,x]=ht(h.shape,l);let m=f;r&&(m=St(f,i));let g;if(p){const b=e.texData.get(h.dataId).values,$=y2(b,Y(x),m,n.dtype);g=e.makeTensorInfo(m,n.dtype);const I=e.texData.get(g.dataId);I.values=$}else g=cA(h,x,m,e);return d&&e.disposeIntermediateTensorInfo(h),g}const lA={kernelName:Fc,backendName:"webgl",kernelFunc:Ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uA=Da+`
  return max(a, b);
`,dA=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bn+`
  return result;
`,pA=ve({opSnippet:uA,packedOpSnippet:dA,cpuKernelImpl:w2}),hA={kernelName:Mc,backendName:"webgl",kernelFunc:pA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t;Ln(n,"maxPool");const{filterSize:o,strides:r,pad:c,dimRoundingMode:i}=a,l=1;ae(On(r,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const u=An(n.shape,o,r,l,c,i);if(u.filterWidth===1&&u.filterHeight===1&&Ne(u.inShape,u.outShape))return Be({inputs:{x:n},backend:e});const d=new Tn(u,"max",!1);return e.runWebGLProgram(d,[n],n.dtype)}const mA={kernelName:Dc,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{filterSize:o,strides:r,pad:c,dataFormat:i,dimRoundingMode:l}=a,u=[1,1,1],d=$s(n.shape,o,r,u,c,l,i),p=new Aa(d,"max",!1);return e.runWebGLProgram(p,[n],n.dtype)}const xA={kernelName:Oc,backendName:"webgl",kernelFunc:gA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CA{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,a=t.strideWidth,n=t.dilationHeight,o=t.effectiveFilterHeight,r=t.effectiveFilterWidth,c=o-1-t.padInfo.top,i=r-1-t.padInfo.left,l=o*r-1;this.userCode=`
      const ivec2 pads = ivec2(${c}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${r} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class $A{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,a=t.strideHeight,n=t.strideWidth,o=t.dilationDepth,r=t.dilationHeight,c=t.dilationWidth,i=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,d=i-1-t.padInfo.front,p=l-1-t.padInfo.top,h=u-1-t.padInfo.left,f=i*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${i};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${r}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o}=t,r=o,{filterSize:c,strides:i,pad:l,dimRoundingMode:u}=a,d=[1,1,1],p=$s(r.shape,c,i,d,l,u),h=new Aa(p,"max",!0),f=e.runWebGLProgram(h,[r],r.dtype),x=new $A(p),m=e.runWebGLProgram(x,[n,f],r.dtype);return e.disposeIntermediateTensorInfo(f),m}const IA={kernelName:Ac,backendName:"webgl",kernelFunc:bA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(s){const{inputs:t,backend:e,attrs:a}=s,{dy:n,input:o,output:r}=t,c=o;Ln([o,r],"maxPoolGrad");const{filterSize:i,strides:l,pad:u,dimRoundingMode:d}=a,p=An(c.shape,i,l,1,u,d),h=!0,f=new Tn(p,"max",h),x=e.runWebGLProgram(f,[c],c.dtype),m=new CA(p),g=e.runWebGLProgram(m,[n,x],c.dtype);return e.disposeIntermediateTensorInfo(x),g}const yA={kernelName:Pc,backendName:"webgl",kernelFunc:vA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(s,t,e,a){let n=new Tn(e,"max",!1);const o=a.runWebGLProgram(n,[s],"float32");n=new Tn(e,"max",!0,!0,t);const r=a.runWebGLProgram(n,[s],"float32");return[o,r]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SA={kernelName:_c,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:a}=s,{filterSize:n,strides:o,pad:r,includeBatchInIndex:c}=t,i=e;ae(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);const l=[1,1];ae(On(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const u=An(a.shape,n,o,l,r),[d,p]=wA(a,c,u,i);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kA(s,t,e,a){const n=Y(t),r=Y(s.shape)/n,c=U({inputs:{x:s},attrs:{shape:[r,n]},backend:a}),i=Xt(c,"float32","mean",a),l=U({inputs:{x:i},attrs:{shape:e},backend:a});return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(i),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RA={kernelName:Lc,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:a}=s,{keepDims:n,axis:o}=t,r=e,c=a.shape.length,i=Ae(o,a.shape);let l=i;const u=et(l,c),d=u!=null,p=r.shouldExecuteOnCPU([a]),h=[];let f=a;if(d){if(p){const $=r.texData.get(f.dataId).values,I=new Array(c);for(let w=0;w<I.length;w++)I[w]=a.shape[u[w]];const v=Fa($,a.shape,a.dtype,u,I);f=r.makeTensorInfo(I,a.dtype);const y=r.texData.get(f.dataId);y.values=v}else f=Fs(a,u,r);h.push(f),l=tt(l.length,c)}it("sum",l,c);const[x,m]=ht(f.shape,l);let g=x;n&&(g=St(x,i));const C=kA(f,m,g,r);for(const b of h)r.disposeIntermediateTensorInfo(b);return C}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NA(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a,c=n.shape.length,i=Ae(o,n.shape);let l=i;const u=et(l,c);let d=n;u!=null&&(d=Te({inputs:{x:n},backend:e,attrs:{perm:u}}),l=tt(l.length,n.shape.length)),it("min",l,c);const[p,h]=ht(d.shape,l),f=Y(h),x=U({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}}),m=Xt(x,x.dtype,"min",e);let g;if(r){const C=St(p,i);g=U({inputs:{x:m},backend:e,attrs:{shape:C}})}else g=U({inputs:{x:m},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(d),g}const TA={kernelName:Vc,backendName:"webgl",kernelFunc:NA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EA=Da+`
  return min(a, b);
`,FA=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Bn+`
  return result;
`,DA=ve({opSnippet:EA,packedOpSnippet:FA,cpuKernelImpl:S2}),OA={kernelName:Bc,backendName:"webgl",kernelFunc:DA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AA{constructor(t,e,a){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const n=t.length,o=pe(n),r=e.map(u=>u[0]).join(","),c=e.map((u,d)=>u[0]+t[d]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),l=a==="reflect"?0:1;if(n===1){this.userCode=`
        int start = ${r};
        int end = ${c};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${r});
      ${o} end = ${o}(${c});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PA{constructor(t,e,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,x)=>f[0]+t[x]+f[1]);const n=t.length,o=pe(n),r=e.map(f=>f[0]).join(","),c=e.map((f,x)=>f[0]+t[x]).join(","),i=Se("rc",n),l=Se("source",n),u=`${i[n-1]} < ${this.outputShape[n-1]}`,d=n===1?"source":`vec2(${l.slice(-2).join()})`,p=a==="reflect"?0:1;let h="";if(n===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${i[n-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${i[n-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${i[n-2]} += 1;
        if(${i[n-2]} < ${this.outputShape[n-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${i[n-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${r});
      const ${o} end = ${o}(${c});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _A=({inputs:s,backend:t,attrs:e})=>{const{x:a}=s,{paddings:n,mode:o}=e,r=A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PA(a.shape,n,o):new AA(a.shape,n,o);return t.runWebGLProgram(r,[a],a.dtype)},MA={kernelName:Wc,backendName:"webgl",kernelFunc:_A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LA=`if (b == 0.0) return NAN;
  return mod(a, b);`,VA=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Bn+`
  return result;
`,BA=ve({opSnippet:LA,packedOpSnippet:VA}),WA={kernelName:zc,backendName:"webgl",kernelFunc:BA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zA{constructor(t,e,a){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,a],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UA=`
if (a == b) {
  return 1.0;
};
return a / b;`,GA=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Fd=ve({opSnippet:UA,packedOpSnippet:GA,checkOutOfBounds:!0}),HA={kernelName:il,backendName:"webgl",kernelFunc:Fd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ko="return a - b;",Dd=ve({opSnippet:ko,packedOpSnippet:ko,supportsComplex:!0,cpuKernelImpl:G2}),XA={kernelName:Xl,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Od(s){const{inputs:t,backend:e,attrs:a}=s,{logits:n}=t,{dim:o}=a,r=Ae([o],n.shape),c=Ed({inputs:{x:n},backend:e,attrs:{reductionIndices:r,keepDims:!1}}),i=St(c.shape,r),l=U({inputs:{x:c},backend:e,attrs:{shape:i}}),u=Dd({inputs:{a:n,b:l},backend:e}),d=Rd({inputs:{x:u},backend:e}),p=Ds({inputs:{x:d},backend:e,attrs:{axis:r,keepDims:!1}}),h=U({inputs:{x:p},backend:e,attrs:{shape:i}}),f=Fd({inputs:{a:d,b:h},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),f}const qA={kernelName:Tl,backendName:"webgl",kernelFunc:Od};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(s){const{inputs:t,backend:e,attrs:a}=s,{logits:n}=t,{numSamples:o,seed:r,normalized:c}=a,i=c?n:Od({inputs:{logits:n},backend:e,attrs:{dim:n.shape.length-1}}),l=i.shape[0],u=i.shape[1],d=new zA(l,u,o),p=[[r]],h=e.runWebGLProgram(d,[i],"int32",p);return c||e.disposeIntermediateTensorInfo(i),h}const KA={kernelName:Uc,backendName:"webgl",kernelFunc:jA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YA=Ke+`
  return -x;
`,QA=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ZA(s){const{inputs:t,backend:e}=s,{x:a}=t;if(e.shouldExecuteOnCPU([a])){const o=e.texData.get(a.dataId),[r,c]=R2(o.values,a.shape,a.dtype);return e.makeTensorInfo(c,a.dtype,r)}let n;return A().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new _t(a.shape,QA):n=new ut(a.shape,YA),e.runWebGLProgram(n,[a],a.dtype)}const JA={kernelName:Hc,backendName:"webgl",kernelFunc:ZA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eP=Kr;function tP(s){Cs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i}=a,l=e.readSync(n.dataId),u=e.readSync(o.dataId),{selectedIndices:d}=eP(l,u,r,c,i);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const nP={kernelName:Xc,backendName:"webgl",kernelFunc:tP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP=Yr;function aP(s){Cs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i,padToMaxOutputSize:l}=a,u=e.readSync(n.dataId),d=e.readSync(o.dataId),{selectedIndices:p,validOutputs:h}=sP(u,d,r,c,i,l);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([h]))]}const oP={kernelName:qc,backendName:"webgl",kernelFunc:aP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rP=Qr;function iP(s){Cs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:a}=s,{boxes:n,scores:o}=t,{maxOutputSize:r,iouThreshold:c,scoreThreshold:i,softNmsSigma:l}=a,u=e.readSync(n.dataId),d=e.readSync(o.dataId),p=r,h=c,f=i,x=l,{selectedIndices:m,selectedScores:g}=rP(u,d,p,h,f,x);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const cP={kernelName:jc,backendName:"webgl",kernelFunc:iP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lP{constructor(t,e,a,n){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${a}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uP=s=>{const{inputs:t,backend:e,attrs:a}=s,{indices:n}=t,{dtype:o,depth:r,onValue:c,offValue:i}=a,l=Y(n.shape),u=new lP(l,r,c,i),d=U({inputs:{x:n},backend:e,attrs:{shape:[l]}}),p=e.runWebGLProgram(u,[d],o);e.disposeIntermediateTensorInfo(d);const h=[...n.shape,r],f=U({inputs:{x:p},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(p),f},dP={kernelName:Yc,backendName:"webgl",kernelFunc:uP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ps(s){const{inputs:t,backend:e}=s,{x:a}=t;if(a.dtype==="complex64"){const n=zn({inputs:{input:a},backend:e}),o=ps({inputs:{x:n},backend:e}),r=Os({inputs:{input:a},backend:e}),c=ps({inputs:{x:r},backend:e}),i=Et({inputs:{real:o,imag:c},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(c),i}else return Un({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:e})}const pP={kernelName:su,backendName:"webgl",kernelFunc:ps};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ad(s){const{inputs:t,backend:e}=s,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){const n=zn({inputs:{input:a},backend:e}),o=Ad({inputs:{x:n},backend:e}),r=Os({inputs:{input:a},backend:e}),c=ps({inputs:{x:r},backend:e}),i=Et({inputs:{real:o,imag:c},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(c),i}else return Un({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:e})}const hP={kernelName:Qc,backendName:"webgl",kernelFunc:Ad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(s){const{inputs:t,backend:e,attrs:a}=s,{axis:n}=a;if(t.length===1)return ra({inputs:{input:t[0]},backend:e,attrs:{dim:n}});const o=t[0].shape,r=t[0].dtype;t.forEach(u=>{XC(o,u.shape,"All tensors passed to stack must have matching shapes"),ae(r===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const c=[],i=t.map(u=>{const d=ra({inputs:{input:u},backend:e,attrs:{dim:n}});return c.push(d),d}),l=$d({inputs:i,backend:e,attrs:{axis:n}});return c.forEach(u=>e.disposeIntermediateTensorInfo(u)),l}const mP={kernelName:Zc,backendName:"webgl",kernelFunc:fP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gP{constructor(t,e,a){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,u)=>l[0]+t[u]+l[1]);const n=t.length,o=pe(n),r=e.map(l=>l[0]).join(","),c=e.map((l,u)=>l[0]+t[u]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(n===1){this.userCode=`
        int start = ${r};
        int end = ${c};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${r});
      ${o} end = ${o}(${c});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xP{constructor(t,e,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((x,m)=>x[0]+t[m]+x[1]);const n=t.length,o=pe(n),r=e.map(x=>x[0]).join(","),c=e.map((x,m)=>x[0]+t[m]).join(","),i=Se("rc",n),l=Se("source",n),u=`${i[n-1]} < ${this.outputShape[n-1]}`,d=n===1?"source":`vec2(${l.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${i[n-1]} += 1;
       if(${u}) {
      `,n===1?"":`}
       rc = outputLoc;
       ${i[n-2]} += 1;
       if(${i[n-2]} < ${this.outputShape[n-2]}) {`,n===1?"":`  ${i[n-1]} += 1;
         if(${u}) {`],h=n===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let x=0,m=n===1?2:4;x<m;x++)f+=`
        ${p[x]}
        if (${h}) {
          result[${x}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${x}] = getChannel(getX(${l.join()}), ${d});
        }
      `;f+=n===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${r});
      const ${o} end = ${o}(${c});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pd=s=>{const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{paddings:o,constantValue:r}=a;if(Y(n.shape)===0){const l=o.map((u,d)=>u[0]+n.shape[d]+u[1]);return Un({backend:e,attrs:{shape:l,value:r,dtype:n.dtype}})}const c=A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xP(n.shape,o,r):new gP(n.shape,o,r),i=[[r]];return e.runWebGLProgram(c,[n],n.dtype,i)},CP={kernelName:Jc,backendName:"webgl",kernelFunc:Pd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,bP=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Bn+`
  return result;
`,IP=ve({opSnippet:$P,packedOpSnippet:bP}),vP={kernelName:el,backendName:"webgl",kernelFunc:IP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{axis:o,keepDims:r}=a,c=n.shape.length,i=[],l=Ae(o,n.shape);let u=l;const d=et(u,c);let p=n;d!=null&&(p=Te({inputs:{x:n},backend:e,attrs:{perm:d}}),u=tt(u.length,c),i.push(p)),it("prod",u,c);let h;if(e.shouldExecuteOnCPU([p])){const f=e.texData.get(p.dataId).values,{outVals:x,outShape:m,outDtype:g}=T2(p.shape,p.dtype,f,u);h=e.makeTensorInfo(m,g,x)}else{const[f,x]=ht(p.shape,u),m=Y(x),g=U({inputs:{x:p},backend:e,attrs:{shape:[-1,m]}}),C=xs(n.dtype),b=Xt(g,C,"prod",e);h=U({inputs:{x:b},backend:e,attrs:{shape:f}}),i.push(g),i.push(b)}if(r){i.push(h);const f=St(h.shape,l);h=U({inputs:{x:h},backend:e,attrs:{shape:f}})}return i.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const wP={kernelName:nl,backendName:"webgl",kernelFunc:yP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SP(s){const{inputs:t,backend:e,attrs:a}=s,{paramsNestedSplits:n,paramsDenseValues:o,indices:r}=t,{outputRaggedRank:c}=a,i=n.map(g=>e.readSync(g.dataId)),l=n.map(g=>g.shape),u=e.readSync(o.dataId),d=e.readSync(r.dataId),[p,h,f]=E2(i,l,u,o.shape,o.dtype,d,r.shape,c),x=p.map(g=>e.makeTensorInfo([g.length],"int32",g)),m=e.makeTensorInfo(f,o.dtype,h);return x.concat([m])}const kP={kernelName:sl,backendName:"webgl",kernelFunc:SP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(s){const{inputs:t,backend:e,attrs:a}=s,{shape:n,values:o,defaultValue:r,rowPartitionTensors:c}=t,{rowPartitionTypes:i}=a,l=e.readSync(n.dataId),u=e.readSync(o.dataId),d=e.readSync(r.dataId),p=c.map(m=>e.readSync(m.dataId)),h=c.map(m=>m.shape),[f,x]=F2(l,n.shape,u,o.shape,o.dtype,d,r.shape,p,h,i);return e.makeTensorInfo(f,o.dtype,x)}const NP={kernelName:al,backendName:"webgl",kernelFunc:RP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _d=s=>{const{backend:t,attrs:e}=s,{start:a,stop:n,step:o,dtype:r}=e,c=D2(a,n,o,r);return t.makeTensorInfo([c.length],r,c)},TP={kernelName:ol,backendName:"webgl",kernelFunc:_d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP="return 1.0 / x;",FP=se({opSnippet:EP}),DP={kernelName:cl,backendName:"webgl",kernelFunc:FP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP=Ke+`
  return (x < 0.0) ? 0.0 : x;
`,AP=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,PP=se({opSnippet:OP,packedOpSnippet:AP}),_P={kernelName:ll,backendName:"webgl",kernelFunc:PP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP=Ke+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,LP=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VP=se({opSnippet:MP,packedOpSnippet:LP}),BP={kernelName:ul,backendName:"webgl",kernelFunc:VP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WP{constructor(t,e,a,n,o){this.variableNames=["A"],this.outputShape=[];const[r,c,i,l]=t;this.outputShape=[r,e,a,l];const u=[n&&e>1?c-1:c,n&&a>1?i-1:i],d=[n&&e>1?e-1:e,n&&a>1?a-1:a];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${c}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zP{constructor(t,e,a,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,c,i,l]=t;this.outputShape=[r,e,a,l];const u=[n&&e>1?c-1:c,n&&a>1?i-1:i],d=[n&&e>1?e-1:e,n&&a>1?a-1:a];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${c}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${a-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UP(s){const{inputs:t,backend:e,attrs:a}=s,{images:n}=t,{alignCorners:o,halfPixelCenters:r,size:c}=a,[i,l]=c,u=A().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zP(n.shape,i,l,o,r):new WP(n.shape,i,l,o,r);return e.runWebGLProgram(u,[n],"float32")}const GP={kernelName:pl,backendName:"webgl",kernelFunc:UP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HP{constructor(t,e,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,n,o]=e,[,r,c]=t,i=[a&&r>1?n-1:n,a&&c>1?o-1:o],l=[a&&r>1?r-1:r,a&&c>1?c-1:c],u=i[0]/l[0],d=i[1]/l[1],p=1/u,h=1/d,f=Math.ceil(p)*2+2,x=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${r}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${c}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(s){const{inputs:t,backend:e,attrs:a}=s,{images:n,dy:o}=t,{alignCorners:r}=a,c=new HP(o.shape,n.shape,r);return e.runWebGLProgram(c,[o],o.dtype)}const qP={kernelName:hl,backendName:"webgl",kernelFunc:XP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jP{constructor(t,e,a,n,o){this.variableNames=["A"],this.outputShape=[];const[r,c,i,l]=t;this.outputShape=[r,e,a,l];const u=[n&&e>1?c-1:c,n&&a>1?i-1:i],d=[n&&e>1?e-1:e,n&&a>1?a-1:a],p=n?"0.5":"0.0";let h;o?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${c}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KP{constructor(t,e,a,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,c,i,l]=t;this.outputShape=[r,e,a,l];const u=[n&&e>1?c-1:c,n&&a>1?i-1:i],d=[n&&e>1?e-1:e,n&&a>1?a-1:a],p=n?"0.5":"0.0";let h;o?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${c}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${a-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(s){const{inputs:t,backend:e,attrs:a}=s,{images:n}=t,{alignCorners:o,halfPixelCenters:r,size:c}=a,[i,l]=c,u=A().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new KP(n.shape,i,l,o,r):new jP(n.shape,i,l,o,r);return e.runWebGLProgram(u,[n],n.dtype)}const QP={kernelName:fl,backendName:"webgl",kernelFunc:YP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZP{constructor(t,e,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,n,o]=e,[,r,c]=t,i=[a&&r>1?n-1:n,a&&c>1?o-1:o],l=[a&&r>1?r-1:r,a&&c>1?c-1:c],u=i[0]/l[0],d=i[1]/l[1],p=1/u,h=1/d,f=Math.ceil(p)*2+2,x=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${r}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${c}) {
              continue;
            }

            float sourceFracRow =
              float(${i[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${i[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${a} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${a} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(s){const{inputs:t,backend:e,attrs:a}=s,{images:n,dy:o}=t,{alignCorners:r}=a,c=new ZP(o.shape,n.shape,r);return e.runWebGLProgram(c,[o],o.dtype)}const e_={kernelName:ml,backendName:"webgl",kernelFunc:JP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t_{constructor(t,e){this.variableNames=["x"];const a=t.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);if(this.outputShape=t,a===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const n=c=>e.indexOf(c)!==-1&&t[c]!==1?`${t[c]} - coords[${c}] - 1`:`coords[${c}]`,o=t.map((c,i)=>n(i)).join(","),r=pe(a);this.userCode=`
      void main() {
        ${r} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n_{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const a=t.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);this.outputShape=t;const n=Se("rc",a),o=`${n[a-1]} + 1 < ${this.outputShape[a-1]}`,r=`${n[a-2]} + 1 < ${this.outputShape[a-2]}`,c=pe(a);a===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${c} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${i(n.slice())};
          if(${o}){
            result.g = ${l(n.slice())};
          }
          if(${r}) {
            result.b = ${u(n.slice())};
            if(${o}) {
              result.a = ${d(n.slice())};
            }
          }
          setOutput(result);
        }
    `;function i(f){return p(f)}function l(f){return f[a-1]="("+f[a-1]+" + 1)",p(f)}function u(f){return f[a-2]="("+f[a-2]+" + 1)",p(f)}function d(f){return f[a-1]="("+f[a-1]+" + 1)",f[a-2]="("+f[a-2]+" + 1)",p(f)}function p(f){const x=t.map((C,b)=>h(b,f)),m=x.join(","),g=x.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function h(f,x){return e.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${x[f]} - 1`:`${x[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{dims:o}=a,r=n.shape.length,c=Ae(o,n.shape);if(r===0)return Be({inputs:{x:n},backend:e});const i=A().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n_(n.shape,c):new t_(n.shape,c);return e.runWebGLProgram(i,[n],n.dtype)}const a_={kernelName:gl,backendName:"webgl",kernelFunc:s_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o_{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const a=t[1],n=t[2];this.outputShape=t;let o="";typeof e=="number"?o=`float outputValue = ${e.toFixed(2)};`:o=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${a}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_={kernelName:xl,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:a}=s,{radians:n,fillValue:o,center:r}=t,c=e,i=new o_(a.shape,o),[l,u]=M0(r,a.shape[1],a.shape[2]),d=[[l,u,Math.sin(n),Math.cos(n)]];return c.runWebGLProgram(i,[a],a.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,c_=se({opSnippet:i_}),l_={kernelName:Cl,backendName:"webgl",kernelFunc:c_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_="return inversesqrt(x);",d_=se({opSnippet:u_,cpuKernelImpl:O2}),p_={kernelName:$l,backendName:"webgl",kernelFunc:d_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Md{constructor(t,e,a,n,o,r,c=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=r;const i=pe(o.length),l=pe(r.length);let u="";a===1?u="i":a===2&&(u="i, j");const d=`getIndices(${u})`;let p="";n===1?p="i":n===2&&(p="i, coords[1]");const h=`getUpdates(${p})`,f=e>1?"strides[j]":"strides";this.userCode=`
        ${i} strides = ${i}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(s){const{inputs:t,backend:e,attrs:a}=s,{indices:n,updates:o}=t,{shape:r}=a,{sliceRank:c,numUpdates:i,sliceSize:l,strides:u,outputSize:d}=pu(o,n,r),p=[d/l,l];if(d===0)return e.makeTensorInfo(r,n.dtype);const h=U({inputs:{x:n},backend:e,attrs:{shape:[i,c]}}),f=U({inputs:{x:o},backend:e,attrs:{shape:[i,l]}}),x=e.makeTensorInfo([],"float32",new Float32Array([0])),m=new Md(i,c,h.shape.length,f.shape.length,u,p),g=e.runWebGLProgram(m,[f,h,x],f.dtype),C=U({inputs:{x:g},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),C}const f_={kernelName:bl,backendName:"webgl",kernelFunc:h_};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m_{constructor(t,e,a,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,a];const o="while (left < right) {",r=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,c=A().getNumber("WEBGL_VERSION")===2?o:r,i=n==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${c}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${i} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(s){const{inputs:t,backend:e,attrs:a}=s,{sortedSequence:n,values:o}=t,{side:r}=a,c=new m_(n.shape[0],n.shape[1],o.shape[1],r),i=[[n.shape[1]]];return e.runWebGLProgram(c,[n,o],"int32",i)}const x_={kernelName:Il,backendName:"webgl",kernelFunc:g_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C_{constructor(t,e,a){this.variableNames=["c","a","b"],this.outputShape=e;let n,o;if(a>4)throw Error(`Where for rank ${a} is not yet supported`);if(a===1)o="resRC",n="resRC";else{const c=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],l=[];for(let u=0;u<e.length;u++)l.push(`${c[u]}`),u<t&&i.push(`${c[u]}`);n=i.join(),o=l.join()}const r=pe(a);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(s){const{inputs:t,backend:e}=s,{condition:a,t:n,e:o}=t,r=new C_(a.shape.length,n.shape,n.shape.length);return e.runWebGLProgram(r,[a,n,o],vt(n.dtype,o.dtype))}const b_={kernelName:vl,backendName:"webgl",kernelFunc:$_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${L0};
  float scale = ${V0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,v_=se({opSnippet:I_}),y_={kernelName:yl,backendName:"webgl",kernelFunc:v_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w_=gn+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,S_=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,k_=se({opSnippet:w_,packedOpSnippet:S_,cpuKernelImpl:P2}),R_={kernelName:wl,backendName:"webgl",kernelFunc:k_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,T_=se({opSnippet:N_}),E_={kernelName:Sl,backendName:"webgl",kernelFunc:T_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F_=gn+`
  return sin(x);
`,D_=se({opSnippet:F_}),O_={kernelName:kl,backendName:"webgl",kernelFunc:D_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A_=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,P_=se({opSnippet:A_}),__={kernelName:Rl,backendName:"webgl",kernelFunc:P_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,L_=se({opSnippet:M_}),V_={kernelName:El,backendName:"webgl",kernelFunc:L_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B_=s=>{const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{blockShape:o,paddings:r}=a;ae(n.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const c=o.reduce((g,C)=>g*C),i=[[0,0]];i.push(...r);for(let g=1+o.length;g<n.shape.length;++g)i.push([0,0]);const l=[],u=Pd({inputs:{x:n},backend:e,attrs:{paddings:i,constantValue:0}}),d=fu(u.shape,o,c,!1),p=mu(d.length,o.length,!1),h=gu(u.shape,o,c,!1),f=U({inputs:{x:u},backend:e,attrs:{shape:d}}),x=Te({inputs:{x:f},backend:e,attrs:{perm:p}}),m=U({inputs:{x},backend:e,attrs:{shape:h}});return l.push(u),l.push(f),l.push(x),l.forEach(g=>e.disposeIntermediateTensorInfo(g)),m},W_={kernelName:Fl,backendName:"webgl",kernelFunc:B_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_(s){const{inputs:t,backend:e}=s,{indices:a,values:n,denseShape:o,defaultValue:r}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${n.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const c=e.readSync(a.dataId),i=e.readSync(n.dataId),l=e.readSync(o.dataId),u=e.readSync(r.dataId)[0],[d,p,h,f,x]=M2(c,a.shape,a.dtype,i,n.dtype,l,u);return[e.makeTensorInfo(p,a.dtype,d),e.makeTensorInfo([p[0]],n.dtype,h),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([x.length],a.dtype,new Int32Array(x))]}const U_={kernelName:Dl,backendName:"webgl",kernelFunc:z_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(s){const{inputs:t,backend:e}=s,{inputIndices:a,inputShape:n,newShape:o}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const r=Array.from(e.readSync(n.dataId)),c=e.readSync(a.dataId),i=Array.from(e.readSync(o.dataId)),[l,u,d]=L2(c,a.shape,a.dtype,r,i);return[e.makeTensorInfo(u,a.dtype,l),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const H_={kernelName:Ol,backendName:"webgl",kernelFunc:G_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_(s){const{inputs:t,backend:e}=s,{data:a,indices:n,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${n.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const r=e.readSync(a.dataId),c=e.readSync(n.dataId),i=e.readSync(o.dataId),[l,u]=rd(r,a.shape,a.dtype,c,i,!0);return e.makeTensorInfo(u,a.dtype,l)}const q_={kernelName:Al,backendName:"webgl",kernelFunc:X_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(s){const{inputs:t,backend:e}=s,{data:a,indices:n,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${n.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const r=e.readSync(a.dataId),c=e.readSync(n.dataId),i=e.readSync(o.dataId),[l,u]=rd(r,a.shape,a.dtype,c,i);return e.makeTensorInfo(u,a.dtype,l)}const K_={kernelName:Pl,backendName:"webgl",kernelFunc:j_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(s){const{inputs:t,backend:e,attrs:a}=s,{sparseIndices:n,sparseValues:o,defaultValue:r}=t,{outputShape:c}=a,{sliceRank:i,numUpdates:l,sliceSize:u,strides:d,outputSize:p}=pu(o,n,c),h=!1;if(o.dtype==="string"){const g=e.bufferSync(n),C=e.bufferSync(o),b=xa(e.readSync(r.dataId)[0]),$=A2(g,C,c,p,u,l,i,d,b,h);return e.makeTensorInfo(c,$.dtype,$.values)}const f=new Md(l,i,n.shape.length,o.shape.length,d,[p,1],h),x=e.runWebGLProgram(f,[o,n,r],o.dtype),m=U({inputs:{x},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(x),m}const Q_={kernelName:_l,backendName:"webgl",kernelFunc:Y_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{numOrSizeSplits:o,axis:r}=a,c=Ae(r,n.shape)[0],i=B0(n,o,c),l=n.shape.length,u=new Array(l).fill(0),d=n.shape.slice();return i.map(p=>{const h=[...d];h[c]=p;const f=xn({inputs:{x:n},backend:e,attrs:{begin:u,size:h}});return u[c]+=p,f})}const J_={kernelName:Ml,backendName:"webgl",kernelFunc:Z_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ro="return sqrt(x);",eM=se({opSnippet:Ro,packedOpSnippet:Ro,cpuKernelImpl:V2}),tM={kernelName:Ll,backendName:"webgl",kernelFunc:eM};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM="return x * x;",sM=se({opSnippet:nM}),aM={kernelName:Vl,backendName:"webgl",kernelFunc:sM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No="return (a - b) * (a - b);",oM=ve({opSnippet:No,packedOpSnippet:No}),rM={kernelName:Bl,backendName:"webgl",kernelFunc:oM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iM({inputs:s,attrs:t,backend:e}){const{x:a}=s,n=Ke+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,o=new ut(a.shape,n);return e.runWebGLProgram(o,[a],a.dtype)}const cM={kernelName:Wl,backendName:"webgl",kernelFunc:iM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lM{constructor(t,e,a){this.variableNames=["x"],this.outputShape=a;const n=a.length,o=pe(a.length),r=pe(a.length);let c="";if(n===1)c="coords * strides + begin";else{let i=0;c=a.map((l,u)=>(i++,a.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${i-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${t});
      ${o} strides = ${o}(${e});

      void main() {
        ${r} coords = getOutputCoords();
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{begin:o,end:r,strides:c,beginMask:i,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=a,{finalShapeSparse:h,finalShape:f,isIdentity:x,sliceDim0:m,isSimpleSlice:g,begin:C,end:b,strides:$}=W0(n.shape,o,r,c,i,l,u,d,p);let I;if(x)I=U({inputs:{x:n},backend:e,attrs:{shape:f}});else if(m||g){ae(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);const y=z0(C,b,$),w=xn({inputs:{x:n},backend:e,attrs:{begin:C,size:y}});I=U({inputs:{x:w},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(w)}else if(e.shouldExecuteOnCPU([n])){const w=e.readSync(n.dataId),k=Ve(n.shape,n.dtype,w),S=B2(h,k,$,C);I=e.makeTensorInfo(f,n.dtype,S.values)}else{const w=new lM(C,$,h);I=e.runWebGLProgram(w,[n],n.dtype)}const v=U({inputs:{x:I},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(I),v}const dM={kernelName:zl,backendName:"webgl",kernelFunc:uM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(s){const{inputs:t,backend:e,attrs:a}=s,{separator:n,nGramWidths:o,leftPad:r,rightPad:c,padWidth:i,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,p=e.readSync(u.dataId),h=e.readSync(d.dataId),[f,x]=W2(p,h,n,o,r,c,i,l);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",x)]}const hM={kernelName:Ul,backendName:"webgl",kernelFunc:pM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fM(s){const{inputs:t,backend:e,attrs:a}=s,{skipEmpty:n}=a,{input:o,delimiter:r}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const c=e.readSync(o.dataId),i=e.readSync(r.dataId)[0],[l,u,d]=z2(c,i,n),p=u.length;return[e.makeTensorInfo([p,2],"int32",l),e.makeTensorInfo([p],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const mM={kernelName:Gl,backendName:"webgl",kernelFunc:fM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gM(s){const{inputs:t,backend:e,attrs:a}=s,{numBuckets:n}=a,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");const r=e.readSync(o.dataId),c=U2(r,n);return e.makeTensorInfo(o.shape,"int32",c)}const xM={kernelName:Hl,backendName:"webgl",kernelFunc:gM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM="return tan(x);",$M=se({opSnippet:CM}),bM={kernelName:jl,backendName:"webgl",kernelFunc:$M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IM=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,vM=se({opSnippet:IM}),yM={kernelName:Kl,backendName:"webgl",kernelFunc:vM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wM{constructor(t,e){this.variableNames=["A"];const a=new Array(t.length);for(let r=0;r<a.length;r++)a[r]=t[r]*e[r];this.outputShape=a,this.rank=a.length;const n=pe(this.rank),o=SM(t);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function SM(s){const t=s.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${s[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let n=0;n<s.length;n++)a.push(`imod(${e[n]}, ${s[n]})`);return a.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{reps:o}=a;if(n.dtype==="string"||n.shape.length>5){const i=e.readSync(n.dataId),l=n.dtype==="string"?i.map(p=>xa(p)):i,u=Ve(n.shape,n.dtype,l),d=H2(u,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const r=new wM(n.shape,o);return e.runWebGLProgram(r,[n],n.dtype)}const kM={kernelName:Yl,backendName:"webgl",kernelFunc:Ld};class RM{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class NM{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot(s,t){t!==null&&s.disposeIntermediateTensorInfo(t)}function To(s){let t=1;for(;t<s;)t*=2;return t}function TM(s){const{inputs:t,backend:e,attrs:a}=s,{x:n}=t,{k:o,sorted:r}=a,c=A().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),i=A().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=n.shape,u=l[l.length-1];if(e.shouldExecuteOnCPU([n])||u<c||o>i){const S=e.readSync(n.dataId),[E,O]=X2(S,l,n.dtype,o,r);return[e.makeTensorInfo(E.shape,E.dtype,E.values),e.makeTensorInfo(O.shape,O.dtype,O.values)]}if(o===0)return l[l.length-1]=0,[e.makeTensorInfo(l,n.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(u===1)return[n,Un({attrs:{shape:l,dtype:"int32",value:0},backend:e})];const d=e.texData.get(n.dataId),p=d!==null&&d.isPacked,h=p?e.unpackTensor(n):n,x=Y(l)/u,m=U({inputs:{x:h},attrs:{shape:[x,u]},backend:e});p&&Ot(e,h);const g=To(o),C=To(u);let b=null;const $=()=>b===null?[m,m]:[m,b],I=(S,E,O)=>{const F=$(),D=new RM(O),T=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[S],[E]],_=b;b=e.runWebGLProgram(D,F,"int32",T),Ot(e,_)};for(let S=1;S<g;S*=2){const E=S*2;for(let O=S;O>=1;O/=2)I(E,O,[x,C])}for(let S=C;S>g;S/=2){const E=$(),O=new NM([x,S/2]),D=[[u],[b===null?1:0],[g]],N=b;b=e.runWebGLProgram(O,E,"int32",D),Ot(e,N);const T=g/2,_=T*2;for(let R=T;R>=1;R/=2)I(_,R,b.shape)}let v=b;b=xn({inputs:{x:b},backend:e,attrs:{begin:0,size:[x,o]}}),Ot(e,v);let y=Td({inputs:{x:m,indices:b},backend:e,attrs:{axis:1,batchDims:1}});Ot(e,m);const w=l.slice(0,-1);w.push(o),v=b,b=U({inputs:{x:b},attrs:{shape:w},backend:e}),Ot(e,v);const k=y;return y=U({inputs:{x:y},attrs:{shape:w},backend:e}),Ot(e,k),[y,b]}const EM={kernelName:Ql,backendName:"webgl",kernelFunc:TM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FM{constructor(t,e,a,n,o,r){this.variableNames=["Image","Transforms"],this.outputShape=r;const c=a==="nearest"?1:2;let i;switch(n){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${c} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DM(s){const{inputs:t,backend:e,attrs:a}=s,{image:n,transforms:o}=t,{interpolation:r,fillMode:c,fillValue:i,outputShape:l}=a,[u,d,p,h]=n.shape,[f,x]=l??[d,p],m=[u,f,x,h],g=new FM(d,p,r,c,i,m);return e.runWebGLProgram(g,[n,o],"float32")}const OM={kernelName:Zl,backendName:"webgl",kernelFunc:DM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AM(s){const{inputs:t,attrs:e,backend:a}=s,{axis:n}=e,{x:o}=t;Ln(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const r=a.readSync(o.dataId),{outputValues:c,outputShape:i,indices:l}=q2(r,n,o.shape,o.dtype);return[a.makeTensorInfo(i,o.dtype,c),a.makeTensorInfo([l.length],"int32",l)]}const PM={kernelName:eu,backendName:"webgl",kernelFunc:AM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _M(s){const{inputs:t,backend:e,attrs:a}=s,{value:n}=t;let{axis:o}=a;o<0&&(o+=n.shape.length);const r=n,c=r.shape.length,i=n.shape[o],l=new Array(c-1);let u=0;for(let x=0;x<c;x++)x!==o&&(l[u++]=r.shape[x]);const d=[],p=new Array(c).fill(0),h=r.shape.slice();h[o]=1;const f=new Array(i);for(let x=0;x<f.length;x++){p[o]=x;const m=xn({inputs:{x:r},backend:e,attrs:{begin:p,size:h}}),g=U({inputs:{x:m},backend:e,attrs:{shape:l}});f[x]=g,d.push(m)}return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),f}const MM={kernelName:tu,backendName:"webgl",kernelFunc:_M};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LM{constructor(t,e){this.variableNames=["x","segmentIds"];const a=t.windowSize,n=t.batchSize,o=t.inSize,r=t.numSegments,c=r*Math.ceil(o/a);this.outputShape=[n,c];const i="0.0",l="sumValue",u=Math.floor(a/4)*4,d=a%4,p=`
        sumValue += dot(values, segFilter);
    `;let h="";o%a>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%a>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${i};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${r})) * float(${a}));
        int currentSeg = int(mod(float(outIdx), float(${r})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VM(s){const{inputs:t,backend:e,attrs:a}=s,{x:n,segmentIds:o}=t,{numSegments:r}=a,c=n.shape.length,i=[];let l=0;const u=et([l],c);let d=n;u!=null&&(d=Te({inputs:{x:n},backend:e,attrs:{perm:u}}),i.push(d),l=tt(1,c)[0]);const p=U0(d.shape,l,r),h=Y([d.shape[l]]),f=U({inputs:{x:d},backend:e,attrs:{shape:[-1,h]}});i.push(f);const x=xs(n.dtype),m=($,I,v,y,w)=>{const k=$.shape[0],S=$.shape[1],E=G0(S,w),O={windowSize:E,inSize:S,batchSize:k,numSegments:w},F=new LM(O,I),D=e.compileAndRun(F,[$,v],y);if(i.push(D),D.shape[1]===w)return D;const N=_d({backend:e,attrs:{start:0,stop:w,step:1,dtype:"float32"}}),T=Ld({inputs:{x:N},backend:e,attrs:{reps:[S/E]}});return i.push(N),i.push(T),m(D,I,T,y,w)},g=m(f,"unsortedSegmentSum",o,x,r),C=U({inputs:{x:g},backend:e,attrs:{shape:p}});let b=C;if(u!=null){i.push(C);const $=du(u);b=Te({inputs:{x:b},backend:e,attrs:{perm:$}})}return i.forEach($=>e.disposeIntermediateTensorInfo($)),b}const BM={kernelName:nu,backendName:"webgl",kernelFunc:VM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WM=[LT,BT,UT,XT,jT,QT,JT,tE,oE,iE,uE,hE,gE,bE,yE,SE,RE,FE,OE,PE,VE,XE,jE,YE,nF,aF,cF,IT,dF,gF,bF,kF,NF,EF,DF,AF,MF,BF,UF,HF,qF,KF,ZF,eD,aD,rD,lD,pD,fD,CD,vD,kD,TD,DD,OD,PD,MD,VD,WD,UD,qD,YD,JD,tO,aO,iO,dO,mO,bT,xO,fF,bO,yO,kO,yT,EO,AO,_O,BO,UO,qO,YO,eA,aA,iA,lA,hA,mA,xA,IA,yA,SA,RA,TA,OA,MA,WA,KA,kT,JA,nP,oP,cP,ZE,dP,hP,mP,CP,vP,ST,wP,kP,NP,TP,JE,HA,DP,_P,BP,NT,GP,qP,QP,e_,a_,r_,l_,p_,f_,x_,b_,y_,R_,E_,O_,__,GE,qA,V_,W_,U_,H_,q_,K_,Q_,J_,tM,aM,rM,cM,dM,hM,mM,xM,XA,PT,bM,yM,kM,EM,OM,_T,PM,MM,BM,pP];for(const s of WM)iu(s);var hs={},zM={get exports(){return hs},set exports(s){hs=s}};const UM=Vr(C$),GM=Vr(g$);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(s,t){(function(e,a){a(t,UM,GM)})(im,function(e,a,n){const o={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class r{constructor(i,l){this.modelPath=l||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(i)}/model.json`}getPrefix(i){return i==="lite_mobilenet_v2"?`ssd${i}`:`ssd_${i}`}async load(){this.model=await a.loadGraphModel(this.modelPath);const i=n.zeros([1,300,300,3],"int32"),l=await this.model.executeAsync(i);await Promise.all(l.map(u=>u.data())),l.map(u=>u.dispose()),i.dispose()}async infer(i,l,u){const d=n.tidy(()=>(i instanceof n.Tensor||(i=n.browser.fromPixels(i)),n.expandDims(i))),p=d.shape[1],h=d.shape[2],f=await this.model.executeAsync(d),x=f[0].dataSync(),m=f[1].dataSync();d.dispose(),n.dispose(f);const[g,C]=this.calculateMaxScores(x,f[0].shape[1],f[0].shape[2]),b=n.getBackend();n.getBackend()==="webgl"&&n.setBackend("cpu");const $=n.tidy(()=>{const v=n.tensor2d(m,[f[1].shape[1],f[1].shape[3]]);return n.image.nonMaxSuppression(v,g,l,u,u)}),I=$.dataSync();return $.dispose(),b!==n.getBackend()&&n.setBackend(b),this.buildDetectedObjects(h,p,m,g,I,C)}buildDetectedObjects(i,l,u,d,p,h){const f=p.length,x=[];for(let m=0;m<f;m++){const g=[];for(let v=0;v<4;v++)g[v]=u[4*p[m]+v];const C=g[0]*l,b=g[1]*i,$=g[2]*l,I=g[3]*i;g[0]=b,g[1]=C,g[2]=I-b,g[3]=$-C,x.push({bbox:g,class:o[h[p[m]]+1].displayName,score:d[p[m]]})}return x}calculateMaxScores(i,l,u){const d=[],p=[];for(let h=0;h<l;h++){let f=Number.MIN_VALUE,x=-1;for(let m=0;m<u;m++)i[h*u+m]>f&&(f=i[h*u+m],x=m);d[h]=f,p[h]=x}return[d,p]}async detect(i,l=20,u=.5){return this.infer(i,l,u)}dispose(){this.model!=null&&this.model.dispose()}}e.ObjectDetection=r,e.load=async function(c={}){if(n==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const i=c.base||"lite_mobilenet_v2",l=c.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(i)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${i}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new r(i,l);return await u.load(),u},e.version="2.2.2",Object.defineProperty(e,"__esModule",{value:!0})})})(zM,hs);const HM={class:"coco-ssd"},XM=q0({__name:"CocoSsd",setup(s){const t={person:"",bicycle:"",car:"",motorcycle:"",airplane:"",bus:"",train:"",truck:"",boat:"","traffic light":"","fire hydrant":"","stop sign":"","parking meter":"",bench:"",bird:"",cat:"",dog:"",horse:"",sheep:"",cow:"",elephant:"",bear:"",zebra:"",giraffe:"",backpack:"",umbrella:"",handbag:"",tie:"",suitcase:"",frisbee:"",skis:"",snowboard:"","sports ball":"",kite:"","baseball bat":"","baseball glove":"",skateboard:"",surfboard:"","tennis racket":"",bottle:"","wine glass":"",cup:"",fork:"",knife:"",spoon:"",bowl:"",banana:"",apple:"",sandwich:"",orange:"",broccoli:"",carrot:"","hot dog":"",pizza:"",donut:"",cake:"",chair:"",couch:"","potted plant":"",bed:"","dining table":"",toilet:"",tv:"",laptop:"",mouse:"",remote:"",keyboard:"","cell phone":"",microwave:"",oven:"",toaster:"",sink:"",refrigerator:"",book:"",clock:"",vase:"",scissors:"","teddy bear":"","hair drier":"",toothbrush:""},e=Ms(),a=Ms(),n=Ms(!1);async function o(){if(!r.status)return;l(i.value);const f=u();(await h.detect(f)).forEach(m=>{const{bbox:g,class:C,score:b}=m;d(g,"rgba(64, 158, 255, 0.5)"),p({text:`${t[C]}${b}`,bbox:g,style:"#fff"})}),window.requestAnimationFrame(o)}const{videoConfig:r,videoButtonClick:c,newVideoRef:i}=X0({videoRef:e,videoProceed:o}),{drawImage:l,getImageData:u,fillRect:d,drawText:p}=H0({canvasRef:a});let h;return j0(async()=>{h=await hs.load(),n.value=!0}),(f,x)=>(ja(),qa("div",HM,[Ls("div",null,[Ls("video",{ref_key:"videoRef",ref:e,autoplay:""},null,512),Ls("canvas",{ref_key:"canvasRef",ref:a},null,512)]),n.value?(ja(),qa("button",{key:0,onClick:x[0]||(x[0]=(...m)=>Vs(c)&&Vs(c)(...m))},K0(Vs(r).status?"":"")+" ",1)):Y0("",!0)]))}});const JM=Q0(XM,[["__scopeId","data-v-86b0cb75"]]);export{JM as default};
